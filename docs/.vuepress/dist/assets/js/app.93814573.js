(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,a,i=e[0],l=e[1],c=e[2],u=0,d=[];u<i.length;u++)a=i[u],Object.prototype.hasOwnProperty.call(o,a)&&o[a]&&d.push(o[a][0]),o[a]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);d.length;)d.shift()();return s.push.apply(s,c||[]),t()}function t(){for(var n,e=0;e<s.length;e++){for(var t=s[e],r=!0,i=1;i<t.length;i++){var l=t[i];0!==o[l]&&(r=!1)}r&&(s.splice(e--,1),n=a(a.s=t[0]))}return n}var r={},o={1:0},s=[];function a(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var s,i=document.createElement("script");i.charset="utf-8",i.timeout=120,a.nc&&i.setAttribute("nonce",a.nc),i.src=function(n){return a.p+"assets/js/"+({}[n]||n)+"."+{2:"575522a8",3:"ef781ef2",4:"b7d52313",5:"722c3cce",6:"9164e6a8",7:"94da7503",8:"3a2f605c",9:"2bd9f9b0",10:"d15f6731",11:"045237c4",12:"5bc7125b",13:"0ff02159",14:"23e8e239",15:"9fadb4e1",16:"b6ee32be",17:"9893a8d9",18:"c65fd450",19:"6b0c5de8",20:"fcecb46b",21:"918763b5",22:"d702a3cd",23:"10fe2aa3",24:"769f2716",25:"d059d820",26:"257a50bd",27:"b6425e14",28:"792acd4f",29:"c1362419",30:"21e75c3d",31:"fc20f67b",32:"5bf688b5",33:"379ed7dc",34:"b6b3bb80",35:"e31e12bb",36:"c60072ab",37:"b11e2ad9",38:"af77f821",39:"86aab4b6",40:"3ae86ea7",41:"dbfc87a8",42:"851f8fa7",43:"68a8e939",44:"c3063688",45:"df865860",46:"cf2ad333",47:"a50d1f0c",48:"ab43ce56",49:"99cc89ac",50:"984af688",51:"df2895d2",52:"0765779d",53:"75b61a84",54:"1d282985",55:"3e651070",56:"7b66ae46",57:"a4efb873",58:"1d0529fe",59:"7852ce87",60:"74b5a094",61:"36275bb3",62:"316fa8a9",63:"4d0016b4",64:"aa3929b9",65:"af5feacb",66:"d16d9060",67:"02ac473c",68:"19535ecc",69:"e0759e95",70:"14f6004b",71:"bd6e4d8f",72:"3fc1d763",73:"c73a7f92",74:"dbd960e9",75:"81d2873d",76:"b6e75f73",77:"f63e336e",78:"9a3dc6d3",79:"61851bd9",80:"7286381b",81:"bfec15f9",82:"1196be60",83:"0d6f1914",84:"92995f4e"}[n]+".js"}(n);var l=new Error;s=function(e){i.onerror=i.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),s=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+s+")",l.name="ChunkLoadError",l.type=r,l.request=s,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){s({type:"timeout",target:i})}),12e4);i.onerror=i.onload=s,document.head.appendChild(i)}return Promise.all(e)},a.m=n,a.c=r,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)a.d(t,r,function(e){return n[e]}.bind(null,r));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="/",a.oe=function(n){throw console.error(n),n};var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=e,i=i.slice();for(var c=0;c<i.length;c++)e(i[c]);var p=l;s.push([100,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(25),o=Function.prototype,s=o.bind,a=o.call,i=r&&s.bind(a,a);n.exports=r?function(n){return n&&i(n)}:function(n){return n&&function(){return a.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(67),o="object"==typeof self&&self&&self.Object===Object&&self,s=r||o||Function("return this")();n.exports=s},function(n,e,t){"use strict";function r(n,e,t,r,o,s,a,i){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),s&&(c._scopeId="data-v-"+s),a?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},c._ssrRegister=l):o&&(l=i?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(1),o=t(45),s=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return s(o(n),e)}},function(n,e,t){var r=t(0);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(155),o=t(158);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return s})),t.d(e,"j",(function(){return a})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return y})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return x}));const r=/#.*$/,o=/\.(md|html)$/,s=/\/$/,a=/^[a-z]+:/i;function i(n){return decodeURI(n).replace(r,"").replace(o,"")}function l(n){return a.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",o=i(n);return s.test(o)?n:o+".html"+t}function d(n,e){const t=n.hash,o=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(o&&t!==o)return!1;return i(n.path)===i(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const o=e.split("/");t&&o[o.length-1]||o.pop();const s=n.replace(/^\//,"").split("/");for(let n=0;n<s.length;n++){const e=s[n];".."===e?o.pop():"."!==e&&o.push(e)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));const r=i(e);for(let e=0;e<n.length;e++)if(i(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:o,themeConfig:s}=t,a=r&&s.locales&&s.locales[r]||s;if("auto"===(n.frontmatter.sidebar||a.sidebar||s.sidebar))return m(n);const i=a.sidebar||s.sidebar;if(i){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,i);return"auto"===r?m(n):r?r.map(n=>function n(e,t,r,o=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const s=e.children||[];return 0===s.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:s.map(e=>n(e,t,r,o+1)),collapsable:!1!==e.collapsable}}}(n,o,t)):[]}return[]}function m(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function y(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return b(e)-b(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(14),o=t(140),s=t(141),a=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":a&&a in Object(n)?o(n):s(n)}},function(n,e,t){var r=t(5).Symbol;n.exports=r},function(n,e,t){var r=t(7),o=t(61),s=t(96),a=t(24),i=t(52),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?s?function(n,e,t){if(a(n),e=i(e),a(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(a(n),e=i(e),a(t),o)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(2),o=t(0),s=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?s(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(7),o=t(15),s=t(29);n.exports=r?function(n,e,t){return o.f(n,e,s(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(145),o=t(146),s=t(147),a=t(148),i=t(149);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=s,l.prototype.has=a,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(69);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(167);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(40);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function s(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,u=r.easing;return l.offsetWidth,a((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),i(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+s(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+s(n)+"%,0)"}:{"margin-left":s(n)+"%"}).transition="all "+e+"ms "+t,o}(n,p,u)),1===n?(i(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){i(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,a=e.querySelector(r.barSelector),l=n?"-100":s(t.status||0),p=document.querySelector(r.parent);return i(a,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&d(o),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var a=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),i=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,s=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+s)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,s=arguments;if(2==s.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,s[1],s[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n,e,t){var r=t(9),o=String,s=TypeError;n.exports=function(n){if(r(n))return n;throw s(o(n)+" is not an object")}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(43),o=t(51);n.exports=function(n){return r(o(n))}},function(n,e,t){var r=t(2),o=t(58),s=t(8),a=t(60),i=t(56),l=t(55),c=o("wks"),p=r.Symbol,u=p&&p.for,d=l?p:p&&p.withoutSetter||a;n.exports=function(n){if(!s(c,n)||!i&&"string"!=typeof c[n]){var e="Symbol."+n;i&&s(p,n)?c[n]=p[n]:c[n]=l&&u?u(e):d(e)}return c[n]}},function(n,e,t){var r=t(25),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(1),o=r({}.toString),s=r("".slice);n.exports=function(n){return s(o(n),8,-1)}},function(n,e,t){var r=t(2),o=t(32),s=r["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=s},function(n,e,t){var r=t(2),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(139),o=t(12),s=Object.prototype,a=s.hasOwnProperty,i=s.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&a.call(n,"callee")&&!i.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(5),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(159),o=t(166),s=t(168),a=t(169),i=t(170);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=s,l.prototype.has=a,l.prototype.set=i,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(4),o=t(40),s=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(a.test(n)||!s.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(13),o=t(12);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(2),o=t(50).f,s=t(17),a=t(108),i=t(32),l=t(63),c=t(120);n.exports=function(n,e){var t,p,u,d,f,h=n.target,m=n.global,g=n.stat;if(t=m?r:g?r[h]||i(h,{}):(r[h]||{}).prototype)for(p in e){if(d=e[p],u=n.dontCallGetSet?(f=o(t,p))&&f.value:t[p],!c(m?p:h+(g?".":"#")+p,n.forced)&&void 0!==u){if(typeof d==typeof u)continue;l(d,u)}(n.sham||u&&u.sham)&&s(d,"sham",!0),a(t,p,d,n)}}},function(n,e,t){var r=t(1),o=t(3),s=t(30),a=Object,i=r("".split);n.exports=o((function(){return!a("z").propertyIsEnumerable(0)}))?function(n){return"String"==s(n)?i(n,""):a(n)}:a},function(n,e,t){var r=t(0),o=t(106),s=TypeError;n.exports=function(n){if(r(n))return n;throw s(o(n)+" is not a function")}},function(n,e,t){var r=t(51),o=Object;n.exports=function(n){return o(r(n))}},function(n,e){n.exports={}},function(n,e,t){var r=t(118);n.exports=function(n){return r(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,s=/^0o[0-7]+$/i,a=parseInt,i="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=i||l||Function("return this")(),p=Object.prototype.toString,u=Math.max,d=Math.min,f=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var i=o.test(n);return i||s.test(n)?a(n.slice(2),i?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,s,a,i,l,c=0,p=!1,g=!1,y=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,s=o;return r=o=void 0,c=e,a=n.apply(s,t)}function b(n){return c=n,i=setTimeout(k,e),p?v(n):a}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=s}function k(){var n=f();if(x(n))return _(n);i=setTimeout(k,function(n){var t=e-(n-l);return g?d(t,s-(n-c)):t}(n))}function _(n){return i=void 0,y&&r?v(n):(r=o=void 0,a)}function S(){var n=f(),t=x(n);if(r=arguments,o=this,l=n,t){if(void 0===i)return b(l);if(g)return i=setTimeout(k,e),v(l)}return void 0===i&&(i=setTimeout(k,e)),a}return e=m(e)||0,h(t)&&(p=!!t.leading,s=(g="maxWait"in t)?u(m(t.maxWait)||0,e):s,y="trailing"in t?!!t.trailing:y),S.cancel=function(){void 0!==i&&clearTimeout(i),c=0,r=l=o=i=void 0},S.flush=function(){return void 0===i?a:_(f())},S}},function(n,e,t){var r=t(7),o=t(28),s=t(102),a=t(29),i=t(26),l=t(52),c=t(8),p=t(61),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=i(n),e=l(e),p)try{return u(n,e)}catch(n){}if(c(n,e))return a(!o(s.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var r=t(103),o=t(53);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e,t){var r=t(16),o=t(0),s=t(54),a=t(55),i=Object;n.exports=a?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return o(e)&&s(e.prototype,i(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(56);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(57),o=t(3);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,o,s=t(2),a=t(104),i=s.process,l=s.Deno,c=i&&i.versions||l&&l.version,p=c&&c.v8;p&&(o=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&a&&(!(r=a.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=a.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){var r=t(59),o=t(31);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.23.3",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),o=0,s=Math.random(),a=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+a(++o+s,36)}},function(n,e,t){var r=t(7),o=t(3),s=t(95);n.exports=!r&&!o((function(){return 7!=Object.defineProperty(s("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(1),o=t(0),s=t(31),a=r(Function.toString);o(s.inspectSource)||(s.inspectSource=function(n){return a(n)}),n.exports=s.inspectSource},function(n,e,t){var r=t(8),o=t(113),s=t(50),a=t(15);n.exports=function(n,e,t){for(var i=o(e),l=a.f,c=s.f,p=0;p<i.length;p++){var u=i[p];r(n,u)||t&&r(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var r=t(117);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(1),o=t(24),s=t(127);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return o(t),s(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(18),o=t(150),s=t(151),a=t(152),i=t(153),l=t(154);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=s,c.prototype.get=a,c.prototype.has=i,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(13),o=t(35);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(171),o=t(12);n.exports=function n(e,t,s,a,i){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,s,a,n,i))}},function(n,e,t){var r=t(74),o=t(174),s=t(75);n.exports=function(n,e,t,a,i,l){var c=1&t,p=n.length,u=e.length;if(p!=u&&!(c&&u>p))return!1;var d=l.get(n),f=l.get(e);if(d&&f)return d==e&&f==n;var h=-1,m=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var y=n[h],v=e[h];if(a)var b=c?a(v,y,h,e,n,l):a(y,v,h,n,e,l);if(void 0!==b){if(b)continue;m=!1;break}if(g){if(!o(e,(function(n,e){if(!s(g,e)&&(y===n||i(y,n,t,a,l)))return g.push(e)}))){m=!1;break}}else if(y!==v&&!i(y,v,t,a,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(36),o=t(172),s=t(173);function a(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}a.prototype.add=a.prototype.push=o,a.prototype.has=s,n.exports=a},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(184),o=t(190),s=t(80);n.exports=function(n){return s(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(5),o=t(186),s=e&&!e.nodeType&&e,a=s&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===s?r.Buffer:void 0,l=(i?i.isBuffer:void 0)||o;n.exports=l}).call(this,t(48)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(187),o=t(188),s=t(189),a=s&&s.isTypedArray,i=a?o(a):r;n.exports=i},function(n,e,t){var r=t(70),o=t(38);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(5),"Set");n.exports=r},function(n,e,t){var r=t(35);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(85),o=t(22);n.exports=function(n,e){for(var t=0,s=(e=r(e,n)).length;null!=n&&t<s;)n=n[o(e[t++])];return t&&t==s?n:void 0}},function(n,e,t){var r=t(4),o=t(39),s=t(201),a=t(204);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:s(a(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(137),o=t(142),s=t(213),a=t(221),i=t(230),l=t(99),c=s((function(n){var e=l(n);return i(e)&&(e=void 0),a(r(n,1,i,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=r.exec(t);if(!o)return t;var s="",a=0,i=0;for(a=o.index;a<t.length;a++){switch(t.charCodeAt(a)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}i!==a&&(s+=t.substring(i,a)),i=a+1,s+=e}return i!==a?s+t.substring(i,a):s}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(233),t(6)),s=Object(o.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=s.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},o=(t(234),t(6)),s=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=s.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(2),o=t(9),s=r.document,a=o(s)&&o(s.createElement);n.exports=function(n){return a?s.createElement(n):{}}},function(n,e,t){var r=t(7),o=t(3);n.exports=r&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(58),o=t(60),s=r("keys");n.exports=function(n){return s[n]||(s[n]=o(n))}},function(n,e,t){var r=t(1),o=t(8),s=t(26),a=t(115).indexOf,i=t(46),l=r([].push);n.exports=function(n,e){var t,r=s(n),c=0,p=[];for(t in r)!o(i,t)&&o(r,t)&&l(p,t);for(;e.length>c;)o(r,t=e[c++])&&(~a(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(239)},function(n,e,t){"use strict";var r=t(42),o=t(121).left,s=t(122),a=t(57),i=t(123);r({target:"Array",proto:!0,forced:!s("reduce")||!i&&a>79&&a<83},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,s=o&&!r.call({1:2},1);e.f=s?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(28),o=t(9),s=t(53),a=t(105),i=t(107),l=t(27),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!o(n)||s(n))return n;var t,l=a(n,p);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!o(t)||s(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),i(n,e)}},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(44);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(28),o=t(0),s=t(9),a=TypeError;n.exports=function(n,e){var t,i;if("string"===e&&o(t=n.toString)&&!s(i=r(t,n)))return i;if(o(t=n.valueOf)&&!s(i=r(t,n)))return i;if("string"!==e&&o(t=n.toString)&&!s(i=r(t,n)))return i;throw a("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),o=t(15),s=t(109),a=t(32);n.exports=function(n,e,t,i){i||(i={});var l=i.enumerable,c=void 0!==i.name?i.name:e;if(r(t)&&s(t,c,i),i.global)l?n[e]=t:a(e,t);else{try{i.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!i.nonConfigurable,writable:!i.nonWritable})}return n}},function(n,e,t){var r=t(3),o=t(0),s=t(8),a=t(7),i=t(110).CONFIGURABLE,l=t(62),c=t(111),p=c.enforce,u=c.get,d=Object.defineProperty,f=a&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),h=String(String).split("String"),m=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||i&&n.name!==e)&&(a?d(n,"name",{value:e,configurable:!0}):n.name=e),f&&t&&s(t,"arity")&&n.length!==t.arity&&d(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?a&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=p(n);return s(r,"source")||(r.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=m((function(){return o(this)&&u(this).source||l(this)}),"toString")},function(n,e,t){var r=t(7),o=t(8),s=Function.prototype,a=r&&Object.getOwnPropertyDescriptor,i=o(s,"name"),l=i&&"something"===function(){}.name,c=i&&(!r||r&&a(s,"name").configurable);n.exports={EXISTS:i,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r,o,s,a=t(112),i=t(2),l=t(1),c=t(9),p=t(17),u=t(8),d=t(31),f=t(97),h=t(46),m=i.TypeError,g=i.WeakMap;if(a||d.state){var y=d.state||(d.state=new g),v=l(y.get),b=l(y.has),x=l(y.set);r=function(n,e){if(b(y,n))throw new m("Object already initialized");return e.facade=n,x(y,n,e),e},o=function(n){return v(y,n)||{}},s=function(n){return b(y,n)}}else{var k=f("state");h[k]=!0,r=function(n,e){if(u(n,k))throw new m("Object already initialized");return e.facade=n,p(n,k,e),e},o=function(n){return u(n,k)?n[k]:{}},s=function(n){return u(n,k)}}n.exports={set:r,get:o,has:s,enforce:function(n){return s(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=o(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),o=t(0),s=t(62),a=r.WeakMap;n.exports=o(a)&&/native code/.test(s(a))},function(n,e,t){var r=t(16),o=t(1),s=t(114),a=t(119),i=t(24),l=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=s.f(i(n)),t=a.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(98),o=t(94).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){var r=t(26),o=t(116),s=t(47),a=function(n){return function(e,t,a){var i,l=r(e),c=s(l),p=o(a,c);if(n&&t!=t){for(;c>p;)if((i=l[p++])!=i)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:a(!0),indexOf:a(!1)}},function(n,e,t){var r=t(64),o=Math.max,s=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):s(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(64),o=Math.min;n.exports=function(n){return n>0?o(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),o=t(0),s=/#|\.prototype\./,a=function(n,e){var t=l[i(n)];return t==p||t!=c&&(o(e)?r(e):!!e)},i=a.normalize=function(n){return String(n).replace(s,".").toLowerCase()},l=a.data={},c=a.NATIVE="N",p=a.POLYFILL="P";n.exports=a},function(n,e,t){var r=t(44),o=t(45),s=t(43),a=t(47),i=TypeError,l=function(n){return function(e,t,l,c){r(t);var p=o(e),u=s(p),d=a(p),f=n?d-1:0,h=n?-1:1;if(l<2)for(;;){if(f in u){c=u[f],f+=h;break}if(f+=h,n?f<0:d<=f)throw i("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=h)f in u&&(c=t(c,u[f],f,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(30),o=t(2);n.exports="process"==r(o.process)},function(n,e,t){var r=t(42),o=t(2),s=t(125),a=t(126),i=o.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=a(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(i&&i[n]){var t={};t[n]=a("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return s(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return s(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return s(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return s(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return s(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return s(n,this,arguments)}})),c("URIError",(function(n){return function(e){return s(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return s(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return s(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return s(n,this,arguments)}}))},function(n,e,t){var r=t(25),o=Function.prototype,s=o.apply,a=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?a.bind(s):function(){return a.apply(s,arguments)})},function(n,e,t){"use strict";var r=t(16),o=t(8),s=t(17),a=t(54),i=t(65),l=t(63),c=t(128),p=t(129),u=t(130),d=t(134),f=t(135),h=t(136),m=t(7),g=t(59);n.exports=function(n,e,t,y){var v=y?2:1,b=n.split("."),x=b[b.length-1],k=r.apply(null,b);if(k){var _=k.prototype;if(!g&&o(_,"cause")&&delete _.cause,!t)return k;var S=r("Error"),T=e((function(n,e){var t=u(y?e:n,void 0),r=y?new k(n):new k;return void 0!==t&&s(r,"message",t),h&&s(r,"stack",f(r.stack,2)),this&&a(_,this)&&p(r,this,T),arguments.length>v&&d(r,arguments[v]),r}));if(T.prototype=_,"Error"!==x?i?i(T,S):l(T,S,{name:!0}):m&&"stackTraceLimit"in k&&(c(T,k,"stackTraceLimit"),c(T,k,"prepareStackTrace")),l(T,k),!g)try{_.name!==x&&s(_,"name",x),_.constructor=T}catch(n){}return T}}},function(n,e,t){var r=t(0),o=String,s=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw s("Can't set "+o(n)+" as a prototype")}},function(n,e,t){var r=t(15).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),o=t(9),s=t(65);n.exports=function(n,e,t){var a,i;return s&&r(a=e.constructor)&&a!==t&&o(i=a.prototype)&&i!==t.prototype&&s(n,i),n}},function(n,e,t){var r=t(131);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(132),o=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){var r=t(133),o=t(0),s=t(30),a=t(27)("toStringTag"),i=Object,l="Arguments"==s(function(){return arguments}());n.exports=r?s:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=i(n),a))?t:l?s(e):"Object"==(r=s(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(27)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),o=t(17);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){var r=t(1),o=Error,s=r("".replace),a=String(o("zxcasd").stack),i=/\n\s*at [^:]*:[^\n]*/,l=i.test(a);n.exports=function(n,e){if(l&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=s(n,i,"");return n}},function(n,e,t){var r=t(3),o=t(29);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(66),o=t(138);n.exports=function n(e,t,s,a,i){var l=-1,c=e.length;for(s||(s=o),i||(i=[]);++l<c;){var p=e[l];t>0&&s(p)?t>1?n(p,t-1,s,a,i):r(i,p):a||(i[i.length]=p)}return i}},function(n,e,t){var r=t(14),o=t(33),s=t(4),a=r?r.isConcatSpreadable:void 0;n.exports=function(n){return s(n)||o(n)||!!(a&&n&&n[a])}},function(n,e,t){var r=t(13),o=t(12);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(14),o=Object.prototype,s=o.hasOwnProperty,a=o.toString,i=r?r.toStringTag:void 0;n.exports=function(n){var e=s.call(n,i),t=n[i];try{n[i]=void 0;var r=!0}catch(n){}var o=a.call(n);return r&&(e?n[i]=t:delete n[i]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(143),o=t(199),s=t(41),a=t(4),i=t(210);n.exports=function(n){return"function"==typeof n?n:null==n?s:"object"==typeof n?a(n)?o(n[0],n[1]):r(n):i(n)}},function(n,e,t){var r=t(144),o=t(198),s=t(83);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?s(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(68),o=t(72);n.exports=function(n,e,t,s){var a=t.length,i=a,l=!s;if(null==n)return!i;for(n=Object(n);a--;){var c=t[a];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++a<i;){var p=(c=t[a])[0],u=n[p],d=c[1];if(l&&c[2]){if(void 0===u&&!(p in n))return!1}else{var f=new r;if(s)var h=s(u,d,p,n,e,f);if(!(void 0===h?o(d,u,3,s,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(19),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(19);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(19);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(18);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(18),o=t(34),s=t(36);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var a=t.__data__;if(!o||a.length<199)return a.push([n,e]),this.size=++t.size,this;t=this.__data__=new s(a)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(70),o=t(156),s=t(35),a=t(71),i=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,u=c.hasOwnProperty,d=RegExp("^"+p.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!s(n)||o(n))&&(r(n)?d:i).test(a(n))}},function(n,e,t){var r,o=t(157),s=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!s&&s in n}},function(n,e,t){var r=t(5)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(160),o=t(18),s=t(34);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(s||o),string:new r}}},function(n,e,t){var r=t(161),o=t(162),s=t(163),a=t(164),i=t(165);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=s,l.prototype.has=a,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(20);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(20),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(20),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(21);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(68),o=t(73),s=t(175),a=t(178),i=t(194),l=t(4),c=t(77),p=t(79),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,m){var g=l(n),y=l(e),v=g?"[object Array]":i(n),b=y?"[object Array]":i(e),x=(v="[object Arguments]"==v?u:v)==u,k=(b="[object Arguments]"==b?u:b)==u,_=v==b;if(_&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(_&&!x)return m||(m=new r),g||p(n)?o(n,e,t,f,h,m):s(n,e,v,t,f,h,m);if(!(1&t)){var S=x&&d.call(n,"__wrapped__"),T=k&&d.call(e,"__wrapped__");if(S||T){var w=S?n.value():n,q=T?e.value():e;return m||(m=new r),h(w,q,t,f,m)}}return!!_&&(m||(m=new r),a(n,e,t,f,h,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(14),o=t(176),s=t(69),a=t(73),i=t(177),l=t(37),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return s(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=i;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var m=d.get(n);if(m)return m==e;r|=2,d.set(n,e);var g=a(f(n),f(e),r,c,u,d);return d.delete(n),g;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(5).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(179),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,s,a,i){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var u=p;u--;){var d=c[u];if(!(l?d in e:o.call(e,d)))return!1}var f=i.get(n),h=i.get(e);if(f&&h)return f==e&&h==n;var m=!0;i.set(n,e),i.set(e,n);for(var g=l;++u<p;){var y=n[d=c[u]],v=e[d];if(s)var b=l?s(v,y,d,e,n,i):s(y,v,d,n,e,i);if(!(void 0===b?y===v||a(y,v,t,s,i):b)){m=!1;break}g||(g="constructor"==d)}if(m&&!g){var x=n.constructor,k=e.constructor;x==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof k&&k instanceof k||(m=!1)}return i.delete(n),i.delete(e),m}},function(n,e,t){var r=t(180),o=t(181),s=t(76);n.exports=function(n){return r(n,s,o)}},function(n,e,t){var r=t(66),o=t(4);n.exports=function(n,e,t){var s=e(n);return o(n)?s:r(s,t(n))}},function(n,e,t){var r=t(182),o=t(183),s=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,i=a?function(n){return null==n?[]:(n=Object(n),r(a(n),(function(e){return s.call(n,e)})))}:o;n.exports=i},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,s=[];++t<r;){var a=n[t];e(a,t,n)&&(s[o++]=a)}return s}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(185),o=t(33),s=t(4),a=t(77),i=t(78),l=t(79),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=s(n),p=!t&&o(n),u=!t&&!p&&a(n),d=!t&&!p&&!u&&l(n),f=t||p||u||d,h=f?r(n.length,String):[],m=h.length;for(var g in n)!e&&!c.call(n,g)||f&&("length"==g||u&&("offset"==g||"parent"==g)||d&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||i(g,m))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(13),o=t(38),s=t(12),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,n.exports=function(n){return s(n)&&o(n.length)&&!!a[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(67),o=e&&!e.nodeType&&e,s=o&&"object"==typeof n&&n&&!n.nodeType&&n,a=s&&s.exports===o&&r.process,i=function(){try{var n=s&&s.require&&s.require("util").types;return n||a&&a.binding&&a.binding("util")}catch(n){}}();n.exports=i}).call(this,t(48)(n))},function(n,e,t){var r=t(191),o=t(192),s=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))s.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(193)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(195),o=t(34),s=t(196),a=t(81),i=t(197),l=t(13),c=t(71),p=c(r),u=c(o),d=c(s),f=c(a),h=c(i),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=m(new o)||s&&"[object Promise]"!=m(s.resolve())||a&&"[object Set]"!=m(new a)||i&&"[object WeakMap]"!=m(new i))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(10)(t(5),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(5),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(5),"WeakMap");n.exports=r},function(n,e,t){var r=t(82),o=t(76);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var s=e[t],a=n[s];e[t]=[s,a,r(a)]}return e}},function(n,e,t){var r=t(72),o=t(200),s=t(207),a=t(39),i=t(82),l=t(83),c=t(22);n.exports=function(n,e){return a(n)&&i(e)?l(c(n),e):function(t){var a=o(t,n);return void 0===a&&a===e?s(t,n):r(e,a,3)}}},function(n,e,t){var r=t(84);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(202),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,s=/\\(\\)?/g,a=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(s,"$1"):t||n)})),e}));n.exports=a},function(n,e,t){var r=t(203);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(36);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],s=t.cache;if(s.has(o))return s.get(o);var a=n.apply(this,r);return t.cache=s.set(o,a)||s,a};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(205);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(14),o=t(206),s=t(4),a=t(40),i=r?r.prototype:void 0,l=i?i.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(s(e))return o(e,n)+"";if(a(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(208),o=t(209);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(85),o=t(33),s=t(4),a=t(78),i=t(38),l=t(22);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,u=!1;++c<p;){var d=l(e[c]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++c!=p?u:!!(p=null==n?0:n.length)&&i(p)&&a(d,p)&&(s(n)||o(n))}},function(n,e,t){var r=t(211),o=t(212),s=t(39),a=t(22);n.exports=function(n){return s(n)?r(a(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(84);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(41),o=t(214),s=t(216);n.exports=function(n,e){return s(o(n,e,r),n+"")}},function(n,e,t){var r=t(215),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var s=arguments,a=-1,i=o(s.length-e,0),l=Array(i);++a<i;)l[a]=s[e+a];a=-1;for(var c=Array(e+1);++a<e;)c[a]=s[a];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(217),o=t(220)(r);n.exports=o},function(n,e,t){var r=t(218),o=t(219),s=t(41),a=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:s;n.exports=a},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),s=16-(o-r);if(r=o,s>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(74),o=t(222),s=t(227),a=t(75),i=t(228),l=t(37);n.exports=function(n,e,t){var c=-1,p=o,u=n.length,d=!0,f=[],h=f;if(t)d=!1,p=s;else if(u>=200){var m=e?null:i(n);if(m)return l(m);d=!1,p=a,h=new r}else h=e?[]:f;n:for(;++c<u;){var g=n[c],y=e?e(g):g;if(g=t||0!==g?g:0,d&&y==y){for(var v=h.length;v--;)if(h[v]===y)continue n;e&&h.push(y),f.push(g)}else p(h,y,t)||(h!==f&&h.push(y),f.push(g))}return f}},function(n,e,t){var r=t(223);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(224),o=t(225),s=t(226);n.exports=function(n,e,t){return e==e?s(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,s=t+(r?1:-1);r?s--:++s<o;)if(e(n[s],s,n))return s;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(81),o=t(229),s=t(37),a=r&&1/s(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=a},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(80),o=t(12);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t(87)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.0
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),o=Array.isArray;function s(n){return null==n}function a(n){return null!=n}function i(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function f(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var k=Object.prototype.hasOwnProperty;function _(n,e){return k.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,w=S((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),q=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,E=S((function(n){return n.replace(C,"-$1").toLowerCase()}));var F=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function j(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function R(n,e){for(var t in e)n[t]=e[t];return n}function A(n){for(var e={},t=0;t<n.length;t++)n[t]&&R(e,n[t]);return e}function P(n,e,t){}var I=function(n,e,t){return!1},O=function(n){return n};function L(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),s=Array.isArray(e);if(o&&s)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||s)return!1;var a=Object.keys(n),i=Object.keys(e);return a.length===i.length&&a.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function B(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function z(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function M(n,e){return n===e?0===n&&1/n!=1/e:n==n&&e==e}var U=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],H={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:P,parsePlatformTagName:O,mustUseProp:I,async:!0,_lifecycleHooks:$},D=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function J(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(D.source,".$_\\d]"));var Q="__proto__"in{},V="undefined"!=typeof window,W=V&&window.navigator.userAgent.toLowerCase(),X=W&&/msie|trident/.test(W),Z=W&&W.indexOf("msie 9.0")>0,K=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Y=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var nn,en=W&&W.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(V)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var sn=function(){return void 0===nn&&(nn=!V&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},an=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function dn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var fn=P,hn=0,mn=function(){function n(){this.id=hn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){x(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,r=e.length;t<r;t++){e[t].update()}},n}();mn.target=null;var gn=[];function yn(n){gn.push(n),mn.target=n}function vn(){gn.pop(),mn.target=gn[gn.length-1]}var bn=function(){function n(n,e,t,r,o,s,a,i){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=i,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),xn=function(n){void 0===n&&(n="");var e=new bn;return e.text=n,e.isComment=!0,e};function kn(n){return new bn(void 0,void 0,void 0,String(n))}function _n(n){var e=new bn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var Sn=Array.prototype,Tn=Object.create(Sn);function wn(n){return qn(n,!0),J(n,"__v_isShallow",!0),n}function qn(n,e){if(!Cn(n)){ht(n,e);0}}function Cn(n){return!(!n||!n.__v_isReadonly)}["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Sn[n];J(Tn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o,s=e.apply(this,t),a=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&a.observeArray(o),a.dep.notify(),s}))}));function En(n){return!(!n||!0!==n.__v_isRef)}var Fn=new cn;function jn(n){return function n(e,t){var r,s,a=o(e);if(!a&&!p(e)||Object.isFrozen(e)||e instanceof bn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(a)for(r=e.length;r--;)n(e[r],t);else for(s=Object.keys(e),r=s.length;r--;)n(e[s[r]],t)}(n,Fn),Fn.clear(),n}var Rn=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function An(n,e){function t(){var n=t.fns;if(!o(n))return We(n,null,arguments,e,"v-on handler");for(var r=n.slice(),s=0;s<r.length;s++)We(r[s],null,arguments,e,"v-on handler")}return t.fns=n,t}function Pn(n,e,t,r,o,a){var l,c,p,u;for(l in n)c=n[l],p=e[l],u=Rn(l),s(c)||(s(p)?(s(c.fns)&&(c=n[l]=An(c,a)),i(u.once)&&(c=n[l]=o(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)s(n[l])&&r((u=Rn(l)).name,e[l],u.capture)}function In(n,e,t){var r;n instanceof bn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}s(o)?r=An([l]):a(o.fns)&&i(o.merged)?(r=o).fns.push(l):r=An([o,l]),r.merged=!0,n[e]=r}function On(n,e,t,r,o){if(a(e)){if(_(e,t))return n[t]=e[t],o||delete e[t],!0;if(_(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function Ln(n){return l(n)?[kn(n)]:o(n)?function n(e,t){var r,c,p,u,d=[];for(r=0;r<e.length;r++)s(c=e[r])||"boolean"==typeof c||(p=d.length-1,u=d[p],o(c)?c.length>0&&(Bn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Bn(u)&&(d[p]=kn(u.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Bn(u)?d[p]=kn(u.text+c):""!==c&&d.push(kn(c)):Bn(c)&&Bn(u)?d[p]=kn(u.text+c.text):(i(e._isVList)&&a(c.tag)&&s(c.key)&&a(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Bn(n){return a(n)&&a(n.text)&&!1===n.isComment}function zn(n,e){if(un){var t=un._provided,r=un.$parent&&un.$parent._provided;r===t&&(t=un._provided=Object.create(r)),t[n]=e}else 0}function Mn(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var s=r[o];if("__ob__"!==s){var a=n[s].from;if(a in e._provided)t[s]=e._provided[a];else if("default"in n[s]){var i=n[s].default;t[s]=c(i)?i.call(e):i}else 0}}return t}}function Un(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var s=n[r],a=s.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,s.context!==e&&s.fnContext!==e||!a||null==a.slot)(t.default||(t.default=[])).push(s);else{var i=a.slot,l=t[i]||(t[i]=[]);"template"===s.tag?l.push.apply(l,s.children||[]):l.push(s)}}for(var c in t)t[c].every($n)&&delete t[c];return t}function $n(n){return n.isComment&&!n.asyncFactory||" "===n.text}function Hn(n){return n.isComment&&n.asyncFactory}function Dn(n,e,t,o){var s,a=Object.keys(t).length>0,i=e?!!e.$stable:!a,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(i&&o&&o!==r&&l===o.$key&&!a&&!o.$hasNormal)return o;for(var c in s={},e)e[c]&&"$"!==c[0]&&(s[c]=Nn(n,t,c,e[c]))}else s={};for(var p in t)p in s||(s[p]=Jn(t,p));return e&&Object.isExtensible(e)&&(e._normalized=s),J(s,"$stable",i),J(s,"$key",l),J(s,"$hasNormal",a),s}function Nn(n,e,t,r){var s=function(){var e=un;dn(n);var t=arguments.length?r.apply(null,arguments):r({}),s=(t=t&&"object"==typeof t&&!o(t)?[t]:Ln(t))&&t[0];return dn(e),t&&(!s||1===t.length&&s.isComment&&!Hn(s))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:s,enumerable:!0,configurable:!0}),s}function Jn(n,e){return function(){return n[e]}}function Gn(n,e){var t,r,s,i,l=null;if(o(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(s=Object.keys(n),l=new Array(s.length),t=0,r=s.length;t<r;t++)i=s[t],l[t]=e(n[i],i,t);return a(l)||(l=[]),l._isVList=!0,l}function Qn(n,e,t,r){var o,s=this.$scopedSlots[n];s?(t=t||{},r&&(t=R(R({},r),t)),o=s(t)||(c(e)?e():e)):o=this.$slots[n]||(c(e)?e():e);var a=t&&t.slot;return a?this.$createElement("template",{slot:a},o):o}function Vn(n){return qt(this.$options,"filters",n,!0)||O}function Wn(n,e){return o(n)?-1===n.indexOf(e):n!==e}function Xn(n,e,t,r,o){var s=H.keyCodes[e]||t;return o&&r&&!H.keyCodes[e]?Wn(o,r):s?Wn(s,n):r?E(r)!==e:void 0===n}function Zn(n,e,t,r,s){if(t)if(p(t)){o(t)&&(t=A(t));var a=void 0,i=function(o){if("class"===o||"style"===o||b(o))a=n;else{var i=n.attrs&&n.attrs.type;a=r||H.mustUseProp(e,i,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=w(o),c=E(o);l in a||c in a||(a[o]=t[o],s&&((n.on||(n.on={}))["update:".concat(o)]=function(n){t[o]=n}))};for(var l in t)i(l)}else;return n}function Kn(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ne(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__".concat(n),!1),r}function Yn(n,e,t){return ne(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ne(n,e,t){if(o(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ee(n[r],"".concat(e,"_").concat(r),t);else ee(n,e,t)}function ee(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function te(n,e){if(e)if(d(e)){var t=n.on=n.on?R({},n.on):{};for(var r in e){var o=t[r],s=e[r];t[r]=o?[].concat(o,s):s}}else;return n}function re(n,e,t,r){e=e||{$stable:!t};for(var s=0;s<n.length;s++){var a=n[s];o(a)?re(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function oe(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function se(n,e){return"string"==typeof n?e+n:n}function ae(n){n._o=Yn,n._n=y,n._s=g,n._l=Gn,n._t=Qn,n._q=L,n._i=B,n._m=Kn,n._f=Vn,n._k=Xn,n._b=Zn,n._v=kn,n._e=xn,n._u=re,n._g=te,n._d=oe,n._p=se}function ie(n,e,t,s,a){var l,c=this,p=a.options;_(s,"_uid")?(l=Object.create(s))._original=s:(l=s,s=s._original);var u=i(p._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=s,this.listeners=n.on||r,this.injections=Mn(p.inject,s),this.slots=function(){return c.$slots||Dn(s,n.scopedSlots,c.$slots=Un(t,s)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return Dn(s,n.scopedSlots,this.slots())}}),u&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=Dn(s,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var a=he(l,n,e,t,r,d);return a&&!o(a)&&(a.fnScopeId=p._scopeId,a.fnContext=s),a}:this._c=function(n,e,t,r){return he(l,n,e,t,r,d)}}function le(n,e,t,r,o){var s=_n(n);return s.fnContext=t,s.fnOptions=r,e.slot&&((s.data||(s.data={})).slot=e.slot),s}function ce(n,e){for(var t in e)n[w(t)]=e[t]}ae(ie.prototype);var pe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;pe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;a(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ee)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,s){0;var a=o.data.scopedSlots,i=n.$scopedSlots,l=!!(a&&!a.$stable||i!==r&&!i.$stable||a&&n.$scopedSlots.$key!==a.$key||!a&&n.$scopedSlots.$key),c=!!(s||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o);n.$options._renderChildren=s;var u=o.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,u,p.data&&p.data.attrs||r,n)&&(c=!0);if(n.$attrs=u,n.$listeners=t||r,e&&n.$options.props){dt(!1);for(var d=n._props,f=n.$options._propKeys||[],h=0;h<f.length;h++){var m=f[h],g=n.$options.props;d[m]=Ct(m,g,e,n)}dt(!0),n.$options.propsData=e}t=t||r;var y=n.$options._parentListeners;n.$options._parentListeners=t,Ce(n,t,y),c&&(n.$slots=Un(s,o.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,Ae(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,Ie.push(e)):Re(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,je(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);Ae(e,"deactivated")}}(e,!0):e.$destroy())}},ue=Object.keys(pe);function de(n,e,t,l,c){if(!s(n)){var u=t.$options._base;if(p(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(s(n.cid)&&void 0===(n=function(n,e){if(i(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=ke;t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(i(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var r=n.owners=[t],o=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=z((function(t){n.resolved=_e(t,e),o?r.length=0:u(!0)})),f=z((function(e){a(n.errorComp)&&(n.error=!0,u(!0))})),h=n(d,f);return p(h)&&(m(h)?s(n.resolved)&&h.then(d,f):m(h.component)&&(h.component.then(d,f),a(h.error)&&(n.errorComp=_e(h.error,e)),a(h.loading)&&(n.loadingComp=_e(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,s(n.resolved)&&s(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),a(h.timeout)&&(c=setTimeout((function(){c=null,s(n.resolved)&&f(null)}),h.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,o){var s=xn();return s.asyncFactory=n,s.asyncMeta={data:e,context:t,children:r,tag:o},s}(d,e,t,l,c);e=e||{},$t(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var s=e.on||(e.on={}),i=s[r],l=e.model.callback;a(i)?(o(i)?-1===i.indexOf(l):i!==l)&&(s[r]=[l].concat(i)):s[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!s(r)){var o={},i=n.attrs,l=n.props;if(a(i)||a(l))for(var c in r){var p=E(c);On(o,l,c,p,!0)||On(o,i,c,p,!1)}return o}}(e,n);if(i(n.options.functional))return function(n,e,t,s,i){var l=n.options,c={},p=l.props;if(a(p))for(var u in p)c[u]=Ct(u,p,e||r);else a(t.attrs)&&ce(c,t.attrs),a(t.props)&&ce(c,t.props);var d=new ie(t,c,i,s,n),f=l.render.call(null,d._c,d);if(f instanceof bn)return le(f,t,d.parent,l,d);if(o(f)){for(var h=Ln(f)||[],m=new Array(h.length),g=0;g<h.length;g++)m[g]=le(h[g],t,d.parent,l,d);return m}}(n,f,e,t,l);var h=e.on;if(e.on=e.nativeOn,i(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<ue.length;t++){var r=ue[t],o=e[r],s=pe[r];o===s||o&&o._merged||(e[r]=o?fe(s,o):s)}}(e);var y=n.options.name||c;return new bn("vue-component-".concat(n.cid).concat(y?"-".concat(y):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:h,tag:c,children:l},d)}}}function fe(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function he(n,e,t,r,u,d){return(o(t)||l(t))&&(u=r,r=t,t=void 0),i(d)&&(u=2),function(n,e,t,r,l){if(a(t)&&a(t.__ob__))return xn();a(t)&&a(t.is)&&(e=t.is);if(!e)return xn();0;o(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Ln(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(o(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,d;if("string"==typeof e){var f=void 0;d=n.$vnode&&n.$vnode.ns||H.getTagNamespace(e),u=H.isReservedTag(e)?new bn(H.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!a(f=qt(n.$options,"components",e))?new bn(e,t,r,void 0,void 0,n):de(f,t,n,r,e)}else u=de(e,t,n,r);return o(u)?u:a(u)?(a(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(a(e.children))for(var o=0,l=e.children.length;o<l;o++){var c=e.children[o];a(c.tag)&&(s(c.ns)||i(r)&&"svg"!==c.tag)&&n(c,t,r)}}(u,d),a(t)&&function(n){p(n.style)&&jn(n.style);p(n.class)&&jn(n.class)}(t),u):xn()}(n,e,t,r,u)}function me(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];return En(n)?n.value:n},set:function(n){var r=e[t];En(r)?r.value=n:e[t]=n}})}function ge(n){return{get attrs(){return function(n){if(!n._attrsProxy){var e=n._attrsProxy={};J(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n)}return n._attrsProxy}(n)},get slots(){return function(n){n._slotsProxy||be(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:F(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return me(n,e,t)}))}}}function ye(n,e,t,r){var o=!1;for(var s in e)s in n?e[s]!==t[s]&&(o=!0):(o=!0,ve(n,s,r));for(var s in n)s in e||(o=!0,delete n[s]);return o}function ve(n,e,t){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t.$attrs[e]}})}function be(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var xe,ke=null;function _e(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function Se(n){if(o(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||Hn(t)))return t}}function Te(n,e){xe.$on(n,e)}function we(n,e){xe.$off(n,e)}function qe(n,e){var t=xe;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function Ce(n,e,t){xe=n,Pn(e,t||{},Te,we,qe,n),xe=void 0}var Ee=null;function Fe(n){var e=Ee;return Ee=n,function(){Ee=e}}function je(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Re(n,e){if(e){if(n._directInactive=!1,je(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Re(n.$children[t]);Ae(n,"activated")}}function Ae(n,e,t){yn();var r=un;dn(n);var o=n.$options[e],s="".concat(e," hook");if(o)for(var a=0,i=o.length;a<i;a++)We(o[a],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),dn(r),vn()}var Pe=[],Ie=[],Oe={},Le=!1,Be=!1,ze=0;var Me,Ue=0,$e=Date.now;if(V&&!X){var He=window.performance;He&&"function"==typeof He.now&&$e()>document.createEvent("Event").timeStamp&&($e=function(){return He.now()})}function De(){var n,e;for(Ue=$e(),Be=!0,Pe.sort((function(n,e){return n.id-e.id})),ze=0;ze<Pe.length;ze++)(n=Pe[ze]).before&&n.before(),e=n.id,Oe[e]=null,n.run();var t=Ie.slice(),r=Pe.slice();ze=Pe.length=Ie.length=0,Oe={},Le=Be=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Re(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&Ae(r,"updated")}}(r),an&&H.devtools&&an.emit("flush")}function Ne(n){var e=n.id;if(null==Oe[e]&&(n!==mn.target||!n.noRecurse)){if(Oe[e]=!0,Be){for(var t=Pe.length-1;t>ze&&Pe[t].id>n.id;)t--;Pe.splice(t+1,0,n)}else Pe.push(n);Le||(Le=!0,it(De))}}var Je=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Me&&(this.parent=Me,this.index=(Me.scopes||(Me.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Me;try{return Me=this,n()}finally{Me=e}}else 0},n.prototype.on=function(){Me=this},n.prototype.off=function(){Me=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.active=!1}},n}();var Ge=0,Qe=function(){function n(n,e,t,r,o){var s,a;s=this,void 0===(a=Me||(n?n._scope:void 0))&&(a=Me),a&&a.active&&a.effects.push(s),(this.vm=n)&&o&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ge,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;yn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ve(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&jn(n),vn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():Ne(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');We(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");function Ve(n,e,t){yn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var s=0;s<o.length;s++)try{if(!1===o[s].call(r,n,e,t))return}catch(n){Xe(n,r,"errorCaptured hook")}}Xe(n,e,t)}finally{vn()}}function We(n,e,t,r,o){var s;try{(s=t?n.apply(e,t):n.call(e))&&!s._isVue&&m(s)&&!s._handled&&(s.catch((function(n){return Ve(n,r,o+" (Promise/async)")})),s._handled=!0)}catch(n){Ve(n,r,o)}return s}function Xe(n,e,t){if(H.errorHandler)try{return H.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ze(e,null,"config.errorHandler")}Ze(n,e,t)}function Ze(n,e,t){if(!V||"undefined"==typeof console)throw n;console.error(n)}var Ke,Ye=!1,nt=[],et=!1;function tt(){et=!1;var n=nt.slice(0);nt.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var rt=Promise.resolve();Ke=function(){rt.then(tt),Y&&setTimeout(P)},Ye=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ke="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(tt)}:function(){setTimeout(tt,0)};else{var ot=1,st=new MutationObserver(tt),at=document.createTextNode(String(ot));st.observe(at,{characterData:!0}),Ke=function(){ot=(ot+1)%2,at.data=String(ot)},Ye=!0}function it(n,e){var t;if(nt.push((function(){if(n)try{n.call(e)}catch(n){Ve(n,e,"nextTick")}else t&&t(e)})),et||(et=!0,Ke()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function lt(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=_t(r[e],t)}(t,n,e)}}lt("beforeMount"),lt("mounted"),lt("beforeUpdate"),lt("updated"),lt("beforeDestroy"),lt("destroyed"),lt("errorCaptured"),lt("activated"),lt("deactivated"),lt("serverPrefetch"),lt("renderTracked"),lt("renderTriggered");var ct=Object.getOwnPropertyNames(Tn),pt={},ut=!0;function dt(n){ut=n}var ft=function(){function n(n,e){void 0===e&&(e=!1),this.value=n,this.shallow=e,this.dep=new mn,this.vmCount=0,J(n,"__ob__",this),o(n)?(Q?function(n,e){n.__proto__=e}(n,Tn):function(n,e,t){for(var r=0,o=t.length;r<o;r++){var s=t[r];J(n,s,e[s])}}(n,Tn,ct),e||this.observeArray(n)):this.walk(n,e)}return n.prototype.walk=function(n,e){for(var t=Object.keys(n),r=0;r<t.length;r++){mt(n,t[r],pt,void 0,e)}},n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)ht(n[e])},n}();function ht(n,e){var t;if(!(!p(n)||En(n)||n instanceof bn))return _(n,"__ob__")&&n.__ob__ instanceof ft?t=n.__ob__:ut&&!sn()&&(o(n)||d(n))&&Object.isExtensible(n)&&!n.__v_skip&&(t=new ft(n,e)),t}function mt(n,e,t,r,s){var a=new mn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var l=i&&i.get,c=i&&i.set;l&&!c||t!==pt&&2!==arguments.length||(t=n[e]);var p=!s&&ht(t);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return mn.target&&(a.depend(),p&&(p.dep.depend(),o(e)&&vt(e))),En(e)?e.value:e},set:function(e){var r=l?l.call(n):t;if(M(r,e)){if(c)c.call(n,e);else{if(l)return;if(En(r)&&!En(e))return void(r.value=e);t=e}p=!s&&ht(e),a.notify()}}}),a}}function gt(n,e,t){if(!Cn(n)){if(o(n)&&h(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(mt(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}}function yt(n,e){if(o(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Cn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function vt(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),o(e)&&vt(e)}var bt=H.optionMergeStrategies;function xt(n,e){if(!e)return n;for(var t,r,o,s=pn?Reflect.ownKeys(e):Object.keys(e),a=0;a<s.length;a++)"__ob__"!==(t=s[a])&&(r=n[t],o=e[t],_(n,t)?r!==o&&d(r)&&d(o)&&xt(r,o):gt(n,t,o));return n}function kt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,o=c(n)?n.call(t,t):n;return r?xt(r,o):o}:e?n?function(){return xt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function _t(n,e){var t=e?n?n.concat(e):o(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function St(n,e,t,r){var o=Object.create(n||null);return e?R(o,e):o}bt.data=function(n,e,t){return t?kt(n,e,t):e&&"function"!=typeof e?n:kt(n,e)},$.forEach((function(n){bt[n]=_t})),U.forEach((function(n){bt[n+"s"]=St})),bt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var s={};for(var a in R(s,n),e){var i=s[a],l=e[a];i&&!o(i)&&(i=[i]),s[a]=i?i.concat(l):o(l)?l:[l]}return s},bt.props=bt.methods=bt.inject=bt.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return R(o,n),e&&R(o,e),o},bt.provide=kt;var Tt=function(n,e){return void 0===e?n:e};function wt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,s,a={};if(o(t))for(r=t.length;r--;)"string"==typeof(s=t[r])&&(a[w(s)]={type:null});else if(d(t))for(var i in t)s=t[i],a[w(i)]=d(s)?s:{type:s};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(o(t))for(var s=0;s<t.length;s++)r[t[s]]={from:t[s]};else if(d(t))for(var a in t){var i=t[a];r[a]=d(i)?R({from:a},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=wt(n,e.extends,t)),e.mixins))for(var r=0,s=e.mixins.length;r<s;r++)n=wt(n,e.mixins[r],t);var a,i={};for(a in n)l(a);for(a in e)_(n,a)||l(a);function l(r){var o=bt[r]||Tt;i[r]=o(n[r],e[r],t,r)}return i}function qt(n,e,t,r){if("string"==typeof t){var o=n[e];if(_(o,t))return o[t];var s=w(t);if(_(o,s))return o[s];var a=q(s);return _(o,a)?o[a]:o[t]||o[s]||o[a]}}function Ct(n,e,t,r){var o=e[n],s=!_(t,n),a=t[n],i=Rt(Boolean,o.type);if(i>-1)if(s&&!_(o,"default"))a=!1;else if(""===a||a===E(n)){var l=Rt(String,o.type);(l<0||i<l)&&(a=!0)}if(void 0===a){a=function(n,e,t){if(!_(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Ft(e.type)?r.call(n):r}(r,o,n);var p=ut;dt(!0),ht(a),dt(p)}return a}var Et=/^\s*function (\w+)/;function Ft(n){var e=n&&n.toString().match(Et);return e?e[1]:""}function jt(n,e){return Ft(n)===Ft(e)}function Rt(n,e){if(!o(e))return jt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(jt(e[t],n))return t;return-1}var At={enumerable:!0,configurable:!0,get:P,set:P};function Pt(n,e,t){At.get=function(){return this[e][t]},At.set=function(n){this[e][t]=n},Object.defineProperty(n,t,At)}function It(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=wn({}),o=n.$options._propKeys=[];n.$parent&&dt(!1);var s=function(s){o.push(s);var a=Ct(s,e,t,n);mt(r,s,a),s in n||Pt(n,"_props",s)};for(var a in e)s(a);dt(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ge(n);dn(n),yn();var o=We(t,null,[n._props||wn({}),r],n,"setup");if(vn(),dn(),c(o))e.render=o;else if(p(o))if(n._setupState=o,o.__sfc){var s=n._setupProxy={};for(var a in o)me(s,o,a)}else for(var a in o)N(a)||me(n,o,a);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?P:F(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){yn();try{return n.call(e,e)}catch(n){return Ve(n,e,"data()"),{}}finally{vn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var s=t[o];0,r&&_(r,s)||N(s)||Pt(n,"_data",s)}var a=ht(e);a&&a.vmCount++}(n);else{var t=ht(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var o in e){var s=e[o],a=c(s)?s:s.get;0,r||(t[o]=new Qe(n,a||P,P,Ot)),o in n||Lt(n,o,s)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(o(r))for(var s=0;s<r.length;s++)Mt(n,t,r[s]);else Mt(n,t,r)}}(n,e.watch)}var Ot={lazy:!0};function Lt(n,e,t){var r=!sn();c(t)?(At.get=r?Bt(e):zt(t),At.set=P):(At.get=t.get?r&&!1!==t.cache?Bt(e):zt(t.get):P,At.set=t.set||P),Object.defineProperty(n,e,At)}function Bt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),mn.target&&e.depend(),e.value}}function zt(n){return function(){return n.call(this,this)}}function Mt(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Ut=0;function $t(n){var e=n.options;if(n.super){var t=$t(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&R(n.extendOptions,r),(e=n.options=wt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ht(n){this._init(n)}function Dt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var s=n.name||t.options.name;var a=function(n){this._init(n)};return(a.prototype=Object.create(t.prototype)).constructor=a,a.cid=e++,a.options=wt(t.options,n),a.super=t,a.options.props&&function(n){var e=n.options.props;for(var t in e)Pt(n.prototype,"_props",t)}(a),a.options.computed&&function(n){var e=n.options.computed;for(var t in e)Lt(n.prototype,t,e[t])}(a),a.extend=t.extend,a.mixin=t.mixin,a.use=t.use,U.forEach((function(n){a[n]=t[n]})),s&&(a.options.components[s]=a),a.superOptions=t.options,a.extendOptions=n,a.sealedOptions=R({},a.options),o[r]=a,a}}function Nt(n){return n&&(n.Ctor.options.name||n.tag)}function Jt(n,e){return o(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Gt(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var s in t){var a=t[s];if(a){var i=a.name;i&&!e(i)&&Qt(t,s,r,o)}}}function Qt(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ut++,e._isVue=!0,e.__v_skip=!0,e._scope=new Je(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=wt($t(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ce(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=Un(e._renderChildren,o),n.$scopedSlots=r,n._c=function(e,t,r,o){return he(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return he(n,e,t,r,o,!0)};var s=t&&t.data;mt(n,"$attrs",s&&s.attrs||r,null,!0),mt(n,"$listeners",e._parentListeners||r,null,!0)}(e),Ae(e,"beforeCreate"),function(n){var e=Mn(n.$options.inject,n);e&&(dt(!1),Object.keys(e).forEach((function(t){mt(n,t,e[t])})),dt(!0))}(e),It(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;var r=pn?Reflect.ownKeys(t):Object.keys(t);dn(n);for(var o=0;o<r.length;o++)zn(r[o],t[r[o]]);dn()}}(e),Ae(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ht),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=gt,n.prototype.$delete=yt,n.prototype.$watch=function(n,e,t){if(d(e))return Mt(this,n,e,t);(t=t||{}).user=!0;var r=new Qe(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'.concat(r.expression,'"');yn(),We(e,this,[r.value],this,o),vn()}return function(){r.teardown()}}}(Ht),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(o(n))for(var s=0,a=n.length;s<a;s++)r.$on(n[s],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(o(n)){for(var r=0,s=n.length;r<s;r++)t.$off(n[r],e);return t}var a,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var l=i.length;l--;)if((a=i[l])===e||a.fn===e){i.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?j(t):t;for(var r=j(arguments,1),o='event handler for "'.concat(n,'"'),s=0,a=t.length;s<a;s++)We(t[s],e,r,e,o)}return e}}(Ht),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,s=Fe(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),s(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Ae(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Ae(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ht),function(n){ae(n.prototype),n.prototype.$nextTick=function(n){return it(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,s=t._parentVnode;s&&(e.$scopedSlots=Dn(e.$parent,s.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&be(e._slotsProxy,e.$scopedSlots)),e.$vnode=s;try{dn(e),ke=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ve(t,e,"render"),n=e._vnode}finally{ke=null,dn()}return o(n)&&1===n.length&&(n=n[0]),n instanceof bn||(n=xn()),n.parent=s,n}}(Ht);var Vt=[String,RegExp,Array],Wt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Vt,exclude:Vt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,s=t.componentInstance,a=t.componentOptions;n[r]={name:Nt(a),tag:o,componentInstance:s},e.push(r),this.max&&e.length>parseInt(this.max)&&Qt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Qt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Gt(n,(function(n){return Jt(e,n)}))})),this.$watch("exclude",(function(e){Gt(n,(function(n){return!Jt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var r=Nt(t),o=this.include,s=this.exclude;if(o&&(!r||!Jt(o,r))||s&&r&&Jt(s,r))return e;var a=this.cache,i=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;a[l]?(e.componentInstance=a[l].componentInstance,x(i,l),i.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return H}};Object.defineProperty(n,"config",e),n.util={warn:fn,extend:R,mergeOptions:wt,defineReactive:mt},n.set=gt,n.delete=yt,n.nextTick=it,n.observable=function(n){return ht(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,R(n.options.components,Wt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=j(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=wt(this.options,n),this}}(n),Dt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ht),Object.defineProperty(Ht.prototype,"$isServer",{get:sn}),Object.defineProperty(Ht.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ht,"FunctionalRenderContext",{value:ie}),Ht.version="2.7.0";var Xt=v("style,class"),Zt=v("input,textarea,option,select,progress"),Kt=v("contenteditable,draggable,spellcheck"),Yt=v("events,caret,typing,plaintext-only"),nr=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),er="http://www.w3.org/1999/xlink",tr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},rr=function(n){return tr(n)?n.slice(6,n.length):""},or=function(n){return null==n||!1===n};function sr(n){for(var e=n.data,t=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=ar(r.data,e));for(;a(t=t.parent);)t&&t.data&&(e=ar(e,t.data));return function(n,e){if(a(n)||a(e))return ir(n,lr(e));return""}(e.staticClass,e.class)}function ar(n,e){return{staticClass:ir(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function ir(n,e){return n?e?n+" "+e:n:e||""}function lr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)a(e=lr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var cr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},pr=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ur=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),dr=function(n){return pr(n)||ur(n)};var fr=Object.create(null);var hr=v("text,number,password,search,email,tel,url");var mr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(cr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),gr={create:function(n,e){yr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(yr(n,!0),yr(e))},destroy:function(n){yr(n,!0)}};function yr(n,e){var t=n.data.ref;if(a(t)){var r=n.context,s=n.componentInstance||n.elm,i=e?null:s,l=e?void 0:s;if(c(t))We(t,r,[i],r,"template ref function");else{var p=n.data.refInFor,u="string"==typeof t||"number"==typeof t,d=En(t),f=r.$refs;if(u||d)if(p){var h=u?f[t]:t.value;e?o(h)&&x(h,s):o(h)?h.includes(s)||h.push(s):u?(f[t]=[s],vr(r,t,f[t])):t.value=[s]}else if(u){if(e&&f[t]!==s)return;f[t]=l,vr(r,t,i)}else if(d){if(e&&t.value!==s)return;t.value=i}else 0}}}function vr(n,e,t){var r=n._setupState;r&&_(r,e)&&(En(r[e])?r[e].value=t:r[e]=t)}var br=new bn("",{},[]),xr=["create","activate","update","remove","destroy"];function kr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=a(t=n.data)&&a(t=t.attrs)&&t.type,o=a(t=e.data)&&a(t=t.attrs)&&t.type;return r===o||hr(r)&&hr(o)}(n,e)||i(n.isAsyncPlaceholder)&&s(e.asyncFactory.error))}function _r(n,e,t){var r,o,s={};for(r=e;r<=t;++r)a(o=n[r].key)&&(s[o]=r);return s}var Sr={create:Tr,update:Tr,destroy:function(n){Tr(n,br)}};function Tr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,s=n===br,a=e===br,i=qr(n.data.directives,n.context),l=qr(e.data.directives,e.context),c=[],p=[];for(t in l)r=i[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,Er(o,"update",e,n),o.def&&o.def.componentUpdated&&p.push(o)):(Er(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Er(c[t],"inserted",e,n)};s?In(e,"insert",u):u()}p.length&&In(e,"postpatch",(function(){for(var t=0;t<p.length;t++)Er(p[t],"componentUpdated",e,n)}));if(!s)for(t in i)l[t]||Er(i[t],"unbind",n,n,a)}(n,e)}var wr=Object.create(null);function qr(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=wr),o[Cr(r)]=r,e._setupState&&e._setupState.__sfc&&(r.def=qt(e,"_setupState","v-"+r.name)),r.def=r.def||qt(e.$options,"directives",r.name);return o}function Cr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Er(n,e,t,r,o){var s=n.def&&n.def[e];if(s)try{s(t.elm,n,t,r,o)}catch(r){Ve(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Fr=[gr,Sr];function jr(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||s(n.data.attrs)&&s(e.data.attrs))){var r,o,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(r in(a(p.__ob__)||i(p._v_attr_proxy))&&(p=e.data.attrs=R({},p)),p)o=p[r],c[r]!==o&&Rr(l,r,o,e.data.pre);for(r in(X||K)&&p.value!==c.value&&Rr(l,"value",p.value),c)s(p[r])&&(tr(r)?l.removeAttributeNS(er,rr(r)):Kt(r)||l.removeAttribute(r))}}function Rr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Ar(n,e,t):nr(e)?or(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Kt(e)?n.setAttribute(e,function(n,e){return or(e)||"false"===e?"false":"contenteditable"===n&&Yt(e)?e:"true"}(e,t)):tr(e)?or(t)?n.removeAttributeNS(er,rr(e)):n.setAttributeNS(er,e,t):Ar(n,e,t)}function Ar(n,e,t){if(or(t))n.removeAttribute(e);else{if(X&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Pr={create:jr,update:jr};function Ir(n,e){var t=e.elm,r=e.data,o=n.data;if(!(s(r.staticClass)&&s(r.class)&&(s(o)||s(o.staticClass)&&s(o.class)))){var i=sr(e),l=t._transitionClasses;a(l)&&(i=ir(i,lr(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var Or,Lr={create:Ir,update:Ir};function Br(n,e,t){var r=Or;return function o(){var s=e.apply(null,arguments);null!==s&&Ur(n,o,t,r)}}var zr=Ye&&!(en&&Number(en[1])<=53);function Mr(n,e,t,r){if(zr){var o=Ue,s=e;e=s._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return s.apply(this,arguments)}}Or.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Ur(n,e,t,r){(r||Or).removeEventListener(n,e._wrapper||e,t)}function $r(n,e){if(!s(n.data.on)||!s(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Or=e.elm||n.elm,function(n){if(a(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Pn(t,r,Mr,Ur,Br,e.context),Or=void 0}}var Hr,Dr={create:$r,update:$r,destroy:function(n){return $r(n,br)}};function Nr(n,e){if(!s(n.data.domProps)||!s(e.data.domProps)){var t,r,o=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(a(c.__ob__)||i(c._v_attr_proxy))&&(c=e.data.domProps=R({},c)),l)t in c||(o[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var p=s(r)?"":String(r);Jr(o,p)&&(o.value=p)}else if("innerHTML"===t&&ur(o.tagName)&&s(o.innerHTML)){(Hr=Hr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Hr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(r!==l[t])try{o[t]=r}catch(n){}}}}function Jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(a(r)){if(r.number)return y(t)!==y(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Gr={create:Nr,update:Nr},Qr=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Vr(n){var e=Wr(n.style);return n.staticStyle?R(n.staticStyle,e):e}function Wr(n){return Array.isArray(n)?A(n):"string"==typeof n?Qr(n):n}var Xr,Zr=/^--/,Kr=/\s*!important$/,Yr=function(n,e,t){if(Zr.test(e))n.style.setProperty(e,t);else if(Kr.test(t))n.style.setProperty(E(e),t.replace(Kr,""),"important");else{var r=eo(e);if(Array.isArray(t))for(var o=0,s=t.length;o<s;o++)n.style[r]=t[o];else n.style[r]=t}},no=["Webkit","Moz","ms"],eo=S((function(n){if(Xr=Xr||document.createElement("div").style,"filter"!==(n=w(n))&&n in Xr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<no.length;t++){var r=no[t]+e;if(r in Xr)return r}}));function to(n,e){var t=e.data,r=n.data;if(!(s(t.staticStyle)&&s(t.style)&&s(r.staticStyle)&&s(r.style))){var o,i,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},u=c||p,d=Wr(e.data.style)||{};e.data.normalizedStyle=a(d.__ob__)?R({},d):d;var f=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Vr(o.data))&&R(r,t);(t=Vr(n.data))&&R(r,t);for(var s=n;s=s.parent;)s.data&&(t=Vr(s.data))&&R(r,t);return r}(e,!0);for(i in u)s(f[i])&&Yr(l,i,"");for(i in f)(o=f[i])!==u[i]&&Yr(l,i,null==o?"":o)}}var ro={create:to,update:to},oo=/\s+/;function so(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(oo).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ao(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(oo).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function io(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&R(e,lo(n.name||"v")),R(e,n),e}return"string"==typeof n?lo(n):void 0}}var lo=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),co=V&&!Z,po="transition",uo="transitionend",fo="animation",ho="animationend";co&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(po="WebkitTransition",uo="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fo="WebkitAnimation",ho="webkitAnimationEnd"));var mo=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function go(n){mo((function(){mo(n)}))}function yo(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),so(n,e))}function vo(n,e){n._transitionClasses&&x(n._transitionClasses,e),ao(n,e)}function bo(n,e,t){var r=ko(n,e),o=r.type,s=r.timeout,a=r.propCount;if(!o)return t();var i="transition"===o?uo:ho,l=0,c=function(){n.removeEventListener(i,p),t()},p=function(e){e.target===n&&++l>=a&&c()};setTimeout((function(){l<a&&c()}),s+1),n.addEventListener(i,p)}var xo=/\b(transform|all)(,|$)/;function ko(n,e){var t,r=window.getComputedStyle(n),o=(r[po+"Delay"]||"").split(", "),s=(r[po+"Duration"]||"").split(", "),a=_o(o,s),i=(r[fo+"Delay"]||"").split(", "),l=(r[fo+"Duration"]||"").split(", "),c=_o(i,l),p=0,u=0;return"transition"===e?a>0&&(t="transition",p=a,u=s.length):"animation"===e?c>0&&(t="animation",p=c,u=l.length):u=(t=(p=Math.max(a,c))>0?a>c?"transition":"animation":null)?"transition"===t?s.length:l.length:0,{type:t,timeout:p,propCount:u,hasTransform:"transition"===t&&xo.test(r[po+"Property"])}}function _o(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return So(e)+So(n[t])})))}function So(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function To(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=io(n.data.transition);if(!s(r)&&!a(t._enterCb)&&1===t.nodeType){for(var o=r.css,i=r.type,l=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,m=r.appearActiveClass,g=r.beforeEnter,v=r.enter,b=r.afterEnter,x=r.enterCancelled,k=r.beforeAppear,_=r.appear,S=r.afterAppear,T=r.appearCancelled,w=r.duration,q=Ee,C=Ee.$vnode;C&&C.parent;)q=C.context,C=C.parent;var E=!q._isMounted||!n.isRootInsert;if(!E||_||""===_){var F=E&&f?f:l,j=E&&m?m:d,R=E&&h?h:u,A=E&&k||g,P=E&&c(_)?_:v,I=E&&S||b,O=E&&T||x,L=y(p(w)?w.enter:w);0;var B=!1!==o&&!Z,M=Co(P),U=t._enterCb=z((function(){B&&(vo(t,R),vo(t,j)),U.cancelled?(B&&vo(t,F),O&&O(t)):I&&I(t),t._enterCb=null}));n.data.show||In(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),P&&P(t,U)})),A&&A(t),B&&(yo(t,F),yo(t,j),go((function(){vo(t,F),U.cancelled||(yo(t,R),M||(qo(L)?setTimeout(U,L):bo(t,i,U)))}))),n.data.show&&(e&&e(),P&&P(t,U)),B||M||U()}}}function wo(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=io(n.data.transition);if(s(r)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var o=r.css,i=r.type,l=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,v=r.duration,b=!1!==o&&!Z,x=Co(f),k=y(p(v)?v.leave:v);0;var _=t._leaveCb=z((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(vo(t,c),vo(t,u)),_.cancelled?(b&&vo(t,l),m&&m(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(S):S()}function S(){_.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),b&&(yo(t,l),yo(t,u),go((function(){vo(t,l),_.cancelled||(yo(t,c),x||(qo(k)?setTimeout(_,k):bo(t,i,_)))}))),f&&f(t,_),b||x||_())}}function qo(n){return"number"==typeof n&&!isNaN(n)}function Co(n){if(s(n))return!1;var e=n.fns;return a(e)?Co(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Eo(n,e){!0!==e.data.show&&To(e)}var Fo=function(n){var e,t,r={},c=n.modules,p=n.nodeOps;for(e=0;e<xr.length;++e)for(r[xr[e]]=[],t=0;t<c.length;++t)a(c[t][xr[e]])&&r[xr[e]].push(c[t][xr[e]]);function u(n){var e=p.parentNode(n);a(e)&&p.removeChild(e,n)}function d(n,e,t,o,s,l,c){if(a(n.elm)&&a(l)&&(n=l[c]=_n(n)),n.isRootInsert=!s,!function(n,e,t,o){var s=n.data;if(a(s)){var l=a(n.componentInstance)&&s.keepAlive;if(a(s=s.hook)&&a(s=s.init)&&s(n,!1),a(n.componentInstance))return f(n,e),h(t,n.elm,o),i(l)&&function(n,e,t,o){var s,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,a(s=i.data)&&a(s=s.transition)){for(s=0;s<r.activate.length;++s)r.activate[s](br,i);e.push(i);break}h(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var u=n.data,d=n.children,g=n.tag;a(g)?(n.elm=n.ns?p.createElementNS(n.ns,g):p.createElement(g,n),b(n),m(n,d,e),a(u)&&y(n,e),h(t,n.elm,o)):i(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,o)):(n.elm=p.createTextNode(n.text),h(t,n.elm,o))}}function f(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(y(n,e),b(n)):(yr(n),e.push(n))}function h(n,e,t){a(n)&&(a(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function m(n,e,t){if(o(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function y(n,t){for(var o=0;o<r.create.length;++o)r.create[o](br,n);a(e=n.data.hook)&&(a(e.create)&&e.create(br,n),a(e.insert)&&t.push(n))}function b(n){var e;if(a(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;a(e=Ee)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function x(n,e,t,r,o,s){for(;r<=o;++r)d(t[r],s,n,e,!1,t,r)}function k(n){var e,t,o=n.data;if(a(o))for(a(e=o.hook)&&a(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function _(n,e,t){for(;e<=t;++e){var r=n[e];a(r)&&(a(r.tag)?(S(r),k(r)):u(r.elm))}}function S(n,e){if(a(e)||a(n.data)){var t,o=r.remove.length+1;for(a(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,o),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&S(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else u(n.elm)}function T(n,e,t,r){for(var o=t;o<r;o++){var s=e[o];if(a(s)&&kr(n,s))return o}}function w(n,e,t,o,l,c){if(n!==e){a(e.elm)&&a(o)&&(e=o[l]=_n(e));var u=e.elm=n.elm;if(i(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?E(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(i(e.isStatic)&&i(n.isStatic)&&e.key===n.key&&(i(e.isCloned)||i(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;a(h)&&a(f=h.hook)&&a(f=f.prepatch)&&f(n,e);var m=n.children,y=e.children;if(a(h)&&g(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);a(f=h.hook)&&a(f=f.update)&&f(n,e)}s(e.text)?a(m)&&a(y)?m!==y&&function(n,e,t,r,o){var i,l,c,u=0,f=0,h=e.length-1,m=e[0],g=e[h],y=t.length-1,v=t[0],b=t[y],k=!o;for(0;u<=h&&f<=y;)s(m)?m=e[++u]:s(g)?g=e[--h]:kr(m,v)?(w(m,v,r,t,f),m=e[++u],v=t[++f]):kr(g,b)?(w(g,b,r,t,y),g=e[--h],b=t[--y]):kr(m,b)?(w(m,b,r,t,y),k&&p.insertBefore(n,m.elm,p.nextSibling(g.elm)),m=e[++u],b=t[--y]):kr(g,v)?(w(g,v,r,t,f),k&&p.insertBefore(n,g.elm,m.elm),g=e[--h],v=t[++f]):(s(i)&&(i=_r(e,u,h)),s(l=a(v.key)?i[v.key]:T(v,e,u,h))?d(v,r,n,m.elm,!1,t,f):kr(c=e[l],v)?(w(c,v,r,t,f),e[l]=void 0,k&&p.insertBefore(n,c.elm,m.elm)):d(v,r,n,m.elm,!1,t,f),v=t[++f]);u>h?x(n,s(t[y+1])?null:t[y+1].elm,t,f,y,r):f>y&&_(e,u,h)}(u,m,y,t,c):a(y)?(a(n.text)&&p.setTextContent(u,""),x(u,null,y,0,y.length-1,t)):a(m)?_(m,0,m.length-1):a(n.text)&&p.setTextContent(u,""):n.text!==e.text&&p.setTextContent(u,e.text),a(h)&&a(f=h.hook)&&a(f=f.postpatch)&&f(n,e)}}}function q(n,e,t){if(i(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var C=v("attrs,class,staticClass,staticStyle,key");function E(n,e,t,r){var o,s=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,i(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(o=l.hook)&&a(o=o.init)&&o(e,!0),a(o=e.componentInstance)))return f(e,t),!0;if(a(s)){if(a(c))if(n.hasChildNodes())if(a(o=l)&&a(o=o.domProps)&&a(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var p=!0,u=n.firstChild,d=0;d<c.length;d++){if(!u||!E(u,c[d],t,r)){p=!1;break}u=u.nextSibling}if(!p||u)return!1}else m(e,c,t);if(a(l)){var h=!1;for(var g in l)if(!C(g)){h=!0,y(e,t);break}!h&&l.class&&jn(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!s(e)){var l,c=!1,u=[];if(s(n))c=!0,d(e,u);else{var f=a(n.nodeType);if(!f&&kr(n,e))w(n,e,u,null,null,o);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),i(t)&&E(n,e,u))return q(e,u,!0),n;l=n,n=new bn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,m=p.parentNode(h);if(d(e,u,h._leaveCb?null:m,p.nextSibling(h)),a(e.parent))for(var y=e.parent,v=g(e);y;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](y);if(y.elm=e.elm,v){for(var x=0;x<r.create.length;++x)r.create[x](br,y);var S=y.data.hook.insert;if(S.merged)for(var T=1;T<S.fns.length;T++)S.fns[T]()}else yr(y);y=y.parent}a(m)?_([n],0,0):a(n.tag)&&k(n)}}return q(e,u,c),e.elm}a(n)&&k(n)}}({nodeOps:mr,modules:[Pr,Lr,Dr,Gr,ro,V?{create:Eo,activate:Eo,remove:function(n,e){!0!==n.data.show?wo(n,e):e()}}:{}].concat(Fr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Bo(n,"input")}));var jo={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?In(t,"postpatch",(function(){jo.componentUpdated(n,e,t)})):Ro(n,e,t.context),n._vOptions=[].map.call(n.options,Io)):("textarea"===t.tag||hr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Oo),n.addEventListener("compositionend",Lo),n.addEventListener("change",Lo),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ro(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,Io);if(o.some((function(n,e){return!L(n,r[e])})))(n.multiple?e.value.some((function(n){return Po(n,o)})):e.value!==e.oldValue&&Po(e.value,o))&&Bo(n,"change")}}};function Ro(n,e,t){Ao(n,e,t),(X||K)&&setTimeout((function(){Ao(n,e,t)}),0)}function Ao(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var s,a,i=0,l=n.options.length;i<l;i++)if(a=n.options[i],o)s=B(r,Io(a))>-1,a.selected!==s&&(a.selected=s);else if(L(Io(a),r))return void(n.selectedIndex!==i&&(n.selectedIndex=i));o||(n.selectedIndex=-1)}}function Po(n,e){return e.every((function(e){return!L(e,n)}))}function Io(n){return"_value"in n?n._value:n.value}function Oo(n){n.target.composing=!0}function Lo(n){n.target.composing&&(n.target.composing=!1,Bo(n.target,"input"))}function Bo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function zo(n){return!n.componentInstance||n.data&&n.data.transition?n:zo(n.componentInstance._vnode)}var Mo={model:jo,show:{bind:function(n,e,t){var r=e.value,o=(t=zo(t)).data&&t.data.transition,s=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,To(t,(function(){n.style.display=s}))):n.style.display=r?s:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=zo(t)).data&&t.data.transition?(t.data.show=!0,r?To(t,(function(){n.style.display=n.__vOriginalDisplay})):wo(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},Uo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $o(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$o(Se(e.children)):n}function Ho(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var r in o)e[w(r)]=o[r];return e}function Do(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var No=function(n){return n.tag||Hn(n)},Jo=function(n){return"show"===n.name},Go={name:"transition",props:Uo,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(No)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var s=$o(o);if(!s)return o;if(this._leaving)return Do(n,o);var a="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?a+"comment":a+s.tag:l(s.key)?0===String(s.key).indexOf(a)?s.key:a+s.key:s.key;var i=(s.data||(s.data={})).transition=Ho(this),c=this._vnode,p=$o(c);if(s.data.directives&&s.data.directives.some(Jo)&&(s.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(s,p)&&!Hn(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var u=p.data.transition=R({},i);if("out-in"===r)return this._leaving=!0,In(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Do(n,o);if("in-out"===r){if(Hn(s))return c;var d,f=function(){d()};In(i,"afterEnter",f),In(i,"enterCancelled",f),In(u,"delayLeave",(function(n){d=n}))}}return o}}},Qo=R({tag:String,moveClass:String},Uo);function Vo(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Wo(n){n.data.newPos=n.elm.getBoundingClientRect()}function Xo(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var s=n.elm.style;s.transform=s.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),s.transitionDuration="0s"}}delete Qo.mode;var Zo={Transition:Go,TransitionGroup:{props:Qo,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Fe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],s=this.children=[],a=Ho(this),i=0;i<o.length;i++){if((p=o[i]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))s.push(p),t[p.key]=p,(p.data||(p.data={})).transition=a;else;}if(r){var l=[],c=[];for(i=0;i<r.length;i++){var p;(p=r[i]).data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,s)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Vo),n.forEach(Wo),n.forEach(Xo),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;yo(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(uo,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(uo,n),t._moveCb=null,vo(t,e))})}})))},methods:{hasMove:function(n,e){if(!co)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ao(t,n)})),so(t,e),t.style.display="none",this.$el.appendChild(t);var r=ko(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function Ko(n,e){for(var t in e)n[t]=e[t];return n}Ht.config.mustUseProp=function(n,e,t){return"value"===t&&Zt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ht.config.isReservedTag=dr,Ht.config.isReservedAttr=Xt,Ht.config.getTagNamespace=function(n){return ur(n)?"svg":"math"===n?"math":void 0},Ht.config.isUnknownElement=function(n){if(!V)return!0;if(dr(n))return!1;if(n=n.toLowerCase(),null!=fr[n])return fr[n];var e=document.createElement(n);return n.indexOf("-")>-1?fr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:fr[n]=/HTMLUnknownElement/.test(e.toString())},R(Ht.options.directives,Mo),R(Ht.options.components,Zo),Ht.prototype.__patch__=V?Fo:P,Ht.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=xn),Ae(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Qe(n,r,P,{before:function(){n._isMounted&&!n._isDestroyed&&Ae(n,"beforeUpdate")}},!0),t=!1;var o=n._preWatchers;if(o)for(var s=0;s<o.length;s++)o[s].run();return null==n.$vnode&&(n._isMounted=!0,Ae(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){H.devtools&&an&&an.emit("init",Ht)}),0);var Yo=/[!'()*]/g,ns=function(n){return"%"+n.charCodeAt(0).toString(16)},es=/%2C/g,ts=function(n){return encodeURIComponent(n).replace(Yo,ns).replace(es,",")};function rs(n){try{return decodeURIComponent(n)}catch(n){0}return n}var os=function(n){return null==n||"object"==typeof n?n:String(n)};function ss(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=rs(t.shift()),o=t.length>0?rs(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function as(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ts(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(ts(e)):r.push(ts(e)+"="+ts(n)))})),r.join("&")}return ts(e)+"="+ts(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var is=/\/?$/;function ls(n,e,t,r){var o=r&&r.options.stringifyQuery,s=e.query||{};try{s=cs(s)}catch(n){}var a={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:s,params:e.params||{},fullPath:ds(e,o),matched:n?us(n):[]};return t&&(a.redirectedFrom=ds(t,o)),Object.freeze(a)}function cs(n){if(Array.isArray(n))return n.map(cs);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=cs(n[t]);return e}return n}var ps=ls(null,{path:"/"});function us(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ds(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||as)(r)+o}function fs(n,e,t){return e===ps?n===e:!!e&&(n.path&&e.path?n.path.replace(is,"")===e.path.replace(is,"")&&(t||n.hash===e.hash&&hs(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&hs(n.query,e.query)&&hs(n.params,e.params))))}function hs(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var s=n[t];if(r[o]!==t)return!1;var a=e[t];return null==s||null==a?s===a:"object"==typeof s&&"object"==typeof a?hs(s,a):String(s)===String(a)}))}function ms(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],s=t.enteredCbs[r];if(o&&s){delete t.enteredCbs[r];for(var a=0;a<s.length;a++)o._isBeingDestroyed||s[a](o)}}}}var gs={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,s=e.data;s.routerView=!0;for(var a=o.$createElement,i=t.name,l=o.$route,c=o._routerViewCache||(o._routerViewCache={}),p=0,u=!1;o&&o._routerRoot!==o;){var d=o.$vnode?o.$vnode.data:{};d.routerView&&p++,d.keepAlive&&o._directInactive&&o._inactive&&(u=!0),o=o.$parent}if(s.routerViewDepth=p,u){var f=c[i],h=f&&f.component;return h?(f.configProps&&ys(h,s,f.route,f.configProps),a(h,s,r)):a()}var m=l.matched[p],g=m&&m.components[i];if(!m||!g)return c[i]=null,a();c[i]={component:g},s.registerRouteInstance=function(n,e){var t=m.instances[i];(e&&t!==n||!e&&t===n)&&(m.instances[i]=e)},(s.hook||(s.hook={})).prepatch=function(n,e){m.instances[i]=e.componentInstance},s.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[i]&&(m.instances[i]=n.componentInstance),ms(l)};var y=m.props&&m.props[i];return y&&(Ko(c[i],{route:l,configProps:y}),ys(g,s,l,y)),a(g,s,r)}};function ys(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=Ko({},o);var s=e.attrs=e.attrs||{};for(var a in o)n.props&&a in n.props||(s[a]=o[a],delete o[a])}}function vs(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var s=n.replace(/^\//,"").split("/"),a=0;a<s.length;a++){var i=s[a];".."===i?o.pop():"."!==i&&o.push(i)}return""!==o[0]&&o.unshift(""),o.join("/")}function bs(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var xs=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ks=Os,_s=Cs,Ss=function(n,e){return Fs(Cs(n,e),e)},Ts=Fs,ws=Is,qs=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Cs(n,e){for(var t,r=[],o=0,s=0,a="",i=e&&e.delimiter||"/";null!=(t=qs.exec(n));){var l=t[0],c=t[1],p=t.index;if(a+=n.slice(s,p),s=p+l.length,c)a+=c[1];else{var u=n[s],d=t[2],f=t[3],h=t[4],m=t[5],g=t[6],y=t[7];a&&(r.push(a),a="");var v=null!=d&&null!=u&&u!==d,b="+"===g||"*"===g,x="?"===g||"*"===g,k=t[2]||i,_=h||m;r.push({name:f||o++,prefix:d||"",delimiter:k,optional:x,repeat:b,partial:v,asterisk:!!y,pattern:_?Rs(_):y?".*":"[^"+js(k)+"]+?"})}}return s<n.length&&(a+=n.substr(s)),a&&r.push(a),r}function Es(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Fs(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Ps(e)));return function(e,r){for(var o="",s=e||{},a=(r||{}).pretty?Es:encodeURIComponent,i=0;i<n.length;i++){var l=n[i];if("string"!=typeof l){var c,p=s[l.name];if(null==p){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(xs(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<p.length;u++){if(c=a(p[u]),!t[i].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):a(p),!t[i].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function js(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Rs(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function As(n,e){return n.keys=e,n}function Ps(n){return n&&n.sensitive?"":"i"}function Is(n,e,t){xs(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,s="",a=0;a<n.length;a++){var i=n[a];if("string"==typeof i)s+=js(i);else{var l=js(i.prefix),c="(?:"+i.pattern+")";e.push(i),i.repeat&&(c+="(?:"+l+c+")*"),s+=c=i.optional?i.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=js(t.delimiter||"/"),u=s.slice(-p.length)===p;return r||(s=(u?s.slice(0,-p.length):s)+"(?:"+p+"(?=$))?"),s+=o?"$":r&&u?"":"(?="+p+"|$)",As(new RegExp("^"+s,Ps(t)),e)}function Os(n,e,t){return xs(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return As(n,e)}(n,e):xs(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(Os(n[o],e,t).source);return As(new RegExp("(?:"+r.join("|")+")",Ps(t)),e)}(n,e,t):function(n,e,t){return Is(Cs(n,t),e,t)}(n,e,t)}ks.parse=_s,ks.compile=Ss,ks.tokensToFunction=Ts,ks.tokensToRegExp=ws;var Ls=Object.create(null);function Bs(n,e,t){e=e||{};try{var r=Ls[n]||(Ls[n]=ks.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function zs(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var s=(o=Ko({},n)).params;return s&&"object"==typeof s&&(o.params=Ko({},s)),o}if(!o.path&&o.params&&e){(o=Ko({},o))._normalized=!0;var a=Ko(Ko({},e.params),o.params);if(e.name)o.name=e.name,o.params=a;else if(e.matched.length){var i=e.matched[e.matched.length-1].path;o.path=Bs(i,a,e.path)}else 0;return o}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),c=e&&e.path||"/",p=l.path?vs(l.path,c,t||o.append):c,u=function(n,e,t){void 0===e&&(e={});var r,o=t||ss;try{r=o(n||"")}catch(n){r={}}for(var s in e){var a=e[s];r[s]=Array.isArray(a)?a.map(os):os(a)}return r}(l.query,o.query,r&&r.options.parseQuery),d=o.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:p,query:u,hash:d}}var Ms,Us=function(){},$s={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),s=o.location,a=o.route,i=o.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,d=null==p?"router-link-exact-active":p,f=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,m=a.redirectedFrom?ls(null,zs(a.redirectedFrom),null,t):a;l[h]=fs(r,m,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(is,"/").indexOf(e.path.replace(is,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,m);var g=l[h]?this.ariaCurrentValue:null,y=function(n){Hs(n)&&(e.replace?t.replace(s,Us):t.push(s,Us))},v={click:Hs};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=y})):v[this.event]=y;var b={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:i,route:a,navigate:y,isActive:l[f],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)b.on=v,b.attrs={href:i,"aria-current":g};else{var k=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var _=k.data=Ko({},k.data);for(var S in _.on=_.on||{},_.on){var T=_.on[S];S in v&&(_.on[S]=Array.isArray(T)?T:[T])}for(var w in v)w in _.on?_.on[w].push(v[w]):_.on[w]=y;var q=k.data.attrs=Ko({},k.data.attrs);q.href=i,q["aria-current"]=g}else b.on=v}return n(this.tag,b,this.$slots.default)}};function Hs(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ds="undefined"!=typeof window;function Ns(n,e,t,r,o){var s=e||[],a=t||Object.create(null),i=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,s,a){var i=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return bs(e.path+"/"+n)}(i,s,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var u={path:p,regex:Js(p,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:s,matchAs:a,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var s=a?bs(a+"/"+o.path):void 0;n(e,t,r,o,u,s)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==o.alias)for(var d=Array.isArray(o.alias)?o.alias:[o.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:o.children};n(e,t,r,h,s,u.path||"/")}l&&(r[l]||(r[l]=u))}(s,a,i,n,o)}));for(var l=0,c=s.length;l<c;l++)"*"===s[l]&&(s.push(s.splice(l,1)[0]),c--,l--);return{pathList:s,pathMap:a,nameMap:i}}function Js(n,e){return ks(n,[],e)}function Gs(n,e){var t=Ns(n),r=t.pathList,o=t.pathMap,s=t.nameMap;function a(n,t,a){var i=zs(n,t,!1,e),c=i.name;if(c){var p=s[c];if(!p)return l(null,i);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof i.params&&(i.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in i.params)&&u.indexOf(d)>-1&&(i.params[d]=t.params[d]);return i.path=Bs(p.path,i.params),l(p,i,a)}if(i.path){i.params={};for(var f=0;f<r.length;f++){var h=r[f],m=o[h];if(Qs(m.regex,i.path,i.params))return l(m,i,a)}}return l(null,i)}function i(n,t){var r=n.redirect,o="function"==typeof r?r(ls(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var i=o,c=i.name,p=i.path,u=t.query,d=t.hash,f=t.params;if(u=i.hasOwnProperty("query")?i.query:u,d=i.hasOwnProperty("hash")?i.hash:d,f=i.hasOwnProperty("params")?i.params:f,c){s[c];return a({_normalized:!0,name:c,query:u,hash:d,params:f},void 0,t)}if(p){var h=function(n,e){return vs(n,e.parent?e.parent.path:"/",!0)}(p,n);return a({_normalized:!0,path:Bs(h,f),query:u,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?i(n,r||t):n&&n.matchAs?function(n,e,t){var r=a({_normalized:!0,path:Bs(t,e.params)});if(r){var o=r.matched,s=o[o.length-1];return e.params=r.params,l(s,e)}return l(null,e)}(0,t,n.matchAs):ls(n,t,r,e)}return{match:a,addRoute:function(n,e){var t="object"!=typeof n?s[n]:void 0;Ns([e||n],r,o,s,t),t&&t.alias.length&&Ns(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,s,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Ns(n,r,o,s)}}}function Qs(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,s=r.length;o<s;++o){var a=n.keys[o-1];a&&(t[a.name||"pathMatch"]="string"==typeof r[o]?rs(r[o]):r[o])}return!0}var Vs=Ds&&window.performance&&window.performance.now?window.performance:Date;function Ws(){return Vs.now().toFixed(3)}var Xs=Ws();function Zs(){return Xs}function Ks(n){return Xs=n}var Ys=Object.create(null);function na(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Ko({},window.history.state);return t.key=Zs(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ra),function(){window.removeEventListener("popstate",ra)}}function ea(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var s=function(){var n=Zs();if(n)return Ys[n]}(),a=o.call(n,e,t,r?s:null);a&&("function"==typeof a.then?a.then((function(n){la(n,s)})).catch((function(n){0})):la(a,s))}))}}function ta(){var n=Zs();n&&(Ys[n]={x:window.pageXOffset,y:window.pageYOffset})}function ra(n){ta(),n.state&&n.state.key&&Ks(n.state.key)}function oa(n){return aa(n.x)||aa(n.y)}function sa(n){return{x:aa(n.x)?n.x:window.pageXOffset,y:aa(n.y)?n.y:window.pageYOffset}}function aa(n){return"number"==typeof n}var ia=/^#\d/;function la(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=ia.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var s=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,s={x:aa((t=s).x)?t.x:0,y:aa(t.y)?t.y:0})}else oa(n)&&(e=sa(n))}else r&&oa(n)&&(e=sa(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ca,pa=Ds&&((-1===(ca=window.navigator.userAgent).indexOf("Android 2.")&&-1===ca.indexOf("Android 4.0")||-1===ca.indexOf("Mobile Safari")||-1!==ca.indexOf("Chrome")||-1!==ca.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ua(n,e){ta();var t=window.history;try{if(e){var r=Ko({},t.state);r.key=Zs(),t.replaceState(r,"",n)}else t.pushState({key:Ks(Ws())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function da(n){ua(n,!0)}function fa(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}var ha={redirected:2,aborted:4,cancelled:8,duplicated:16};function ma(n,e){return ya(n,e,ha.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return va.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function ga(n,e){return ya(n,e,ha.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ya(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var va=["params","query","hash"];function ba(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function xa(n,e){return ba(n)&&n._isRouter&&(null==e||n.type===e)}function ka(n){return function(e,t,r){var o=!1,s=0,a=null;_a(n,(function(n,e,t,i){if("function"==typeof n&&void 0===n.cid){o=!0,s++;var l,c=wa((function(e){var o;((o=e).__esModule||Ta&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ms.extend(e),t.components[i]=e,--s<=0&&r()})),p=wa((function(n){var e="Failed to resolve async component "+i+": "+n;a||(a=ba(n)?n:new Error(e),r(a))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,p)}}})),o||r()}}function _a(n,e){return Sa(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Sa(n){return Array.prototype.concat.apply([],n)}var Ta="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function wa(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var qa=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ds){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ps,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ca(n,e,t,r){var o=_a(n,(function(n,r,o,s){var a=function(n,e){"function"!=typeof n&&(n=Ms.extend(n));return n.options[e]}(n,e);if(a)return Array.isArray(a)?a.map((function(n){return t(n,r,o,s)})):t(a,r,o,s)}));return Sa(r?o.reverse():o)}function Ea(n,e){if(e)return function(){return n.apply(e,arguments)}}qa.prototype.listen=function(n){this.cb=n},qa.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},qa.prototype.onError=function(n){this.errorCbs.push(n)},qa.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var s=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,s)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(xa(n,ha.redirected)&&s===ps||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},qa.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var s,a,i=function(n){!xa(n)&&ba(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(fs(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),n.hash&&ea(this.router,o,n,!1),i(((a=ya(s=o,n,ha.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",a));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=p.updated,d=p.deactivated,f=p.activated,h=[].concat(function(n){return Ca(n,"beforeRouteLeave",Ea,!0)}(d),this.router.beforeHooks,function(n){return Ca(n,"beforeRouteUpdate",Ea)}(u),f.map((function(n){return n.beforeEnter})),ka(f)),m=function(e,t){if(r.pending!==n)return i(ga(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),i(function(n,e){return ya(n,e,ha.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):ba(e)?(r.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(ma(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){i(n)}};fa(h,m,(function(){fa(function(n){return Ca(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,s){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),s(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return i(ga(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){ms(n)}))}))}))},qa.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},qa.prototype.setupListeners=function(){},qa.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ps,this.pending=null};var Fa=function(n){function e(e,t){n.call(this,e,t),this._startLocation=ja(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=pa&&t;r&&this.listeners.push(na());var o=function(){var t=n.current,o=ja(n.base);n.current===ps&&o===n._startLocation||n.transitionTo(o,(function(n){r&&ea(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){ua(bs(r.base+n.fullPath)),ea(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){da(bs(r.base+n.fullPath)),ea(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(ja(this.base)!==this.current.fullPath){var e=bs(this.base+this.current.fullPath);n?ua(e):da(e)}},e.prototype.getCurrentLocation=function(){return ja(this.base)},e}(qa);function ja(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(bs(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ra=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=ja(n);if(!/^\/#/.test(e))return window.location.replace(bs(n+"/#"+e)),!0}(this.base)||Aa()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=pa&&e;t&&this.listeners.push(na());var r=function(){var e=n.current;Aa()&&n.transitionTo(Pa(),(function(r){t&&ea(n.router,r,e,!0),pa||La(r.fullPath)}))},o=pa?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Oa(n.fullPath),ea(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){La(n.fullPath),ea(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Pa()!==e&&(n?Oa(e):La(e))},e.prototype.getCurrentLocation=function(){return Pa()},e}(qa);function Aa(){var n=Pa();return"/"===n.charAt(0)||(La("/"+n),!1)}function Pa(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ia(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Oa(n){pa?ua(Ia(n)):window.location.hash=n}function La(n){pa?da(Ia(n)):window.location.replace(Ia(n))}var Ba=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){xa(n,ha.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(qa),za=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Gs(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!pa&&!1!==n.fallback,this.fallback&&(e="hash"),Ds||(e="abstract"),this.mode=e,e){case"history":this.history=new Fa(this,n.base);break;case"hash":this.history=new Ra(this,n.base,this.fallback);break;case"abstract":this.history=new Ba(this,n.base);break;default:0}},Ma={currentRoute:{configurable:!0}};function Ua(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}za.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ma.currentRoute.get=function(){return this.history&&this.history.current},za.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Fa||t instanceof Ra){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;pa&&o&&"fullPath"in n&&ea(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},za.prototype.beforeEach=function(n){return Ua(this.beforeHooks,n)},za.prototype.beforeResolve=function(n){return Ua(this.resolveHooks,n)},za.prototype.afterEach=function(n){return Ua(this.afterHooks,n)},za.prototype.onReady=function(n,e){this.history.onReady(n,e)},za.prototype.onError=function(n){this.history.onError(n)},za.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},za.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},za.prototype.go=function(n){this.history.go(n)},za.prototype.back=function(){this.go(-1)},za.prototype.forward=function(){this.go(1)},za.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},za.prototype.resolve=function(n,e,t){var r=zs(n,e=e||this.history.current,t,this),o=this.match(r,e),s=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?bs(n+"/"+r):r}(this.history.base,s,this.mode),normalizedTo:r,resolved:o}},za.prototype.getRoutes=function(){return this.matcher.getRoutes()},za.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ps&&this.history.transitionTo(this.history.getCurrentLocation())},za.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ps&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(za.prototype,Ma),za.install=function n(e){if(!n.installed||Ms!==e){n.installed=!0,Ms=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",gs),e.component("RouterLink",$s);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},za.version="3.5.4",za.isNavigationFailure=xa,za.NavigationFailureType=ha,za.START_LOCATION=ps,Ds&&window.Vue&&window.Vue.use(za);var $a=za;t(101);t(124);var Ha={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,322)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,321))},Da={"v-79fe969c":()=>t.e(6).then(t.bind(null,323)),"v-08a9f753":()=>t.e(10).then(t.bind(null,324)),"v-734a25f4":()=>t.e(7).then(t.bind(null,325)),"v-5c0174b0":()=>t.e(8).then(t.bind(null,326)),"v-424e5bd0":()=>t.e(9).then(t.bind(null,327)),"v-0d22f8f3":()=>t.e(11).then(t.bind(null,328)),"v-439422c9":()=>t.e(12).then(t.bind(null,329)),"v-9d6b1a9a":()=>t.e(13).then(t.bind(null,330)),"v-47f8bcf5":()=>t.e(14).then(t.bind(null,331)),"v-dfc6439a":()=>t.e(15).then(t.bind(null,332)),"v-90253aa6":()=>t.e(16).then(t.bind(null,333)),"v-a477f05e":()=>t.e(17).then(t.bind(null,334)),"v-0859f29a":()=>t.e(18).then(t.bind(null,335)),"v-4e19ff1a":()=>t.e(19).then(t.bind(null,336)),"v-42c56ef3":()=>t.e(20).then(t.bind(null,337)),"v-27e9a7a7":()=>t.e(21).then(t.bind(null,338)),"v-356ce46f":()=>t.e(22).then(t.bind(null,339)),"v-72d1cb9a":()=>t.e(25).then(t.bind(null,340)),"v-b12b9d52":()=>t.e(23).then(t.bind(null,341)),"v-10f1c410":()=>t.e(26).then(t.bind(null,342)),"v-75bc8ce7":()=>t.e(24).then(t.bind(null,343)),"v-3f6f28e8":()=>t.e(27).then(t.bind(null,344)),"v-304de9cc":()=>t.e(28).then(t.bind(null,345)),"v-67914a1a":()=>t.e(29).then(t.bind(null,346)),"v-87ea91a4":()=>t.e(30).then(t.bind(null,347)),"v-56e3e48c":()=>t.e(32).then(t.bind(null,348)),"v-2932182e":()=>t.e(34).then(t.bind(null,349)),"v-5954d9e8":()=>t.e(33).then(t.bind(null,350)),"v-a1d890b4":()=>t.e(35).then(t.bind(null,351)),"v-207735cc":()=>t.e(36).then(t.bind(null,352)),"v-3995ef50":()=>t.e(37).then(t.bind(null,353)),"v-1eee5f6c":()=>t.e(38).then(t.bind(null,354)),"v-7f8efa68":()=>t.e(39).then(t.bind(null,355)),"v-3bb81cec":()=>t.e(40).then(t.bind(null,356)),"v-6885eba8":()=>t.e(41).then(t.bind(null,357)),"v-42e16c48":()=>t.e(42).then(t.bind(null,358)),"v-66f72f14":()=>t.e(44).then(t.bind(null,359)),"v-8652de94":()=>t.e(31).then(t.bind(null,360)),"v-4d0b84ec":()=>t.e(43).then(t.bind(null,361)),"v-934bcb3c":()=>t.e(45).then(t.bind(null,362)),"v-d3a37f44":()=>t.e(47).then(t.bind(null,363)),"v-587b290e":()=>t.e(46).then(t.bind(null,364)),"v-1f0c5104":()=>t.e(48).then(t.bind(null,365)),"v-6c0b53bc":()=>t.e(49).then(t.bind(null,366)),"v-3002147e":()=>t.e(51).then(t.bind(null,367)),"v-3ba4607c":()=>t.e(50).then(t.bind(null,368)),"v-56909398":()=>t.e(52).then(t.bind(null,369)),"v-b1ff77a4":()=>t.e(53).then(t.bind(null,370)),"v-4be650fe":()=>t.e(54).then(t.bind(null,371)),"v-24a2f37e":()=>t.e(57).then(t.bind(null,372)),"v-77bf47fe":()=>t.e(55).then(t.bind(null,373)),"v-bc96cdbc":()=>t.e(59).then(t.bind(null,374)),"v-46b082d4":()=>t.e(56).then(t.bind(null,375)),"v-4365e2e8":()=>t.e(61).then(t.bind(null,376)),"v-52dfbad6":()=>t.e(60).then(t.bind(null,377)),"v-57403bbe":()=>t.e(58).then(t.bind(null,378)),"v-0daf3774":()=>t.e(62).then(t.bind(null,379)),"v-3a7c0a5a":()=>t.e(63).then(t.bind(null,380)),"v-326ffa2f":()=>t.e(64).then(t.bind(null,381)),"v-b4a40016":()=>t.e(65).then(t.bind(null,382)),"v-2022e0ae":()=>t.e(66).then(t.bind(null,383)),"v-6cf70ea9":()=>t.e(67).then(t.bind(null,384)),"v-05d82ecb":()=>t.e(68).then(t.bind(null,385)),"v-e355a5c4":()=>t.e(70).then(t.bind(null,386)),"v-9669bccc":()=>t.e(69).then(t.bind(null,387)),"v-41fb2586":()=>t.e(71).then(t.bind(null,388)),"v-78153190":()=>t.e(72).then(t.bind(null,389)),"v-5b0d2084":()=>t.e(73).then(t.bind(null,390)),"v-3fd0a948":()=>t.e(75).then(t.bind(null,391)),"v-0015b6de":()=>t.e(74).then(t.bind(null,392)),"v-08061b16":()=>t.e(76).then(t.bind(null,393)),"v-2c782d95":()=>t.e(77).then(t.bind(null,394)),"v-46c27bdf":()=>t.e(80).then(t.bind(null,395)),"v-37b0d296":()=>t.e(78).then(t.bind(null,396)),"v-09990286":()=>t.e(79).then(t.bind(null,397)),"v-2ae768c1":()=>t.e(82).then(t.bind(null,398)),"v-d5edb880":()=>t.e(81).then(t.bind(null,399)),"v-2ccc5a68":()=>t.e(84).then(t.bind(null,400)),"v-044a573f":()=>t.e(83).then(t.bind(null,401)),"v-160dfc8b":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,402))};function Na(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ja=/-(\w)/g,Ga=Na(n=>n.replace(Ja,(n,e)=>e?e.toUpperCase():"")),Qa=/\B([A-Z])/g,Va=Na(n=>n.replace(Qa,"-$1").toLowerCase()),Wa=Na(n=>n.charAt(0).toUpperCase()+n.slice(1));function Xa(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Wa(Ga(e))):n(Wa(e))||n(Va(e))}const Za=Object.assign({},Ha,Da),Ka=n=>Za[n],Ya=n=>Da[n],ni=n=>Ha[n],ei=n=>Ht.component(n);function ti(n){return Xa(Ya,n)}function ri(n){return Xa(ni,n)}function oi(n){return Xa(Ka,n)}function si(n){return Xa(ei,n)}function ai(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!si(n)&&oi(n)){const e=await oi(n)();Ht.component(n,e.default)}}))}function ii(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var li=t(90),ci=t.n(li),pi=t(91),ui=t.n(pi),di={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ui()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=hi(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=mi(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ci()([{name:"description",content:this.$description}],n,this.siteMeta,gi)},updateCanonicalLink(){fi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",hi(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){mi(null,this.currentMetaTags),fi()}};function fi(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function hi(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function mi(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function gi(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var yi=t(49),vi={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(yi)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const s=e[n],a=e[n+1],i=0===n&&0===t||t>=s.parentElement.offsetTop+10&&(!a||t<a.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(i&&l!==decodeURIComponent(s.hash)){const t=s;if(o===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},bi=t(23),xi=t.n(bi),ki={mounted(){xi.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ht.component(n.name)||xi.a.start(),t()}),this.$router.afterEach(()=>{xi.a.done(),this.isSidebarOpen=!1})}};t(231),t(232);class _i{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Si={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new _i).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ti={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},wi={},qi=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ci=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ti[n]},Ei=function n(e,t,r){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,s=e.children;o.appendChild(n(t,r,s))})),o},Fi=function(n,e,t){var r,o=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==o.length||t?o:o[0]},ji=function(n,e){var t,r,o=n.match(/<style>([\s\S]+)<\/style>/),s=n.match(/<template>([\s\S]+)<\/template>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:o&&o[1].replace(/^\n|\n$/g,""),html:s&&s[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};i.htmlTpl=qi(i.html),i.jsTpl=(t=i.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),i.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,s=[eval][0](o);return s.template=e,s}(i.js,i.html);var l=Ci("vue");return i.jsLib.unshift(l),i},Ri=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),s=n.match(/<script>([\s\S]+)<\/script>/),a={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return a.htmlTpl=a.html,a.jsTpl=a.js,a.script=(t=a.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),a},Ai=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Pi(){var n=Fi(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Fi(n,"vuepress-plugin-demo-block__code"),t=Fi(n,"vuepress-plugin-demo-block__display"),r=Fi(n,"vuepress-plugin-demo-block__footer"),o=Fi(t,"vuepress-plugin-demo-block__app"),s=decodeURIComponent(n.dataset.code),a=decodeURIComponent(n.dataset.config),i=decodeURIComponent(n.dataset.type);a=a?JSON.parse(a):{};var l=e.querySelector("div").clientHeight,c="react"===i?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(r))(),s={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ai(n),htmlTpl:qi("")},a=Ci("react"),i=Ci("reactDOM");return s.jsLib.unshift(a,i),s}(s,a):"vanilla"===i?Ri(s,a):ji(s,a),p=Ei("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",Ii.bind(null,p,l,e,r)),Ci("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,s=n.cssLib,a=o.concat(s).concat(Ci("cssLib")).concat(Ci("jsLib")).join(",");return Ei("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:a}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ci("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,s=n.cssLib,a=JSON.stringify({css:e,html:t,js:r,js_external:o.concat(Ci("jsLib")).join(";"),css_external:s.concat(Ci("cssLib")).join(";"),layout:Ci("codepenLayout"),js_pre_processor:Ci("codepenJsProcessor"),editors:Ci("codepenEditors")});return Ei("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:a}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==a.horizontal?a.horizontal:Ci("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!wi[n]){var e=Ei("style",{innerHTML:n});document.body.appendChild(e),wi[n]=!0}}(c.css),"react"===i)ReactDOM.render(React.createElement(c.js),o);else if("vue"===i){var d=(new(Vue.extend(c.script))).$mount();o.appendChild(d.$el)}else"vanilla"===i&&(o.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Pi()}),300)}function Ii(n,e,t,r){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Oi={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Pi()},updated:function(){Pi()}},Li="auto",Bi="zoom-in",zi="zoom-out",Mi="grab",Ui="move";function $i(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o={passive:!1};r?n.addEventListener(e,t,o):n.removeEventListener(e,t,o)}function Hi(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Di(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ni(n,e,t){!function(n){var e=Ji,t=Gi;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var o=n.transform;delete n.transform,n[t]=o}}(e);var r=n.style,o={};for(var s in e)t&&(o[s]=r[s]||""),r[s]=e[s];return o}var Ji="transition",Gi="transform",Qi="transform",Vi="transitionend";var Wi=function(){},Xi={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Wi,onClose:Wi,onGrab:Wi,onMove:Wi,onRelease:Wi,onBeforeOpen:Wi,onBeforeClose:Wi,onBeforeGrab:Wi,onBeforeRelease:Wi,onImageLoading:Wi,onImageLoaded:Wi},Zi={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Yi(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,o=this.lastScrollPosition.y-t,s=this.options.scrollThreshold;(Math.abs(o)>=s||Math.abs(r)>=s)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Ki(n)&&!Yi(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Ki(n)&&!Yi(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Ki(n){return 0===n.button}function Yi(n){return n.metaKey||n.ctrlKey}var nl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ni(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),$i(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ni(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},el="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},tl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),rl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ol={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Di(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,o=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Mi:zi,transition:Qi+"\n        "+r+"s\n        "+o,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ni(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ni(this.el,{transform:"none"})},grab:function(n,e,t){var r=sl(),o=r.x-n,s=r.y-e;Ni(this.el,{cursor:Ui,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+s)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=sl(),o=r.x-n,s=r.y-e;Ni(this.el,{transition:Qi,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+s)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ni(this.el,this.styleClose)},restoreOpenStyle:function(){Ni(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=sl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,o=r.customSize,s=r.scaleBase;if(!o&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(o&&"object"===(void 0===o?"undefined":el(o)))return{x:o.width/this.rect.width,y:o.height/this.rect.height};var a=this.rect.width/2,i=this.rect.height/2,l=sl(),c={x:l.x-a,y:l.y-i},p=c.x/a,u=c.y/i,d=s+Math.min(p,u);if(o&&"string"==typeof o){var f=t||this.el.naturalWidth,h=e||this.el.naturalHeight,m=parseFloat(o)*f/(100*this.rect.width),g=parseFloat(o)*h/(100*this.rect.height);if(d>m||d>g)return{x:m,y:g}}return{x:d,y:d}}};function sl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function al(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){$i(n,r,e[r],t)}))}var il=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ol),this.overlay=Object.create(nl),this.handler=Object.create(Zi),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=rl({},Xi,e),this.overlay.init(this),this.handler.init(this)}return tl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Bi,$i(n,"click",this.handler.click),this.options.preloadImage&&Hi(Di(n)));return this}},{key:"config",value:function(n){return n?(rl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var o=this.target.srcOriginal;null!=o&&(this.options.onImageLoading(r),Hi(o,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),$i(document,"scroll",this.handler.scroll),$i(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&$i(window,"resize",this.handler.resizeWindow);var s=function n(){$i(r,Vi,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&al(document,e.handler,!0),t(r)};return $i(r,Vi,s),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Li,this.overlay.fadeOut(),this.target.zoomOut(),$i(document,"scroll",this.handler.scroll,!1),$i(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&$i(window,"resize",this.handler.resizeWindow,!1);var r=function r(){$i(t,Vi,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&al(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return $i(t,Vi,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var o=this.target.el;this.options.onBeforeGrab(o),this.released=!1,this.target.grab(n,e,t);var s=function n(){$i(o,Vi,n,!1),r(o)};return $i(o,Vi,s),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ui,this.target.move(n,e,t);var o=this.target.el,s=function n(){$i(o,Vi,n,!1),r(o)};return $i(o,Vi,s),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Li,this.target.restoreOpenStyle();var r=function r(){$i(t,Vi,r,!1),n.lock=!1,n.released=!0,e(t)};return $i(t,Vi,r),this}}}]),n}();const ll=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),cl=Number("500");class pl{constructor(){this.instance=new il(ll)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=cl){setTimeout(()=>this.update(n),e)}}var ul=[di,vi,ki,Si,Oi,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new pl,this.$vuepress.zooming.updateDelay()}}],dl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ii("layout",n),Ht.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},fl=t(6),hl=Object(fl.a)(dl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(hl,"mixins",ul);const ml=[{name:"v-79fe969c",path:"/pages/1.5.x/intro/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-79fe969c").then(t)}},{path:"/pages/1.5.x/intro/index.html",redirect:"/pages/1.5.x/intro/"},{path:"/001.v1.5.x文档/010.序言/001.intro.html",redirect:"/pages/1.5.x/intro/"},{name:"v-08a9f753",path:"/pages/1.5.x/install_guide/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-08a9f753").then(t)}},{path:"/pages/1.5.x/install_guide/index.html",redirect:"/pages/1.5.x/install_guide/"},{path:"/001.v1.5.x文档/020.入门/001.install_guide.html",redirect:"/pages/1.5.x/install_guide/"},{name:"v-734a25f4",path:"/pages/1.5.x/docs/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-734a25f4").then(t)}},{path:"/pages/1.5.x/docs/index.html",redirect:"/pages/1.5.x/docs/"},{path:"/001.v1.5.x文档/010.序言/002.docs.html",redirect:"/pages/1.5.x/docs/"},{name:"v-5c0174b0",path:"/pages/1.5.x/author/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-5c0174b0").then(t)}},{path:"/pages/1.5.x/author/index.html",redirect:"/pages/1.5.x/author/"},{path:"/001.v1.5.x文档/010.序言/003.author.html",redirect:"/pages/1.5.x/author/"},{name:"v-424e5bd0",path:"/pages/1.5.x/contributors/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-424e5bd0").then(t)}},{path:"/pages/1.5.x/contributors/index.html",redirect:"/pages/1.5.x/contributors/"},{path:"/001.v1.5.x文档/010.序言/004.contributors.html",redirect:"/pages/1.5.x/contributors/"},{name:"v-0d22f8f3",path:"/pages/1.5.x/spring_boot_install/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-0d22f8f3").then(t)}},{path:"/pages/1.5.x/spring_boot_install/index.html",redirect:"/pages/1.5.x/spring_boot_install/"},{path:"/001.v1.5.x文档/020.入门/002.spring_boot_install.html",redirect:"/pages/1.5.x/spring_boot_install/"},{name:"v-439422c9",path:"/pages/1.5.x/spring_boot_config/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-439422c9").then(t)}},{path:"/pages/1.5.x/spring_boot_config/index.html",redirect:"/pages/1.5.x/spring_boot_config/"},{path:"/001.v1.5.x文档/020.入门/003.spring_boot_config.html",redirect:"/pages/1.5.x/spring_boot_config/"},{name:"v-9d6b1a9a",path:"/pages/1.5.x/spring_boot_usage/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-9d6b1a9a").then(t)}},{path:"/pages/1.5.x/spring_boot_usage/index.html",redirect:"/pages/1.5.x/spring_boot_usage/"},{path:"/001.v1.5.x文档/020.入门/004.spring_boot_usage.html",redirect:"/pages/1.5.x/spring_boot_usage/"},{name:"v-47f8bcf5",path:"/pages/1.5.x/spring_install/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-47f8bcf5").then(t)}},{path:"/pages/1.5.x/spring_install/index.html",redirect:"/pages/1.5.x/spring_install/"},{path:"/001.v1.5.x文档/020.入门/005.spring_install.html",redirect:"/pages/1.5.x/spring_install/"},{name:"v-dfc6439a",path:"/pages/1.5.x/spring_config/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-dfc6439a").then(t)}},{path:"/pages/1.5.x/spring_config/index.html",redirect:"/pages/1.5.x/spring_config/"},{path:"/001.v1.5.x文档/020.入门/006.spring_config.html",redirect:"/pages/1.5.x/spring_config/"},{name:"v-90253aa6",path:"/pages/1.5.x/spring_usage/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-90253aa6").then(t)}},{path:"/pages/1.5.x/spring_usage/index.html",redirect:"/pages/1.5.x/spring_usage/"},{path:"/001.v1.5.x文档/020.入门/007.spring_usage.html",redirect:"/pages/1.5.x/spring_usage/"},{name:"v-a477f05e",path:"/pages/1.5.x/java_install/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-a477f05e").then(t)}},{path:"/pages/1.5.x/java_install/index.html",redirect:"/pages/1.5.x/java_install/"},{path:"/001.v1.5.x文档/020.入门/008.java_install.html",redirect:"/pages/1.5.x/java_install/"},{name:"v-0859f29a",path:"/pages/1.5.x/java_config/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-0859f29a").then(t)}},{path:"/pages/1.5.x/java_config/index.html",redirect:"/pages/1.5.x/java_config/"},{path:"/001.v1.5.x文档/020.入门/009.java_config.html",redirect:"/pages/1.5.x/java_config/"},{name:"v-4e19ff1a",path:"/pages/1.5.x/java_usage/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-4e19ff1a").then(t)}},{path:"/pages/1.5.x/java_usage/index.html",redirect:"/pages/1.5.x/java_usage/"},{path:"/001.v1.5.x文档/020.入门/010.java_usage.html",redirect:"/pages/1.5.x/java_usage/"},{name:"v-42c56ef3",path:"/pages/1.5.x/param_api/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-42c56ef3").then(t)}},{path:"/pages/1.5.x/param_api/index.html",redirect:"/pages/1.5.x/param_api/"},{path:"/001.v1.5.x文档/020.入门/011.param_api.html",redirect:"/pages/1.5.x/param_api/"},{name:"v-27e9a7a7",path:"/pages/1.5.x/spring_boot_config_items/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-27e9a7a7").then(t)}},{path:"/pages/1.5.x/spring_boot_config_items/index.html",redirect:"/pages/1.5.x/spring_boot_config_items/"},{path:"/001.v1.5.x文档/030.配置项/001.spring_boot_config_items.html",redirect:"/pages/1.5.x/spring_boot_config_items/"},{name:"v-356ce46f",path:"/pages/1.5.x/spring_config_items/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-356ce46f").then(t)}},{path:"/pages/1.5.x/spring_config_items/index.html",redirect:"/pages/1.5.x/spring_config_items/"},{path:"/001.v1.5.x文档/030.配置项/002.spring_config_items.html",redirect:"/pages/1.5.x/spring_config_items/"},{name:"v-72d1cb9a",path:"/pages/1.5.x/build_interface/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-72d1cb9a").then(t)}},{path:"/pages/1.5.x/build_interface/index.html",redirect:"/pages/1.5.x/build_interface/"},{path:"/001.v1.5.x文档/040.声明式接口/001.build_interface.html",redirect:"/pages/1.5.x/build_interface/"},{name:"v-b12b9d52",path:"/pages/1.5.x/java_config_items/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-b12b9d52").then(t)}},{path:"/pages/1.5.x/java_config_items/index.html",redirect:"/pages/1.5.x/java_config_items/"},{path:"/001.v1.5.x文档/030.配置项/003.java_config_items.html",redirect:"/pages/1.5.x/java_config_items/"},{name:"v-10f1c410",path:"/pages/1.5.x/http_method/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-10f1c410").then(t)}},{path:"/pages/1.5.x/http_method/index.html",redirect:"/pages/1.5.x/http_method/"},{path:"/001.v1.5.x文档/040.声明式接口/002.http_method.html",redirect:"/pages/1.5.x/http_method/"},{name:"v-75bc8ce7",path:"/pages/1.5.x/config_level/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-75bc8ce7").then(t)}},{path:"/pages/1.5.x/config_level/index.html",redirect:"/pages/1.5.x/config_level/"},{path:"/001.v1.5.x文档/030.配置项/004.config_level.html",redirect:"/pages/1.5.x/config_level/"},{name:"v-3f6f28e8",path:"/pages/1.5.x/http_url/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3f6f28e8").then(t)}},{path:"/pages/1.5.x/http_url/index.html",redirect:"/pages/1.5.x/http_url/"},{path:"/001.v1.5.x文档/040.声明式接口/003.http_url.html",redirect:"/pages/1.5.x/http_url/"},{name:"v-304de9cc",path:"/pages/http_query/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-304de9cc").then(t)}},{path:"/pages/http_query/index.html",redirect:"/pages/http_query/"},{path:"/001.v1.5.x文档/040.声明式接口/004.http_query.html",redirect:"/pages/http_query/"},{name:"v-67914a1a",path:"/pages/1.5.x/http_header/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-67914a1a").then(t)}},{path:"/pages/1.5.x/http_header/index.html",redirect:"/pages/1.5.x/http_header/"},{path:"/001.v1.5.x文档/040.声明式接口/005.http_header.html",redirect:"/pages/1.5.x/http_header/"},{name:"v-87ea91a4",path:"/pages/1.5.x/http_body/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-87ea91a4").then(t)}},{path:"/pages/1.5.x/http_body/index.html",redirect:"/pages/1.5.x/http_body/"},{path:"/001.v1.5.x文档/040.声明式接口/006.http_body.html",redirect:"/pages/1.5.x/http_body/"},{name:"v-56e3e48c",path:"/pages/1.5.x/base_request/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-56e3e48c").then(t)}},{path:"/pages/1.5.x/base_request/index.html",redirect:"/pages/1.5.x/base_request/"},{path:"/001.v1.5.x文档/040.声明式接口/008.base_request.html",redirect:"/pages/1.5.x/base_request/"},{name:"v-2932182e",path:"/pages/1.5.x/converter/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-2932182e").then(t)}},{path:"/pages/1.5.x/converter/index.html",redirect:"/pages/1.5.x/converter/"},{path:"/001.v1.5.x文档/040.声明式接口/010.converter.html",redirect:"/pages/1.5.x/converter/"},{name:"v-5954d9e8",path:"/pages/1.5.x/receive_data/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-5954d9e8").then(t)}},{path:"/pages/1.5.x/receive_data/index.html",redirect:"/pages/1.5.x/receive_data/"},{path:"/001.v1.5.x文档/040.声明式接口/009.receive_data.html",redirect:"/pages/1.5.x/receive_data/"},{name:"v-a1d890b4",path:"/pages/1.5.x/success/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-a1d890b4").then(t)}},{path:"/pages/1.5.x/success/index.html",redirect:"/pages/1.5.x/success/"},{path:"/001.v1.5.x文档/040.声明式接口/011.success.html",redirect:"/pages/1.5.x/success/"},{name:"v-207735cc",path:"/pages/1.5.x/retry/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-207735cc").then(t)}},{path:"/pages/1.5.x/retry/index.html",redirect:"/pages/1.5.x/retry/"},{path:"/001.v1.5.x文档/040.声明式接口/012.retry.html",redirect:"/pages/1.5.x/retry/"},{name:"v-3995ef50",path:"/pages/1.5.x/redirection/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3995ef50").then(t)}},{path:"/pages/1.5.x/redirection/index.html",redirect:"/pages/1.5.x/redirection/"},{path:"/001.v1.5.x文档/040.声明式接口/013.redirection.html",redirect:"/pages/1.5.x/redirection/"},{name:"v-1eee5f6c",path:"/pages/1.5.x/decompress/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-1eee5f6c").then(t)}},{path:"/pages/1.5.x/decompress/index.html",redirect:"/pages/1.5.x/decompress/"},{path:"/001.v1.5.x文档/040.声明式接口/014.decompress.html",redirect:"/pages/1.5.x/decompress/"},{name:"v-7f8efa68",path:"/pages/1.5.x/logs/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-7f8efa68").then(t)}},{path:"/pages/1.5.x/logs/index.html",redirect:"/pages/1.5.x/logs/"},{path:"/001.v1.5.x文档/040.声明式接口/015.logs.html",redirect:"/pages/1.5.x/logs/"},{name:"v-3bb81cec",path:"/pages/1.5.x/callback/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3bb81cec").then(t)}},{path:"/pages/1.5.x/callback/index.html",redirect:"/pages/1.5.x/callback/"},{path:"/001.v1.5.x文档/040.声明式接口/016.callback.html",redirect:"/pages/1.5.x/callback/"},{name:"v-6885eba8",path:"/pages/1.5.x/async/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-6885eba8").then(t)}},{path:"/pages/1.5.x/async/index.html",redirect:"/pages/1.5.x/async/"},{path:"/001.v1.5.x文档/040.声明式接口/017.async.html",redirect:"/pages/1.5.x/async/"},{name:"v-42e16c48",path:"/pages/1.5.x/https/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-42e16c48").then(t)}},{path:"/pages/1.5.x/https/index.html",redirect:"/pages/1.5.x/https/"},{path:"/001.v1.5.x文档/040.声明式接口/018.https.html",redirect:"/pages/1.5.x/https/"},{name:"v-66f72f14",path:"/pages/1.5.x/proxy/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-66f72f14").then(t)}},{path:"/pages/1.5.x/proxy/index.html",redirect:"/pages/1.5.x/proxy/"},{path:"/001.v1.5.x文档/040.声明式接口/020.proxy.html",redirect:"/pages/1.5.x/proxy/"},{name:"v-8652de94",path:"/pages/1.5.x/backend/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-8652de94").then(t)}},{path:"/pages/1.5.x/backend/index.html",redirect:"/pages/1.5.x/backend/"},{path:"/001.v1.5.x文档/040.声明式接口/007.backend.html",redirect:"/pages/1.5.x/backend/"},{name:"v-4d0b84ec",path:"/pages/1.5.x/cookie/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-4d0b84ec").then(t)}},{path:"/pages/1.5.x/cookie/index.html",redirect:"/pages/1.5.x/cookie/"},{path:"/001.v1.5.x文档/040.声明式接口/019.cookie.html",redirect:"/pages/1.5.x/cookie/"},{name:"v-934bcb3c",path:"/pages/1.5.x/upload_download/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-934bcb3c").then(t)}},{path:"/pages/1.5.x/upload_download/index.html",redirect:"/pages/1.5.x/upload_download/"},{path:"/001.v1.5.x文档/040.声明式接口/021.upload_download.html",redirect:"/pages/1.5.x/upload_download/"},{name:"v-d3a37f44",path:"/pages/1.5.x/api_forest_request/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-d3a37f44").then(t)}},{path:"/pages/1.5.x/api_forest_request/index.html",redirect:"/pages/1.5.x/api_forest_request/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/001.api_forest_request.html",redirect:"/pages/1.5.x/api_forest_request/"},{name:"v-587b290e",path:"/pages/1.5.x/exception/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-587b290e").then(t)}},{path:"/pages/1.5.x/exception/index.html",redirect:"/pages/1.5.x/exception/"},{path:"/001.v1.5.x文档/040.声明式接口/022.exception.html",redirect:"/pages/1.5.x/exception/"},{name:"v-1f0c5104",path:"/pages/1.5.x/api_request_prop/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-1f0c5104").then(t)}},{path:"/pages/1.5.x/api_request_prop/index.html",redirect:"/pages/1.5.x/api_request_prop/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/002.api_request_properties.html",redirect:"/pages/1.5.x/api_request_prop/"},{name:"v-6c0b53bc",path:"/pages/1.5.x/api_execute/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-6c0b53bc").then(t)}},{path:"/pages/1.5.x/api_execute/index.html",redirect:"/pages/1.5.x/api_execute/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/003.api_execute.html",redirect:"/pages/1.5.x/api_execute/"},{name:"v-3002147e",path:"/pages/1.5.x/api_request_type/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3002147e").then(t)}},{path:"/pages/1.5.x/api_request_type/index.html",redirect:"/pages/1.5.x/api_request_type/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/005.api_request_type.html",redirect:"/pages/1.5.x/api_request_type/"},{name:"v-3ba4607c",path:"/pages/1.5.x/api_backend/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3ba4607c").then(t)}},{path:"/pages/1.5.x/api_backend/index.html",redirect:"/pages/1.5.x/api_backend/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/004.api_backend.html",redirect:"/pages/1.5.x/api_backend/"},{name:"v-56909398",path:"/pages/1.5.x/api_request_address/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-56909398").then(t)}},{path:"/pages/1.5.x/api_request_address/index.html",redirect:"/pages/1.5.x/api_request_address/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/006.api_request_address.html",redirect:"/pages/1.5.x/api_request_address/"},{name:"v-b1ff77a4",path:"/pages/api_request_query/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-b1ff77a4").then(t)}},{path:"/pages/api_request_query/index.html",redirect:"/pages/api_request_query/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/007.api_request_query.html",redirect:"/pages/api_request_query/"},{name:"v-4be650fe",path:"/pages/1.5.x/api_request_header/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-4be650fe").then(t)}},{path:"/pages/1.5.x/api_request_header/index.html",redirect:"/pages/1.5.x/api_request_header/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/008.api_request_header.html",redirect:"/pages/1.5.x/api_request_header/"},{name:"v-24a2f37e",path:"/pages/1.5.x/api_callback/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-24a2f37e").then(t)}},{path:"/pages/1.5.x/api_callback/index.html",redirect:"/pages/1.5.x/api_callback/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/011.api_callback.html",redirect:"/pages/1.5.x/api_callback/"},{name:"v-77bf47fe",path:"/pages/1.5.x/api_request_body/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-77bf47fe").then(t)}},{path:"/pages/1.5.x/api_request_body/index.html",redirect:"/pages/1.5.x/api_request_body/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/009.api_request_body.html",redirect:"/pages/1.5.x/api_request_body/"},{name:"v-bc96cdbc",path:"/pages/1.5.x/api_success/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-bc96cdbc").then(t)}},{path:"/pages/1.5.x/api_success/index.html",redirect:"/pages/1.5.x/api_success/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/013.api_success.html",redirect:"/pages/1.5.x/api_success/"},{name:"v-46b082d4",path:"/pages/1.5.x/api_request_async/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-46b082d4").then(t)}},{path:"/pages/1.5.x/api_request_async/index.html",redirect:"/pages/1.5.x/api_request_async/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/010.api_request_async.html",redirect:"/pages/1.5.x/api_request_async/"},{name:"v-4365e2e8",path:"/pages/1.5.x/api_redirection/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-4365e2e8").then(t)}},{path:"/pages/1.5.x/api_redirection/index.html",redirect:"/pages/1.5.x/api_redirection/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/015.api_redirection.html",redirect:"/pages/1.5.x/api_redirection/"},{name:"v-52dfbad6",path:"/pages/1.5.x/api_retry/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-52dfbad6").then(t)}},{path:"/pages/1.5.x/api_retry/index.html",redirect:"/pages/1.5.x/api_retry/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/014.api_retry.html",redirect:"/pages/1.5.x/api_retry/"},{name:"v-57403bbe",path:"/pages/1.5.x/api_cookie/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-57403bbe").then(t)}},{path:"/pages/1.5.x/api_cookie/index.html",redirect:"/pages/1.5.x/api_cookie/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/012.api_cookie.html",redirect:"/pages/1.5.x/api_cookie/"},{name:"v-0daf3774",path:"/pages/1.5.x/api_proxy/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-0daf3774").then(t)}},{path:"/pages/1.5.x/api_proxy/index.html",redirect:"/pages/1.5.x/api_proxy/"},{path:"/001.v1.5.x文档/050.编程式接口/010.请求API/016.api_proxy.html",redirect:"/pages/1.5.x/api_proxy/"},{name:"v-3a7c0a5a",path:"/pages/1.5.x/api_forest_response/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3a7c0a5a").then(t)}},{path:"/pages/1.5.x/api_forest_response/index.html",redirect:"/pages/1.5.x/api_forest_response/"},{path:"/001.v1.5.x文档/050.编程式接口/020.响应API/001.api_forest_response.html",redirect:"/pages/1.5.x/api_forest_response/"},{name:"v-326ffa2f",path:"/pages/1.5.x/api_response_read/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-326ffa2f").then(t)}},{path:"/pages/1.5.x/api_response_read/index.html",redirect:"/pages/1.5.x/api_response_read/"},{path:"/001.v1.5.x文档/050.编程式接口/020.响应API/002.api_response_read.html",redirect:"/pages/1.5.x/api_response_read/"},{name:"v-b4a40016",path:"/pages/1.5.x/api_response_status/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-b4a40016").then(t)}},{path:"/pages/1.5.x/api_response_status/index.html",redirect:"/pages/1.5.x/api_response_status/"},{path:"/001.v1.5.x文档/050.编程式接口/020.响应API/003.api_response_status.html",redirect:"/pages/1.5.x/api_response_status/"},{name:"v-2022e0ae",path:"/pages/1.5.x/api_response_error/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-2022e0ae").then(t)}},{path:"/pages/1.5.x/api_response_error/index.html",redirect:"/pages/1.5.x/api_response_error/"},{path:"/001.v1.5.x文档/050.编程式接口/020.响应API/004.api_response_error.html",redirect:"/pages/1.5.x/api_response_error/"},{name:"v-6cf70ea9",path:"/pages/1.5.x/api_response_hreader/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-6cf70ea9").then(t)}},{path:"/pages/1.5.x/api_response_hreader/index.html",redirect:"/pages/1.5.x/api_response_hreader/"},{path:"/001.v1.5.x文档/050.编程式接口/020.响应API/005.api_response_hreader.html",redirect:"/pages/1.5.x/api_response_hreader/"},{name:"v-05d82ecb",path:"/pages/1.5.x/api_response_cookie/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-05d82ecb").then(t)}},{path:"/pages/1.5.x/api_response_cookie/index.html",redirect:"/pages/1.5.x/api_response_cookie/"},{path:"/001.v1.5.x文档/050.编程式接口/020.响应API/006.api_response_cookie.html",redirect:"/pages/1.5.x/api_response_cookie/"},{name:"v-e355a5c4",path:"/pages/1.5.x/refer_prop/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-e355a5c4").then(t)}},{path:"/pages/1.5.x/refer_prop/index.html",redirect:"/pages/1.5.x/refer_prop/"},{path:"/001.v1.5.x文档/060.模板表达式/002.refer_prop.html",redirect:"/pages/1.5.x/refer_prop/"},{name:"v-9669bccc",path:"/pages/1.5.x/hello_world/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-9669bccc").then(t)}},{path:"/pages/1.5.x/hello_world/index.html",redirect:"/pages/1.5.x/hello_world/"},{path:"/001.v1.5.x文档/060.模板表达式/001.hello_world.html",redirect:"/pages/1.5.x/hello_world/"},{name:"v-41fb2586",path:"/pages/1.5.x/binding_var/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-41fb2586").then(t)}},{path:"/pages/1.5.x/binding_var/index.html",redirect:"/pages/1.5.x/binding_var/"},{path:"/001.v1.5.x文档/060.模板表达式/003.binding_var.html",redirect:"/pages/1.5.x/binding_var/"},{name:"v-78153190",path:"/pages/1.5.x/refer_index/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-78153190").then(t)}},{path:"/pages/1.5.x/refer_index/index.html",redirect:"/pages/1.5.x/refer_index/"},{path:"/001.v1.5.x文档/060.模板表达式/004.refer_index.html",redirect:"/pages/1.5.x/refer_index/"},{name:"v-5b0d2084",path:"/pages/1.5.x/refer_attr/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-5b0d2084").then(t)}},{path:"/pages/1.5.x/refer_attr/index.html",redirect:"/pages/1.5.x/refer_attr/"},{path:"/001.v1.5.x文档/060.模板表达式/005.refer_attr.html",redirect:"/pages/1.5.x/refer_attr/"},{name:"v-3fd0a948",path:"/pages/1.5.x/refer_var/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-3fd0a948").then(t)}},{path:"/pages/1.5.x/refer_var/index.html",redirect:"/pages/1.5.x/refer_var/"},{path:"/001.v1.5.x文档/060.模板表达式/007.refer_var.html",redirect:"/pages/1.5.x/refer_var/"},{name:"v-0015b6de",path:"/pages/1.5.x/invoke/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-0015b6de").then(t)}},{path:"/pages/1.5.x/invoke/index.html",redirect:"/pages/1.5.x/invoke/"},{path:"/001.v1.5.x文档/060.模板表达式/006.invoke.html",redirect:"/pages/1.5.x/invoke/"},{name:"v-08061b16",path:"/pages/1.5.x/interceptor/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-08061b16").then(t)}},{path:"/pages/1.5.x/interceptor/index.html",redirect:"/pages/1.5.x/interceptor/"},{path:"/001.v1.5.x文档/070.高级特性/001.interceptor.html",redirect:"/pages/1.5.x/interceptor/"},{name:"v-2c782d95",path:"/pages/1.5.x/custom_annotation/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-2c782d95").then(t)}},{path:"/pages/1.5.x/custom_annotation/index.html",redirect:"/pages/1.5.x/custom_annotation/"},{path:"/001.v1.5.x文档/070.高级特性/002.custom_annotation.html",redirect:"/pages/1.5.x/custom_annotation/"},{name:"v-46c27bdf",path:"/archives/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-46c27bdf").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-37b0d296",path:"/pages/1.5.x/makeup_annotation/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-37b0d296").then(t)}},{path:"/pages/1.5.x/makeup_annotation/index.html",redirect:"/pages/1.5.x/makeup_annotation/"},{path:"/001.v1.5.x文档/070.高级特性/003.makeup_annotation.html",redirect:"/pages/1.5.x/makeup_annotation/"},{name:"v-09990286",path:"/pages/custom_converter/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-09990286").then(t)}},{path:"/pages/custom_converter/index.html",redirect:"/pages/custom_converter/"},{path:"/001.v1.5.x文档/070.高级特性/004.custom_converter.html",redirect:"/pages/custom_converter/"},{name:"v-2ae768c1",path:"/pages/contribute/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-2ae768c1").then(t)}},{path:"/pages/contribute/index.html",redirect:"/pages/contribute/"},{path:"/参与贡献.html",redirect:"/pages/contribute/"},{name:"v-d5edb880",path:"/pages/about_author/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-d5edb880").then(t)}},{path:"/pages/about_author/index.html",redirect:"/pages/about_author/"},{path:"/关于作者.html",redirect:"/pages/about_author/"},{name:"v-2ccc5a68",path:"/pages/donate/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-2ccc5a68").then(t)}},{path:"/pages/donate/index.html",redirect:"/pages/donate/"},{path:"/支持.html",redirect:"/pages/donate/"},{name:"v-044a573f",path:"/pages/releases/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-044a573f").then(t)}},{path:"/pages/releases/index.html",redirect:"/pages/releases/"},{path:"/发布记录.html",redirect:"/pages/releases/"},{name:"v-160dfc8b",path:"/",component:hl,beforeEnter:(n,e,t)=>{ai("Layout","v-160dfc8b").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:hl}],gl={title:"Forest",description:"一个轻量，快速，稳定可编排的组件式规则引擎",base:"/",headTags:[["link",{rel:"icon",href:"/img/logo.svg"}],["meta",{name:"keywords",content:"Forest,Forest官网,规则引擎,流程引擎,开源,java规则引擎,rule engine,open source"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"6c4b761a28b734fe93831e3fb400ce87"}],["script",{async:!0,src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}],["script",{},'\n    // 万维广告“禁止”广告拦截\n    // function called if wwads is blocked\n    // https://github.com/bytegravity/whitelist-wwads\n    function ABDetected() {\n      var adBlockDetected_div = document.createElement("div");\n      document.body.appendChild(adBlockDetected_div);\n      var navbar = document.querySelector(".navbar");\n      navbar.style.cssText="transition:top 300ms;top:33px";\n      adBlockDetected_div.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; background: #4aa962; color: #fff; z-index: 9999999999; font-size: 14px; text-align: center; line-height: 1.5; font-weight: bold; padding-top: 6px; padding-bottom: 6px;";\n      adBlockDetected_div.innerHTML = "我们的广告服务商 <a style=\'color:#fff;text-decoration:underline\' target=\'_blank\' href=\'https://wwads.cn/page/end-user-privacy\'>并不跟踪您的隐私</a>，为了支持本站的长期运营，请将我们的网站 <a style=\'color: #fff;text-decoration:underline\' target=\'_blank\' href=\'https://wwads.cn/page/whitelist-wwads\'>加入广告拦截器的白名单</a>。";\n      document.getElementsByTagName("body")[0].appendChild(adBlockDetected_div);\n      // add a close button to the right side of the div\n      var adBlockDetected_close = document.createElement("div");\n      adBlockDetected_close.style.cssText = "position: absolute; top: 0; right: 10px; width: 30px; height: 30px; background: #4aa962; color: #fff; z-index: 9999999999; line-height: 30px; cursor: pointer;";\n      adBlockDetected_close.innerHTML = "×";\n      adBlockDetected_div.appendChild(adBlockDetected_close);\n      // add a click event to the close button\n      adBlockDetected_close.onclick = function() {\n      this.parentNode.parentNode.removeChild(this.parentNode);\n      navbar.style.cssText="transition:top 300ms;top:0";\n      };\n    }\n\n    function vote() {\n      var voteDetected_div = document.createElement("div");\n      voteDetected_div.style.cssText = "position: absolute; top: 0; left: 0; width: 100%; background: #7bbfea; color: #fff; z-index: 9999999999; font-size: 14px; text-align: center; line-height: 1.5; font-weight: bold; padding-top: 6px; padding-bottom: 6px;";\n      voteDetected_div.innerHTML = "<a style=\'color:#fff;text-decoration:underline\' target=\'_blank\' href=\'xxxxxx\'>LiteFlow 正在参与“2021年度 OSC 中国开源项目”评选，请为我们投上宝贵的一票，谢谢！</a>";\n      document.getElementsByTagName("body")[0].appendChild(voteDetected_div);\n      voteDetected_div.onclick = function() {\n        this.remove();\n      };\n    }\n\n    function docReady(t) {\n      "complete" === document.readyState ||\n      "interactive" === document.readyState\n        ? setTimeout(t, 1)\n        : document.addEventListener("DOMContentLoaded", t);\n    }\n\n    //check if wwads\' fire function was blocked after document is ready with 3s timeout (waiting the ad loading)\n    docReady(function () {\n      setTimeout(function () {\n        if( window._AdBlockInit === undefined ){\n            ABDetected();\n        }\n      }, 3000);\n    });\n  ']],pages:[{title:"🎁 新手介绍",frontmatter:{id:"intro",title:"🎁 新手介绍",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/intro/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/010.%E5%BA%8F%E8%A8%80/001.intro.html",relativePath:"001.v1.5.x文档/010.序言/001.intro.md",key:"v-79fe969c",path:"/pages/1.5.x/intro/",headers:[{level:2,title:"什么是 Forest？",slug:"什么是-forest",normalizedTitle:"什么是 forest？",charIndex:2},{level:2,title:"为什么使用 Forest?",slug:"为什么使用-forest",normalizedTitle:"为什么使用 forest?",charIndex:143},{level:2,title:"Forest 如何使用?",slug:"forest-如何使用",normalizedTitle:"forest 如何使用?",charIndex:351},{level:2,title:"Forest 的工作原理",slug:"forest-的工作原理",normalizedTitle:"forest 的工作原理",charIndex:478},{level:2,title:"Forest 的架构",slug:"forest-的架构",normalizedTitle:"forest 的架构",charIndex:691},{level:2,title:"所需环境",slug:"所需环境",normalizedTitle:"所需环境",charIndex:1349},{level:2,title:"名字由来",slug:"名字由来",normalizedTitle:"名字由来",charIndex:1366}],headersStr:"什么是 Forest？ 为什么使用 Forest? Forest 如何使用? Forest 的工作原理 Forest 的架构 所需环境 名字由来",content:"# 什么是 Forest？\n\nForest 是一个开源的 Java HTTP 客户端框架，它能够将 HTTP 的所有请求信息（包括 URL、Header 以及 Body 等信息）绑定到您自定义的 Interface 方法上，能够通过调用本地接口方法的方式发送 HTTP 请求。\n\n\n# 为什么使用 Forest?\n\n使用 Forest 就像使用类似 Dubbo 那样的 RPC 框架一样，只需要定义接口，调用接口即可，不必关心具体发送 HTTP 请求的细节。同时将 HTTP 请求信息与业务代码解耦，方便您统一管理大量 HTTP 的 URL、Header 等信息。而请求的调用方完全不必在意 HTTP 的具体内容，即使该 HTTP 请求信息发生变更，大多数情况也不需要修改调用发送请求的代码。\n\n\n# Forest 如何使用?\n\nForest 不需要您编写具体的 HTTP 调用过程，只需要您定义一个接口，然后通过 Forest 注解将 HTTP 请求的信息添加到接口的方法上即可。请求发送方通过调用您定义的接口便能自动发送请求和接受请求的响应。\n\n\n# Forest 的工作原理\n\nForest 会将您定义好的接口通过动态代理的方式生成一个具体的实现类，然后组织、验证 HTTP 请求信息，绑定动态数据，转换数据形式，SSL 验证签名，调用后端 HTTP API(httpclient 等 API)执行实际请求，等待响应，失败重试，转换响应数据到 Java 类型等脏活累活都由这动态代理的实现类给包了。 请求发送方调用这个接口时，实际上就是在调用这个干脏活累活的实现类。\n\n\n# Forest 的架构\n\n我们讲 HTTP 发送请求的过程分为前端部分和后端部分，Forest 本身是处理前端过程的框架，是对后端 HTTP API 框架的进一步封装。\n\n前端部分：\n\n 1. Forest 配置： 负责管理 HTTP 发送请求所需的配置。\n 2. Forest 注解： 用于定义 HTTP 发送请求的所有相关信息，一般定义在 interface 上和其方法上。\n 3. 动态代理： 用户定义好的 HTTP 请求的interface将通过动态代理产生实际执行发送请求过程的代理类。\n 4. 模板表达式： 模板表达式可以嵌入在几乎所有的 HTTP 请求参数定义中，它能够将用户通过参数或全局变量传入的数据动态绑定到 HTTP 请求信息中。\n 5. 数据转换： 此模块将字符串数据和JSON或XML形式数据进行互转。目前 JSON 转换器支持Jackson、Fastjson、Gson三种，XML 支持JAXB一种。\n 6. 拦截器： 用户可以自定义拦截器，拦截指定的一个或一批请求的开始、成功返回数据、失败、完成等生命周期中的各个环节，以插入自定义的逻辑进行处理。\n 7. 过滤器： 用于动态过滤和处理传入 HTTP 请求的相关数据。\n 8. SSL： Forest 支持单向和双向验证的 HTTPS 请求，此模块用于处理 SSL 相关协议的内容。\n\n后端部分：\n\n后端为实际执行 HTTP 请求发送过程的第三方 HTTP API，目前支持okHttp3和httpclient两种后端 API。\n\n\n# 所需环境\n\nJDK 8+\n\n\n# 名字由来\n\nForest就字面意思而言，就是森林的意思。但仔细看可以拆成For和Rest两个单词，也就是“为了Rest”（Rest为一种基于HTTP的架构风格）。 而合起来就是森林，森林由很多树木花草组成（可以理解为各种不同的服务），它们表面上看独立，实则在地下根茎交错纵横、相互连接依存，这样看就有点现代分布式服务化的味道了。 最后，这两个单词反过来读就像是Resultful。",normalizedContent:"# 什么是 forest？\n\nforest 是一个开源的 java http 客户端框架，它能够将 http 的所有请求信息（包括 url、header 以及 body 等信息）绑定到您自定义的 interface 方法上，能够通过调用本地接口方法的方式发送 http 请求。\n\n\n# 为什么使用 forest?\n\n使用 forest 就像使用类似 dubbo 那样的 rpc 框架一样，只需要定义接口，调用接口即可，不必关心具体发送 http 请求的细节。同时将 http 请求信息与业务代码解耦，方便您统一管理大量 http 的 url、header 等信息。而请求的调用方完全不必在意 http 的具体内容，即使该 http 请求信息发生变更，大多数情况也不需要修改调用发送请求的代码。\n\n\n# forest 如何使用?\n\nforest 不需要您编写具体的 http 调用过程，只需要您定义一个接口，然后通过 forest 注解将 http 请求的信息添加到接口的方法上即可。请求发送方通过调用您定义的接口便能自动发送请求和接受请求的响应。\n\n\n# forest 的工作原理\n\nforest 会将您定义好的接口通过动态代理的方式生成一个具体的实现类，然后组织、验证 http 请求信息，绑定动态数据，转换数据形式，ssl 验证签名，调用后端 http api(httpclient 等 api)执行实际请求，等待响应，失败重试，转换响应数据到 java 类型等脏活累活都由这动态代理的实现类给包了。 请求发送方调用这个接口时，实际上就是在调用这个干脏活累活的实现类。\n\n\n# forest 的架构\n\n我们讲 http 发送请求的过程分为前端部分和后端部分，forest 本身是处理前端过程的框架，是对后端 http api 框架的进一步封装。\n\n前端部分：\n\n 1. forest 配置： 负责管理 http 发送请求所需的配置。\n 2. forest 注解： 用于定义 http 发送请求的所有相关信息，一般定义在 interface 上和其方法上。\n 3. 动态代理： 用户定义好的 http 请求的interface将通过动态代理产生实际执行发送请求过程的代理类。\n 4. 模板表达式： 模板表达式可以嵌入在几乎所有的 http 请求参数定义中，它能够将用户通过参数或全局变量传入的数据动态绑定到 http 请求信息中。\n 5. 数据转换： 此模块将字符串数据和json或xml形式数据进行互转。目前 json 转换器支持jackson、fastjson、gson三种，xml 支持jaxb一种。\n 6. 拦截器： 用户可以自定义拦截器，拦截指定的一个或一批请求的开始、成功返回数据、失败、完成等生命周期中的各个环节，以插入自定义的逻辑进行处理。\n 7. 过滤器： 用于动态过滤和处理传入 http 请求的相关数据。\n 8. ssl： forest 支持单向和双向验证的 https 请求，此模块用于处理 ssl 相关协议的内容。\n\n后端部分：\n\n后端为实际执行 http 请求发送过程的第三方 http api，目前支持okhttp3和httpclient两种后端 api。\n\n\n# 所需环境\n\njdk 8+\n\n\n# 名字由来\n\nforest就字面意思而言，就是森林的意思。但仔细看可以拆成for和rest两个单词，也就是“为了rest”（rest为一种基于http的架构风格）。 而合起来就是森林，森林由很多树木花草组成（可以理解为各种不同的服务），它们表面上看独立，实则在地下根茎交错纵横、相互连接依存，这样看就有点现代分布式服务化的味道了。 最后，这两个单词反过来读就像是resultful。",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎬 安装配置说明",frontmatter:{id:"install_guide",title:"🎬 安装配置说明",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/install_guide/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/001.install_guide.html",relativePath:"001.v1.5.x文档/020.入门/001.install_guide.md",key:"v-08a9f753",path:"/pages/1.5.x/install_guide/",headers:[{level:2,title:"如何安装",slug:"如何安装",normalizedTitle:"如何安装",charIndex:2},{level:2,title:"如何配置",slug:"如何配置",normalizedTitle:"如何配置",charIndex:143},{level:2,title:"如何运行",slug:"如何运行",normalizedTitle:"如何运行",charIndex:284}],headersStr:"如何安装 如何配置 如何运行",content:"# 如何安装\n\nForest 可适配集成 Springboot、Spring 等多种不同的项目环境，也可直接在普通的 Java 项目中使用\n\n可以根据项目需要，选择不同的环境进行安装\n\n * Springboot环境安装\n * Spring环境安装\n * 原生Java环境安装\n\n\n# 如何配置\n\nForest 遵循约定大于配置的理念，大多数情况下不需要进行配置，或填写非常简单的配置即可\n\n但不同项目环境配置方式各有不同，需要根据项目需要，选择不同的环境进行配置\n\n * Springboot环境配置\n * Spring环境配置\n * 原生Java环境配置\n\n\n# 如何运行\n\nForest 提供两种开发运行模式：声明式和编程式\n\n声明式需要定义Java接口，以及请求对应的接口方法，这样会有一个非常清晰的网络接口结构，十分有利于API管理\n\n声明式的模式在不同项目环境中也有所不同，需要根据项目需要，选择不同的方式进行开发\n\n * Springboot环境运行\n * Spring环境运行\n * 原生Java环境运行\n\nForest也提供了快捷的编程式接口，以满足非声明式的开发模式\n\n编程式接口短小精悍，快速便捷，十分有利于开发那些数量少、或大量参数（如URL）不固定的API\n\n * 编程式接口",normalizedContent:"# 如何安装\n\nforest 可适配集成 springboot、spring 等多种不同的项目环境，也可直接在普通的 java 项目中使用\n\n可以根据项目需要，选择不同的环境进行安装\n\n * springboot环境安装\n * spring环境安装\n * 原生java环境安装\n\n\n# 如何配置\n\nforest 遵循约定大于配置的理念，大多数情况下不需要进行配置，或填写非常简单的配置即可\n\n但不同项目环境配置方式各有不同，需要根据项目需要，选择不同的环境进行配置\n\n * springboot环境配置\n * spring环境配置\n * 原生java环境配置\n\n\n# 如何运行\n\nforest 提供两种开发运行模式：声明式和编程式\n\n声明式需要定义java接口，以及请求对应的接口方法，这样会有一个非常清晰的网络接口结构，十分有利于api管理\n\n声明式的模式在不同项目环境中也有所不同，需要根据项目需要，选择不同的方式进行开发\n\n * springboot环境运行\n * spring环境运行\n * 原生java环境运行\n\nforest也提供了快捷的编程式接口，以满足非声明式的开发模式\n\n编程式接口短小精悍，快速便捷，十分有利于开发那些数量少、或大量参数（如url）不固定的api\n\n * 编程式接口",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"📖 文档",frontmatter:{id:"docs",title:"📖 文档",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/docs/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/010.%E5%BA%8F%E8%A8%80/002.docs.html",relativePath:"001.v1.5.x文档/010.序言/002.docs.md",key:"v-734a25f4",path:"/pages/1.5.x/docs/",headers:[{level:2,title:"相关文档",slug:"相关文档",normalizedTitle:"相关文档",charIndex:2}],headersStr:"相关文档",content:"# 相关文档\n\n中文文档\n\nJavaDoc\n\nDemo工程",normalizedContent:"# 相关文档\n\n中文文档\n\njavadoc\n\ndemo工程",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🕵️‍ 联系作者",frontmatter:{id:"author",title:"🕵️‍ 联系作者",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/author/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/010.%E5%BA%8F%E8%A8%80/003.author.html",relativePath:"001.v1.5.x文档/010.序言/003.author.md",key:"v-5c0174b0",path:"/pages/1.5.x/author/",headers:[{level:2,title:"扫码加群",slug:"扫码加群",normalizedTitle:"扫码加群",charIndex:2}],headersStr:"扫码加群",content:"# 扫码加群\n\n您如有问题可以扫码加入微信的技术交流群\n\n扫描二维码关注公众号，点击菜单中的 进群 按钮即可进群\n\n",normalizedContent:"# 扫码加群\n\n您如有问题可以扫码加入微信的技术交流群\n\n扫描二维码关注公众号，点击菜单中的 进群 按钮即可进群\n\n",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"👨‍🎓 贡献者列表",frontmatter:{id:"contributors",title:"👨‍🎓 贡献者列表",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/contributors/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/010.%E5%BA%8F%E8%A8%80/004.contributors.html",relativePath:"001.v1.5.x文档/010.序言/004.contributors.md",key:"v-424e5bd0",path:"/pages/1.5.x/contributors/",headers:[{level:2,title:"框架贡献者",slug:"框架贡献者",normalizedTitle:"框架贡献者",charIndex:2},{level:4,title:"正因为有他们的贡献，Forest才得以走下去（排名不分先后）",slug:"正因为有他们的贡献-forest才得以走下去-排名不分先后",normalizedTitle:"正因为有他们的贡献，forest才得以走下去（排名不分先后）",charIndex:11}],headersStr:"框架贡献者 正因为有他们的贡献，Forest才得以走下去（排名不分先后）",content:"# 框架贡献者\n\n# 正因为有他们的贡献，Forest才得以走下去（排名不分先后）\n\n   ID             主页\n   公子骏            https://gitee.com/dt_flys\n   侯坤林            https://gitee.com/houkunlin\n   CHMing         https://gitee.com/CHMing7\n   fangzhengjin   https://gitee.com/fangzhengjin\n   yakax          https://gitee.com/yakax\n   designer       https://gitee.com/g-dream.\n   Bythere        https://gitee.com/WanderingAnt\n   柚子             https://gitee.com/youzz\n   leesonwei      https://gitee.com/github-29350722\n   bryan31        https://gitee.com/bryan31",normalizedContent:"# 框架贡献者\n\n# 正因为有他们的贡献，forest才得以走下去（排名不分先后）\n\n   id             主页\n   公子骏            https://gitee.com/dt_flys\n   侯坤林            https://gitee.com/houkunlin\n   chming         https://gitee.com/chming7\n   fangzhengjin   https://gitee.com/fangzhengjin\n   yakax          https://gitee.com/yakax\n   designer       https://gitee.com/g-dream.\n   bythere        https://gitee.com/wanderingant\n   柚子             https://gitee.com/youzz\n   leesonwei      https://gitee.com/github-29350722\n   bryan31        https://gitee.com/bryan31",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🏹 Springboot环境安装",frontmatter:{id:"spring_boot_install",title:"🏹 Springboot环境安装",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_boot_install/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/002.spring_boot_install.html",relativePath:"001.v1.5.x文档/020.入门/002.spring_boot_install.md",key:"v-0d22f8f3",path:"/pages/1.5.x/spring_boot_install/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"JSON框架依赖",slug:"json框架依赖",normalizedTitle:"json框架依赖",charIndex:332},{level:2,title:"Protobuf框架依赖",slug:"protobuf框架依赖",normalizedTitle:"protobuf框架依赖",charIndex:639}],headersStr:"依赖 JSON框架依赖 Protobuf框架依赖",content:"# 依赖\n\n对于 Springboot 项目来说， 只需要添加 forest-spring-boot-starter 依赖即可\n\n<dependency>\n    <groupId>com.dtflys.forest</groupId>\n    <artifactId>forest-spring-boot-starter</artifactId>\n    <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.dtflys.forest', name: 'forest-spring-boot-starter', version: '1.5.24'\n\n\n1\n\n\n\n# JSON框架依赖\n\nSpringboot 已自带 Jackson 框架依赖，如需要 Fastjson，请添加以下依赖。否则可以跳过此步\n\nFastjson依赖：版本 >= 1.2.48\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>fastjson</artifactId>\n  <version>1.2.73</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.alibaba', name: 'fastjson', version: '1.2.73'\n\n\n1\n\n\n\n# Protobuf框架依赖\n\n如果您的项目需要使用 Protobuf, 就需要引入 Google 的 Protobuf 包依赖\n\n若是已经引入了 forest-spring-boot-starter 启动包，就不用再引入该依赖了，因为在 Forest 的启动包中已经传递依赖此包\n\n版本 >= 3.14.0\n\n<dependency>\n  <groupId>com.google.protobuf</groupId>\n  <artifactId>protobuf-java</artifactId>\n  <version>3.18.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.18.1'\n\n\n1\n",normalizedContent:"# 依赖\n\n对于 springboot 项目来说， 只需要添加 forest-spring-boot-starter 依赖即可\n\n<dependency>\n    <groupid>com.dtflys.forest</groupid>\n    <artifactid>forest-spring-boot-starter</artifactid>\n    <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.dtflys.forest', name: 'forest-spring-boot-starter', version: '1.5.24'\n\n\n1\n\n\n\n# json框架依赖\n\nspringboot 已自带 jackson 框架依赖，如需要 fastjson，请添加以下依赖。否则可以跳过此步\n\nfastjson依赖：版本 >= 1.2.48\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>fastjson</artifactid>\n  <version>1.2.73</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.alibaba', name: 'fastjson', version: '1.2.73'\n\n\n1\n\n\n\n# protobuf框架依赖\n\n如果您的项目需要使用 protobuf, 就需要引入 google 的 protobuf 包依赖\n\n若是已经引入了 forest-spring-boot-starter 启动包，就不用再引入该依赖了，因为在 forest 的启动包中已经传递依赖此包\n\n版本 >= 3.14.0\n\n<dependency>\n  <groupid>com.google.protobuf</groupid>\n  <artifactid>protobuf-java</artifactid>\n  <version>3.18.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.18.1'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"📐 Springboot环境配置",frontmatter:{id:"spring_boot_config",title:"📐 Springboot环境配置",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_boot_config/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/003.spring_boot_config.html",relativePath:"001.v1.5.x文档/020.入门/003.spring_boot_config.md",key:"v-439422c9",path:"/pages/1.5.x/spring_boot_config/",headers:[{level:3,title:"约定大于配置",slug:"约定大于配置",normalizedTitle:"约定大于配置",charIndex:2},{level:3,title:"简单配置",slug:"简单配置",normalizedTitle:"简单配置",charIndex:134},{level:3,title:"详细配置",slug:"详细配置",normalizedTitle:"详细配置",charIndex:497}],headersStr:"约定大于配置 简单配置 详细配置",content:"# 约定大于配置\n\nForest是基于约定大于配置的理念进行设计的，如果您已经添加好了forest-spring-boot-starter依赖，基本上可以什么都不配置，可直接跳转到《Springboot环境运行》学习如何上手使用\n\n当然也可以进行些简单的配置\n\n\n# 简单配置\n\n在application.yaml / application.properties中配置的 HTTP 基本参数\n\nforest:\n  max-connections: 1000        # 连接池最大连接数\n  connect-timeout: 3000        # 连接超时时间，单位为毫秒\n  read-timeout: 3000           # 数据读取超时时间，单位为毫秒\n\n\n1\n2\n3\n4\n\n\n# 连接池最大连接数\nforest.max-connections=1000\n# 连接超时时间，单位为毫秒\nforest.connect-timeout=3000\n# 数据读取超时时间，单位为毫秒\nforest.read-timeout=3000\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 详细配置\n\nForest的详细配置说明，请参见《Springboot环境配置项》",normalizedContent:"# 约定大于配置\n\nforest是基于约定大于配置的理念进行设计的，如果您已经添加好了forest-spring-boot-starter依赖，基本上可以什么都不配置，可直接跳转到《springboot环境运行》学习如何上手使用\n\n当然也可以进行些简单的配置\n\n\n# 简单配置\n\n在application.yaml / application.properties中配置的 http 基本参数\n\nforest:\n  max-connections: 1000        # 连接池最大连接数\n  connect-timeout: 3000        # 连接超时时间，单位为毫秒\n  read-timeout: 3000           # 数据读取超时时间，单位为毫秒\n\n\n1\n2\n3\n4\n\n\n# 连接池最大连接数\nforest.max-connections=1000\n# 连接超时时间，单位为毫秒\nforest.connect-timeout=3000\n# 数据读取超时时间，单位为毫秒\nforest.read-timeout=3000\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 详细配置\n\nforest的详细配置说明，请参见《springboot环境配置项》",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎯 Springboot环境使用",frontmatter:{id:"spring_boot_usage",title:"🎯 Springboot环境使用",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_boot_usage/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/004.spring_boot_usage.html",relativePath:"001.v1.5.x文档/020.入门/004.spring_boot_usage.md",key:"v-9d6b1a9a",path:"/pages/1.5.x/spring_boot_usage/",headers:[{level:2,title:"Hello World",slug:"hello-world",normalizedTitle:"hello world",charIndex:231},{level:2,title:"扫描接口",slug:"扫描接口",normalizedTitle:"扫描接口",charIndex:555},{level:2,title:"发送请求",slug:"发送请求",normalizedTitle:"发送请求",charIndex:143}],headersStr:"Hello World 扫描接口 发送请求",content:'在 Forest 依赖加入好，并配置好之后，就可以构建 HTTP 请求的接口了\n\n如还没有添加好依赖或配置好，请参见《Springboot环境安装》和《Springboot环境配置》\n\n在 Forest 中，所有的 HTTP 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 HTTP 请求信息的接口方法，自动去执行 HTTP 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 HTTP 请求信息\n\n\n# Hello World\n\n创建一个interface，比如命名为MyClient，并创建一个接口方法名为helloForest，用@Get注解修饰之。\n\npublic interface MyClient {\n\n    @Get("http://localhost:8080/hello")\n    String helloForest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@Get注解，将上面的MyClient接口中的helloForest()方法绑定了一个 HTTP 请求， 其 URL 为http://localhost:8080/hello ，并默认使用GET方式，且将请求响应的数据以String的方式返回给调用者。\n\n\n# 扫描接口\n\n友情提示\n\n1.5.1以后版本可以跳过此步，不需要 @ForestScan 注解来指定扫描的包范围\n\n若您已有定义好的 Forest 请求接口(比如名为 com.yoursite.client.MyClient)，那就可以开始愉快使用它了。\n\n只要在Springboot的配置类或者启动类上加上@ForestScan注解，并在basePackages属性里填上远程接口的所在的包名\n\n@SpringBootApplication\n@Configuration\n@ForestScan(basePackages = "com.yoursite.client")\npublic class MyApp {\n ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nForest 会扫描@ForestScan注解中basePackages属性指定的包下面所有的接口，然后会将符合条件的接口进行动态代理并注入到 Spring 的上下文中。\n\n\n# 发送请求\n\n然后便能在其他代码中从 Spring 上下文注入接口实例，然后如调用普通接口那样调用即可\n\n@Component\npublic class MyService {\n    \n    // 注入自定义的 Forest 接口实例\n    @Resource\n    private MyClient myClient;\n\n    public void testClient() {\n        // 调用自定义的 Forest 接口方法\n        // 等价于发送 HTTP 请求，请求地址和参数即为 helloForest 方法上注解所标识的内容\n        String result = myClient.helloForest();\n        // result 即为 HTTP 请求响应后返回的字符串类型数据\n        System.out.println(result);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'在 forest 依赖加入好，并配置好之后，就可以构建 http 请求的接口了\n\n如还没有添加好依赖或配置好，请参见《springboot环境安装》和《springboot环境配置》\n\n在 forest 中，所有的 http 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 http 请求信息的接口方法，自动去执行 http 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 http 请求信息\n\n\n# hello world\n\n创建一个interface，比如命名为myclient，并创建一个接口方法名为helloforest，用@get注解修饰之。\n\npublic interface myclient {\n\n    @get("http://localhost:8080/hello")\n    string helloforest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@get注解，将上面的myclient接口中的helloforest()方法绑定了一个 http 请求， 其 url 为http://localhost:8080/hello ，并默认使用get方式，且将请求响应的数据以string的方式返回给调用者。\n\n\n# 扫描接口\n\n友情提示\n\n1.5.1以后版本可以跳过此步，不需要 @forestscan 注解来指定扫描的包范围\n\n若您已有定义好的 forest 请求接口(比如名为 com.yoursite.client.myclient)，那就可以开始愉快使用它了。\n\n只要在springboot的配置类或者启动类上加上@forestscan注解，并在basepackages属性里填上远程接口的所在的包名\n\n@springbootapplication\n@configuration\n@forestscan(basepackages = "com.yoursite.client")\npublic class myapp {\n ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nforest 会扫描@forestscan注解中basepackages属性指定的包下面所有的接口，然后会将符合条件的接口进行动态代理并注入到 spring 的上下文中。\n\n\n# 发送请求\n\n然后便能在其他代码中从 spring 上下文注入接口实例，然后如调用普通接口那样调用即可\n\n@component\npublic class myservice {\n    \n    // 注入自定义的 forest 接口实例\n    @resource\n    private myclient myclient;\n\n    public void testclient() {\n        // 调用自定义的 forest 接口方法\n        // 等价于发送 http 请求，请求地址和参数即为 helloforest 方法上注解所标识的内容\n        string result = myclient.helloforest();\n        // result 即为 http 请求响应后返回的字符串类型数据\n        system.out.println(result);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🏹 Spring环境安装",frontmatter:{id:"spring_install",title:"🏹 Spring环境安装",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_install/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/005.spring_install.html",relativePath:"001.v1.5.x文档/020.入门/005.spring_install.md",key:"v-47f8bcf5",path:"/pages/1.5.x/spring_install/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"JSON框架依赖",slug:"json框架依赖",normalizedTitle:"json框架依赖",charIndex:466},{level:2,title:"Protobuf框架依赖",slug:"protobuf框架依赖",normalizedTitle:"protobuf框架依赖",charIndex:1566}],headersStr:"依赖 JSON框架依赖 Protobuf框架依赖",content:"# 依赖\n\n<dependency>\n  <groupId>com.dtflys.forest</groupId>\n  <artifactId>forest-core</artifactId>\n  <version>1.5.25</version>\n</dependency>\n\n<dependency>\n  <groupId>com.dtflys.forest</groupId>\n  <artifactId>forest-spring</artifactId>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ncompile group: 'com.dtflys.forest', name: 'forest-core', version: '1.5.24'\ncompile group: 'com.dtflys.forest', name: 'forest-spring', version: '1.5.24'\n\n\n1\n2\n\n\n\n# JSON框架依赖\n\n如果您的项目中还没有JSON解析框架，如Fastjson或Jackson，请根据需要添加以下依赖。如果已经有了，可以跳过此步\n\nFastjson依赖：版本 >= 1.2.48\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>fastjson</artifactId>\n  <version>1.2.73</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.alibaba', name: 'fastjson', version: '1.2.73'\n\n\n1\n\n\nJackson依赖：版本 >= 2.9.10\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-core</artifactId>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-annotations</artifactId>\n  <version>2.9.10</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: '2.9.10'\n\n\n1\n2\n3\n\n\n\n# Protobuf框架依赖\n\n如果您的项目需要使用 Protobuf, 就需要引入 Google 的 Protobuf 包依赖\n\n若是已经引入了 forest-spring-boot-starter 启动包，就不用再引入该依赖了，因为在 Forest 的启动包中已经传递依赖此包\n\n版本 >= 3.14.0\n\n<dependency>\n  <groupId>com.google.protobuf</groupId>\n  <artifactId>protobuf-java</artifactId>\n  <version>3.18.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.18.1'\n\n\n1\n",normalizedContent:"# 依赖\n\n<dependency>\n  <groupid>com.dtflys.forest</groupid>\n  <artifactid>forest-core</artifactid>\n  <version>1.5.25</version>\n</dependency>\n\n<dependency>\n  <groupid>com.dtflys.forest</groupid>\n  <artifactid>forest-spring</artifactid>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ncompile group: 'com.dtflys.forest', name: 'forest-core', version: '1.5.24'\ncompile group: 'com.dtflys.forest', name: 'forest-spring', version: '1.5.24'\n\n\n1\n2\n\n\n\n# json框架依赖\n\n如果您的项目中还没有json解析框架，如fastjson或jackson，请根据需要添加以下依赖。如果已经有了，可以跳过此步\n\nfastjson依赖：版本 >= 1.2.48\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>fastjson</artifactid>\n  <version>1.2.73</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.alibaba', name: 'fastjson', version: '1.2.73'\n\n\n1\n\n\njackson依赖：版本 >= 2.9.10\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-core</artifactid>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-databind</artifactid>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-annotations</artifactid>\n  <version>2.9.10</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: '2.9.10'\n\n\n1\n2\n3\n\n\n\n# protobuf框架依赖\n\n如果您的项目需要使用 protobuf, 就需要引入 google 的 protobuf 包依赖\n\n若是已经引入了 forest-spring-boot-starter 启动包，就不用再引入该依赖了，因为在 forest 的启动包中已经传递依赖此包\n\n版本 >= 3.14.0\n\n<dependency>\n  <groupid>com.google.protobuf</groupid>\n  <artifactid>protobuf-java</artifactid>\n  <version>3.18.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.18.1'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"📐 Spring环境配置",frontmatter:{id:"spring_config",title:"📐 Spring环境配置",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_config/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/006.spring_config.html",relativePath:"001.v1.5.x文档/020.入门/006.spring_config.md",key:"v-dfc6439a",path:"/pages/1.5.x/spring_config/",headers:[{level:3,title:"约定大于配置",slug:"约定大于配置",normalizedTitle:"约定大于配置",charIndex:2},{level:3,title:"配置 XML SCEHEMA",slug:"配置-xml-scehema",normalizedTitle:"配置 xml scehema",charIndex:82},{level:3,title:"添加Forest基本配置的定义",slug:"添加forest基本配置的定义",normalizedTitle:"添加forest基本配置的定义",charIndex:889},{level:3,title:"详细配置",slug:"详细配置",normalizedTitle:"详细配置",charIndex:1439}],headersStr:"约定大于配置 配置 XML SCEHEMA 添加Forest基本配置的定义 详细配置",content:'# 约定大于配置\n\nForest是基于约定大于配置的理念进行设计的，如果您已经添加好了Forest Spring环境相关依赖，只要进行些简单的配置即可使用\n\n\n# 配置 XML SCEHEMA\n\n打开spring的上下文配置文件，在beans开头定义的属性中加入Forest的Schema\n\nxmlns:forest="http://forest.dtflyx.com/schema/forest"\n   ...\nxsi:schemaLocation=" ...\nhttp://forest.dtflyx.com/schema/forest\nhttp://forest.dtflyx.com/schema/forest/forest-spring.xsd\n..."\n\n\n1\n2\n3\n4\n5\n6\n\n\n加入完成后类似如下效果\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:forest="http://forest.dtflyx.com/schema/forest"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://forest.dtflyx.com/schema/forest\n       http://forest.dtflyx.com/schema/forest/forest-spring.xsd">\n    \n   ...\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 添加Forest基本配置的定义\n\n\x3c!-- Forest 全局配置 --\x3e\n\x3c!-- maxConnections 每个路由的最大连接数 --\x3e\n\x3c!-- connectTimeout 连接超时时间，单位为毫秒 --\x3e\n\x3c!-- readTimeout 数据读取超时时间，单位为毫秒 --\x3e\n<forest:configuration\n        id="configuration"\n        maxConnections="500"\n        connectTimeout="10000"\n        readTimeout="3000">\n   \n    \x3c!-- 定义 Forest 客户端接口所在的包名 --\x3e\n    \x3c!-- 扫描 base-package 属性定义包，然后会将该包名下符合条件的接口进行动态代理并注入到 Spring 的上下文中 --\x3e\n    <forest:scan configuration="configuration" base-package="com.yoursite.client"/>\n   \n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 详细配置\n\nForest的详细配置说明，请参见《Spring环境配置项》',normalizedContent:'# 约定大于配置\n\nforest是基于约定大于配置的理念进行设计的，如果您已经添加好了forest spring环境相关依赖，只要进行些简单的配置即可使用\n\n\n# 配置 xml scehema\n\n打开spring的上下文配置文件，在beans开头定义的属性中加入forest的schema\n\nxmlns:forest="http://forest.dtflyx.com/schema/forest"\n   ...\nxsi:schemalocation=" ...\nhttp://forest.dtflyx.com/schema/forest\nhttp://forest.dtflyx.com/schema/forest/forest-spring.xsd\n..."\n\n\n1\n2\n3\n4\n5\n6\n\n\n加入完成后类似如下效果\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:forest="http://forest.dtflyx.com/schema/forest"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://forest.dtflyx.com/schema/forest\n       http://forest.dtflyx.com/schema/forest/forest-spring.xsd">\n    \n   ...\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 添加forest基本配置的定义\n\n\x3c!-- forest 全局配置 --\x3e\n\x3c!-- maxconnections 每个路由的最大连接数 --\x3e\n\x3c!-- connecttimeout 连接超时时间，单位为毫秒 --\x3e\n\x3c!-- readtimeout 数据读取超时时间，单位为毫秒 --\x3e\n<forest:configuration\n        id="configuration"\n        maxconnections="500"\n        connecttimeout="10000"\n        readtimeout="3000">\n   \n    \x3c!-- 定义 forest 客户端接口所在的包名 --\x3e\n    \x3c!-- 扫描 base-package 属性定义包，然后会将该包名下符合条件的接口进行动态代理并注入到 spring 的上下文中 --\x3e\n    <forest:scan configuration="configuration" base-package="com.yoursite.client"/>\n   \n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 详细配置\n\nforest的详细配置说明，请参见《spring环境配置项》',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎯 Spring环境使用",frontmatter:{id:"spring_usage",title:"🎯 Spring环境使用",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_usage/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/007.spring_usage.html",relativePath:"001.v1.5.x文档/020.入门/007.spring_usage.md",key:"v-90253aa6",path:"/pages/1.5.x/spring_usage/",headers:[{level:2,title:"Hello World",slug:"hello-world",normalizedTitle:"hello world",charIndex:218},{level:2,title:"扫描接口",slug:"扫描接口",normalizedTitle:"扫描接口",charIndex:611},{level:3,title:"调用接口",slug:"调用接口",normalizedTitle:"调用接口",charIndex:664}],headersStr:"Hello World 扫描接口 调用接口",content:'在 Forest 依赖加入好之后，就可以构建 HTTP 请求的接口了\n\n如还没有添加好依赖或配置好，请参见《Spring环境安装》和《Spring环境配置》\n\n在 Forest 中，所有的 HTTP 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 HTTP 请求信息的接口方法，自动去执行 HTTP 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 HTTP 请求信息\n\n\n# Hello World\n\n创建一个interface，比如命名为MyClient，并创建一个接口方法名为helloForest，用@Get注解修饰之。\n\npublic interface MyClient {\n\n    @Get("http://localhost:8080/hello")\n    String helloForest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@Get注解，将上面的MyClient接口中的helloForest()方法绑定了一个 HTTP 请求， 其 URL 为http://localhost:8080/hello，并默认使用GET方式，且将请求响应的数据以String的方式返回给调用者\n\n若您已有定义好的 Forest 请求接口(比如名为 com.yoursite.client.MyClient)，那就可以开始愉快使用它了。\n\n\n# 扫描接口\n\n在上一节内容中已经进行了对接口所在包扫描的配置，如没有请参见《Spring环境配置》\n\n\n# 调用接口\n\n@Component\npublic class MyService {\n    @Resource\n    private MyClient myClient;\n\n    public void testClient() {\n        String result = myClient.helloForest();\n        System.out.println(result);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'在 forest 依赖加入好之后，就可以构建 http 请求的接口了\n\n如还没有添加好依赖或配置好，请参见《spring环境安装》和《spring环境配置》\n\n在 forest 中，所有的 http 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 http 请求信息的接口方法，自动去执行 http 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 http 请求信息\n\n\n# hello world\n\n创建一个interface，比如命名为myclient，并创建一个接口方法名为helloforest，用@get注解修饰之。\n\npublic interface myclient {\n\n    @get("http://localhost:8080/hello")\n    string helloforest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@get注解，将上面的myclient接口中的helloforest()方法绑定了一个 http 请求， 其 url 为http://localhost:8080/hello，并默认使用get方式，且将请求响应的数据以string的方式返回给调用者\n\n若您已有定义好的 forest 请求接口(比如名为 com.yoursite.client.myclient)，那就可以开始愉快使用它了。\n\n\n# 扫描接口\n\n在上一节内容中已经进行了对接口所在包扫描的配置，如没有请参见《spring环境配置》\n\n\n# 调用接口\n\n@component\npublic class myservice {\n    @resource\n    private myclient myclient;\n\n    public void testclient() {\n        string result = myclient.helloforest();\n        system.out.println(result);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🏹 原生Java环境安装",frontmatter:{id:"java_install",title:"🏹 原生Java环境安装",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/java_install/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/008.java_install.html",relativePath:"001.v1.5.x文档/020.入门/008.java_install.md",key:"v-a477f05e",path:"/pages/1.5.x/java_install/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"JSON框架依赖",slug:"json框架依赖",normalizedTitle:"json框架依赖",charIndex:294},{level:2,title:"Protobuf框架依赖",slug:"protobuf框架依赖",normalizedTitle:"protobuf框架依赖",charIndex:1394}],headersStr:"依赖 JSON框架依赖 Protobuf框架依赖",content:"# 依赖\n\n若您的项目既非Spring Boot也非Spring的普通原生Java项目，只需添加 Forest 核心包依赖\n\n<dependency>\n  <groupId>com.dtflys.forest</groupId>\n  <artifactId>forest-core</artifactId>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.dtflys.forest', name: 'forest-core', version: '1.5.25'\n\n\n1\n\n\n\n# JSON框架依赖\n\n如果您的项目中还没有JSON解析框架，如Fastjson或Jackson，请根据需要添加以下依赖。如果已经有了，可以跳过此步\n\nFastjson依赖：版本 >= 1.2.48\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>fastjson</artifactId>\n  <version>1.2.73</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.alibaba', name: 'fastjson', version: '1.2.73'\n\n\n1\n\n\nJackson依赖：版本 >= 2.9.10\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-core</artifactId>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-databind</artifactId>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupId>com.fasterxml.jackson.core</groupId>\n  <artifactId>jackson-annotations</artifactId>\n  <version>2.9.10</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: '2.9.10'\n\n\n1\n2\n3\n\n\n\n# Protobuf框架依赖\n\n如果您的项目需要使用 Protobuf, 就需要引入 Google 的 Protobuf 包依赖\n\n若是已经引入了 forest-spring-boot-starter 启动包，就不用再引入该依赖了，因为在 Forest 的启动包中已经传递依赖此包\n\n版本 >= 3.14.0\n\n<dependency>\n  <groupId>com.google.protobuf</groupId>\n  <artifactId>protobuf-java</artifactId>\n  <version>3.18.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.18.1'\n\n\n1\n",normalizedContent:"# 依赖\n\n若您的项目既非spring boot也非spring的普通原生java项目，只需添加 forest 核心包依赖\n\n<dependency>\n  <groupid>com.dtflys.forest</groupid>\n  <artifactid>forest-core</artifactid>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.dtflys.forest', name: 'forest-core', version: '1.5.25'\n\n\n1\n\n\n\n# json框架依赖\n\n如果您的项目中还没有json解析框架，如fastjson或jackson，请根据需要添加以下依赖。如果已经有了，可以跳过此步\n\nfastjson依赖：版本 >= 1.2.48\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>fastjson</artifactid>\n  <version>1.2.73</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.alibaba', name: 'fastjson', version: '1.2.73'\n\n\n1\n\n\njackson依赖：版本 >= 2.9.10\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-core</artifactid>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-databind</artifactid>\n  <version>2.9.10</version>\n</dependency>\n\n<dependency>\n  <groupid>com.fasterxml.jackson.core</groupid>\n  <artifactid>jackson-annotations</artifactid>\n  <version>2.9.10</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.9.10'\ncompile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: '2.9.10'\n\n\n1\n2\n3\n\n\n\n# protobuf框架依赖\n\n如果您的项目需要使用 protobuf, 就需要引入 google 的 protobuf 包依赖\n\n若是已经引入了 forest-spring-boot-starter 启动包，就不用再引入该依赖了，因为在 forest 的启动包中已经传递依赖此包\n\n版本 >= 3.14.0\n\n<dependency>\n  <groupid>com.google.protobuf</groupid>\n  <artifactid>protobuf-java</artifactid>\n  <version>3.18.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\ncompile group: 'com.google.protobuf', name: 'protobuf-java', version: '3.18.1'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"📐 原生Java环境配置",frontmatter:{id:"java_config",title:"📐 原生Java环境配置",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/java_config/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/009.java_config.html",relativePath:"001.v1.5.x文档/020.入门/009.java_config.md",key:"v-0859f29a",path:"/pages/1.5.x/java_config/",headers:[{level:3,title:"约定大于配置",slug:"约定大于配置",normalizedTitle:"约定大于配置",charIndex:2},{level:3,title:"简单配置",slug:"简单配置",normalizedTitle:"简单配置",charIndex:115},{level:3,title:"详细配置",slug:"详细配置",normalizedTitle:"详细配置",charIndex:377}],headersStr:"约定大于配置 简单配置 详细配置",content:"# 约定大于配置\n\nForest是基于约定大于配置的理念进行设计的，如果您已经添加好了forest-core依赖，基本上可以什么都不配置，可直接跳转到《原生Java环境运行》学习如何上手使用\n\n当然也可以进行些简单的配置\n\n\n# 简单配置\n\n// 获取 Forest 全局配置对象\nForestConfiguration configuration = Forest.config();\n// 连接池最大连接数\nconfiguration.setMaxConnections(1000);\n// 连接超时时间，单位为毫秒\nconfiguration.setConnectTimeout(2000);\n// 数据读取超时时间，单位为毫秒\nconfiguration.setReadTimeout(2000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 详细配置\n\nForest的详细配置说明，请参见《原生Java环境配置项》",normalizedContent:"# 约定大于配置\n\nforest是基于约定大于配置的理念进行设计的，如果您已经添加好了forest-core依赖，基本上可以什么都不配置，可直接跳转到《原生java环境运行》学习如何上手使用\n\n当然也可以进行些简单的配置\n\n\n# 简单配置\n\n// 获取 forest 全局配置对象\nforestconfiguration configuration = forest.config();\n// 连接池最大连接数\nconfiguration.setmaxconnections(1000);\n// 连接超时时间，单位为毫秒\nconfiguration.setconnecttimeout(2000);\n// 数据读取超时时间，单位为毫秒\nconfiguration.setreadtimeout(2000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 详细配置\n\nforest的详细配置说明，请参见《原生java环境配置项》",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎯 原生Java环境使用",frontmatter:{id:"java_usage",title:"🎯 原生Java环境使用",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/java_usage/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/010.java_usage.html",relativePath:"001.v1.5.x文档/020.入门/010.java_usage.md",key:"v-4e19ff1a",path:"/pages/1.5.x/java_usage/",headers:[{level:2,title:"Hello World",slug:"hello-world",normalizedTitle:"hello world",charIndex:174},{level:2,title:"发送请求",slug:"发送请求",normalizedTitle:"发送请求",charIndex:86}],headersStr:"Hello World 发送请求",content:'在 Forest 依赖加入好之后，就可以构建 HTTP 请求的接口了\n\n在 Forest 中，所有的 HTTP 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 HTTP 请求信息的接口方法，自动去执行 HTTP 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 HTTP 请求信息\n\n\n# Hello World\n\n创建一个interface，比如命名为MyClient，并创建一个接口方法名为helloForest，用@Request注解修饰之。\n\npublic interface MyClient {\n\n    @Request("http://localhost:8080/hello")\n    String helloForest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@Request注解，将上面的MyClient接口中的helloForest()方法绑定了一个 HTTP 请求， 其 URL 为http://localhost:8080/hello ，并默认使用GET方式，且将请求响应的数据以String的方式返回给调用者。\n\n\n# 发送请求\n\n若您已有定义好的 Forest 请求接口(比如名为 com.yoursite.client.MyClient)，那就可以开始愉快使用它了\n\n通过Forest的client(Class clazz)方法实例化接口，然后如调用普通接口那样调用即可\n\n// 实例化Forest请求接口\nMyClient myClient = Forest.client(MyClient.class);\n// 调用Forest请求接口，并获取响应返回结果\nString result = myClient.simpleRequest();\n// 打印响应结果\nSystem.out.println(result);\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'在 forest 依赖加入好之后，就可以构建 http 请求的接口了\n\n在 forest 中，所有的 http 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 http 请求信息的接口方法，自动去执行 http 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 http 请求信息\n\n\n# hello world\n\n创建一个interface，比如命名为myclient，并创建一个接口方法名为helloforest，用@request注解修饰之。\n\npublic interface myclient {\n\n    @request("http://localhost:8080/hello")\n    string helloforest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@request注解，将上面的myclient接口中的helloforest()方法绑定了一个 http 请求， 其 url 为http://localhost:8080/hello ，并默认使用get方式，且将请求响应的数据以string的方式返回给调用者。\n\n\n# 发送请求\n\n若您已有定义好的 forest 请求接口(比如名为 com.yoursite.client.myclient)，那就可以开始愉快使用它了\n\n通过forest的client(class clazz)方法实例化接口，然后如调用普通接口那样调用即可\n\n// 实例化forest请求接口\nmyclient myclient = forest.client(myclient.class);\n// 调用forest请求接口，并获取响应返回结果\nstring result = myclient.simplerequest();\n// 打印响应结果\nsystem.out.println(result);\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🧬 编程式接口",frontmatter:{id:"quick",title:"🧬 编程式接口",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/param_api/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/020.%E5%85%A5%E9%97%A8/011.param_api.html",relativePath:"001.v1.5.x文档/020.入门/011.param_api.md",key:"v-42c56ef3",path:"/pages/1.5.x/param_api/",headers:[{level:3,title:"发送请求",slug:"发送请求",normalizedTitle:"发送请求",charIndex:34}],headersStr:"发送请求",content:'Forest 是一个以接口 + 注解形式定义请求为主的HTTP框架，发送请求前先需要定义一个 interface 接口类，再组合使用 Forest 的注解（如：@Get）定义绑定的HTTP请求参数，随后再实例化接口类对象，最终调用该接口绑定HTTP参数注解的方法实现请求的发送。\n\n这样做有很多优点，比如在 Java 代码和 HTTP 协议之间实现解耦，同时方便众多请求接口的管理。但缺点也很明显：步骤较多，如果想要直接快速的请求一个简单的URL地址就显得过重了。\n\n不过，Forest 自 1.5.3 版本起，就提供了编程式接口，不用定义接口类也能发送请求，使用也很方便。\n\n\n# 发送请求\n\n以字符串形式接受响应数据\n\n// Get请求\n// 并以 String 类型接受数据\nString str = Forest.get("/").executeAsString();\n\n\n1\n2\n3\n\n\n以自定义类型形式接受响应数据\n\n// Post请求\n// 并以自定义的 MyResult 类型接受\nMyResult myResult = Forest.post("/").execute(MyResult.class);\n\n\n1\n2\n3\n\n\n以带复杂泛型参数的类型形式接受响应数据\n\n// 通过 TypeReference 引用类传递泛型参数\n// 就可以将响应数据以带复杂泛型参数的类型接受了\nResult<List<User>> userList = Forest.post("/")\n        .execute(new TypeReference<Result<List<User>>>() {});\n\n\n1\n2\n3\n4\n\n\n异步请求\n\n// 异步 Post 请求\n// 通过 onSuccess 回调函数处理请求成功后的结果\n// 而 onError 回调函数则在请求失败后被触发\nForest.post("/")\n        .async()\n        .onSuccess(((data, req, res) -> {\n            // data 为响应成功后返回的反序列化过的数据\n            // req 为Forest请求对象，即 ForestRequest 类实例\n            // res 为Forest响应对象，即 ForestResponse 类实例\n        }))\n        .onError(((ex, req, res) -> {\n            // ex 为请求过程可能抛出的异常对象\n            // req 为Forest请求对象，即 ForestRequest 类实例\n            // res 为Forest响应对象，即 ForestResponse 类实例\n        }))\n        .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n定义请求的各种参数\n\n// 定义各种参数\n// 并以 Map 类型接受\nMap<String, Object> map = Forest.post("/")\n      .backend("okhttp3")        // 设置后端为 okhttp3\n      .host("127.0.0.1")         // 设置地址的host为 127.0.0.1\n      .port(8080)                // 设置地址的端口为 8080\n      .contentTypeJson()         // 设置 Content-Type 头为 application/json\n      .addBody("a", 1)           // 添加 Body 项(键值对)： a, 1\n      .addBody("b", 2)           // 添加 Body 项(键值对：  b, 2\n      .maxRetryCount(3)          // 设置请求最大重试次数为 3\n      // 设置 onSuccess 回调函数\n      .onSuccess((data, req, res) -> { log.info("success!"); })\n      // 设置 onError 回调函数\n      .onError((ex, req, res) -> { log.info("error!"); })\n      // 设置请求成功判断条件回调函数\n      .successWhen((req, res) -> res.noException() && res.statusOk())\n      // 执行并返回Map数据类型对象\n      .executeAsMap();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nForest 的快速接口（如：Forest.get(String url)、Forest.post(String url)等方法）本质上是返回了一个 Forest 请求对象（即 ForestRequest 类对象），Forest 的绝大部分操作都是围绕请求对象所作的工作。\n\n文档导航\n\n要详细了解 Forest 请求对象如何使用，请参见《请求对象》',normalizedContent:'forest 是一个以接口 + 注解形式定义请求为主的http框架，发送请求前先需要定义一个 interface 接口类，再组合使用 forest 的注解（如：@get）定义绑定的http请求参数，随后再实例化接口类对象，最终调用该接口绑定http参数注解的方法实现请求的发送。\n\n这样做有很多优点，比如在 java 代码和 http 协议之间实现解耦，同时方便众多请求接口的管理。但缺点也很明显：步骤较多，如果想要直接快速的请求一个简单的url地址就显得过重了。\n\n不过，forest 自 1.5.3 版本起，就提供了编程式接口，不用定义接口类也能发送请求，使用也很方便。\n\n\n# 发送请求\n\n以字符串形式接受响应数据\n\n// get请求\n// 并以 string 类型接受数据\nstring str = forest.get("/").executeasstring();\n\n\n1\n2\n3\n\n\n以自定义类型形式接受响应数据\n\n// post请求\n// 并以自定义的 myresult 类型接受\nmyresult myresult = forest.post("/").execute(myresult.class);\n\n\n1\n2\n3\n\n\n以带复杂泛型参数的类型形式接受响应数据\n\n// 通过 typereference 引用类传递泛型参数\n// 就可以将响应数据以带复杂泛型参数的类型接受了\nresult<list<user>> userlist = forest.post("/")\n        .execute(new typereference<result<list<user>>>() {});\n\n\n1\n2\n3\n4\n\n\n异步请求\n\n// 异步 post 请求\n// 通过 onsuccess 回调函数处理请求成功后的结果\n// 而 onerror 回调函数则在请求失败后被触发\nforest.post("/")\n        .async()\n        .onsuccess(((data, req, res) -> {\n            // data 为响应成功后返回的反序列化过的数据\n            // req 为forest请求对象，即 forestrequest 类实例\n            // res 为forest响应对象，即 forestresponse 类实例\n        }))\n        .onerror(((ex, req, res) -> {\n            // ex 为请求过程可能抛出的异常对象\n            // req 为forest请求对象，即 forestrequest 类实例\n            // res 为forest响应对象，即 forestresponse 类实例\n        }))\n        .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n定义请求的各种参数\n\n// 定义各种参数\n// 并以 map 类型接受\nmap<string, object> map = forest.post("/")\n      .backend("okhttp3")        // 设置后端为 okhttp3\n      .host("127.0.0.1")         // 设置地址的host为 127.0.0.1\n      .port(8080)                // 设置地址的端口为 8080\n      .contenttypejson()         // 设置 content-type 头为 application/json\n      .addbody("a", 1)           // 添加 body 项(键值对)： a, 1\n      .addbody("b", 2)           // 添加 body 项(键值对：  b, 2\n      .maxretrycount(3)          // 设置请求最大重试次数为 3\n      // 设置 onsuccess 回调函数\n      .onsuccess((data, req, res) -> { log.info("success!"); })\n      // 设置 onerror 回调函数\n      .onerror((ex, req, res) -> { log.info("error!"); })\n      // 设置请求成功判断条件回调函数\n      .successwhen((req, res) -> res.noexception() && res.statusok())\n      // 执行并返回map数据类型对象\n      .executeasmap();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nforest 的快速接口（如：forest.get(string url)、forest.post(string url)等方法）本质上是返回了一个 forest 请求对象（即 forestrequest 类对象），forest 的绝大部分操作都是围绕请求对象所作的工作。\n\n文档导航\n\n要详细了解 forest 请求对象如何使用，请参见《请求对象》',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"👜 Springboot环境配置项",frontmatter:{id:"spring_boot_config",title:"👜 Springboot环境配置项",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_boot_config_items/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/030.%E9%85%8D%E7%BD%AE%E9%A1%B9/001.spring_boot_config_items.html",relativePath:"001.v1.5.x文档/030.配置项/001.spring_boot_config_items.md",key:"v-27e9a7a7",path:"/pages/1.5.x/spring_boot_config_items/",headers:[{level:3,title:"配置后端 HTTP API",slug:"配置后端-http-api",normalizedTitle:"配置后端 http api",charIndex:109},{level:3,title:"全局基本配置",slug:"全局基本配置",normalizedTitle:"全局基本配置",charIndex:451},{level:3,title:"全局变量定义",slug:"全局变量定义",normalizedTitle:"全局变量定义",charIndex:2453},{level:3,title:"配置 Bean ID",slug:"配置-bean-id",normalizedTitle:"配置 bean id",charIndex:2828}],headersStr:"配置后端 HTTP API 全局基本配置 全局变量定义 配置 Bean ID",content:'若您的项目依赖Spring Boot，并加入了spring-boot-starter-forest依赖，就可以通过 application.yml/application.properties 方式定义配置。\n\n\n# 配置后端 HTTP API\n\nforest:\n  backend: okhttp3 # 配置后端HTTP API为 okhttp3\n\n\n1\n2\n\n\n# 配置后端HTTP API为 okhttp3\nforest.backend=okhttp3\n\n\n1\n2\n\n\n目前 Forest 支持okhttp3和httpclient两种后端 HTTP API，若不配置该属性，默认为okhttp3 当然，您也可以改为httpclient\n\nforest:\n  backend: httpclient # 配置后端HTTP API为 httpclient\n\n\n1\n2\n\n\n# 配置后端HTTP API为 httpclient\nforest.backend=httpclient\n\n\n1\n2\n\n\n\n# 全局基本配置\n\n在application.yaml / application.properties中配置的 HTTP 基本参数\n\nforest:\n  backend: okhttp3             # 后端HTTP框架（默认为 okhttp3）\n  max-connections: 1000        # 连接池最大连接数（默认为 500）\n  max-route-connections: 500   # 每个路由的最大连接数（默认为 500）\n  max-request-queue-size: 100  # [自v1.5.22版本起可用] 最大请求等待队列大小\n  max-async-thread-size: 300   # [自v1.5.21版本起可用] 最大异步线程数\n  max-async-queue-size: 16     # [自v1.5.22版本起可用] 最大异步线程池队列大小\n  timeout: 3000                # [已不推荐使用] 请求超时时间，单位为毫秒（默认为 3000）\n  connect-timeout: 3000        # 连接超时时间，单位为毫秒（默认为 timeout）\n  read-timeout: 3000           # 数据读取超时时间，单位为毫秒（默认为 timeout）\n  max-retry-count: 0           # 请求失败后重试次数（默认为 0 次不重试）\n  ssl-protocol: TLS            # 单向验证的HTTPS的默认TLS协议（默认为 TLS）\n  log-enabled: true            # 打开或关闭日志（默认为 true）\n  log-request: true            # 打开/关闭Forest请求日志（默认为 true）\n  log-response-status: true    # 打开/关闭Forest响应状态日志（默认为 true）\n  log-response-content: true   # 打开/关闭Forest响应内容日志（默认为 false）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 后端HTTP框架（默认为 okhttp3）\nforest.backend=okhttp3\n# 连接池最大连接数（默认为 500）\nforest.max-connections=1000\n# 每个路由的最大连接数（默认为 500）\nforest.max-route-connections=500\n# [自v1.5.22版本起可用] 最大请求等待队列大小\nforest.max-request-queue-size=800\n# [自v1.5.21版本起可用] 最大异步线程数\nforest.max-async-thread-size=300\n# [自v1.5.22版本起可用] 最大异步线程池队列大小\nforest.max-async-queue-size=16\n# (已不推荐使用) 请求超时时间，单位为毫秒（默认为 3000）\nforest.timeout=3000\n# 连接超时时间，单位为毫秒（默认为 timeout）\nforest.connect-timeout=3000\n# 数据读取超时时间，单位为毫秒（默认为 timeout）\nforest.read-timeout=3000\n# 请求失败后重试次数（默认为 0 次不重试）\nforest.max-retry-count=0\n# 单向验证的HTTPS的默认TLS协议（默认为 TLS）\nforest.ssl-protocol=TLS\n# 打开或关闭日志（默认为 true）\nforest.log-enabled=true\n# 打开/关闭Forest请求日志（默认为 true）\nforest.log-request=true\n# 打开/关闭Forest响应状态日志（默认为 true）\nforest.log-response-status=true\n# 打开/关闭Forest响应内容日志（默认为 false）\nforest.log-response-content=true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n注意\n\n * 这里max-retry-count只是简单机械的请求失败后的重试次数，所以一般建议设置为0。\n * 如果一定要多次重试，请一定要在保证服务端的幂等性的基础上进行重试，否则容易引发生产事故！\n\n\n# 全局变量定义\n\nForest 可以在forest.variables属性下自定义全局变量。\n\n其中 key 为变量名，value 为变量值。\n\n全局变量可以在任何模板表达式中进行数据绑定。\n\nforest:\n  variables:\n    username: foo      # 声明全局变量，变量名: username，变量值: foo\n    userpwd: bar       # 声明全局变量，变量名: userpwd，变量值: bar\n\n\n1\n2\n3\n4\n\n\n# 声明全局变量，变量名: username，变量值: foo\nforest.variables.username=foo\n# 声明全局变量，变量名: userpwd，变量值: bar\nforest.variables.userpwd=bar\n\n\n1\n2\n3\n4\n\n\n\n# 配置 Bean ID\n\nForest 允许您在 yaml 文件中配置 Bean Id，它对应着ForestConfiguration对象在 Spring 上下文中的 Bean 名称。\n\nforest:\n  bean-id: config0 # 在spring上下文中bean的id，默认值为forestConfiguration\n\n\n1\n2\n\n\n# 在spring上下文中bean的id，默认值为forestConfiguration\nforest.bean-id: config0\n\n\n1\n2\n\n\n然后便可以在 Spring 中通过 Bean 的名称引用到它\n\n@Resource(name = "config0")\nprivate ForestConfiguration config0;\n\n\n1\n2\n',normalizedContent:'若您的项目依赖spring boot，并加入了spring-boot-starter-forest依赖，就可以通过 application.yml/application.properties 方式定义配置。\n\n\n# 配置后端 http api\n\nforest:\n  backend: okhttp3 # 配置后端http api为 okhttp3\n\n\n1\n2\n\n\n# 配置后端http api为 okhttp3\nforest.backend=okhttp3\n\n\n1\n2\n\n\n目前 forest 支持okhttp3和httpclient两种后端 http api，若不配置该属性，默认为okhttp3 当然，您也可以改为httpclient\n\nforest:\n  backend: httpclient # 配置后端http api为 httpclient\n\n\n1\n2\n\n\n# 配置后端http api为 httpclient\nforest.backend=httpclient\n\n\n1\n2\n\n\n\n# 全局基本配置\n\n在application.yaml / application.properties中配置的 http 基本参数\n\nforest:\n  backend: okhttp3             # 后端http框架（默认为 okhttp3）\n  max-connections: 1000        # 连接池最大连接数（默认为 500）\n  max-route-connections: 500   # 每个路由的最大连接数（默认为 500）\n  max-request-queue-size: 100  # [自v1.5.22版本起可用] 最大请求等待队列大小\n  max-async-thread-size: 300   # [自v1.5.21版本起可用] 最大异步线程数\n  max-async-queue-size: 16     # [自v1.5.22版本起可用] 最大异步线程池队列大小\n  timeout: 3000                # [已不推荐使用] 请求超时时间，单位为毫秒（默认为 3000）\n  connect-timeout: 3000        # 连接超时时间，单位为毫秒（默认为 timeout）\n  read-timeout: 3000           # 数据读取超时时间，单位为毫秒（默认为 timeout）\n  max-retry-count: 0           # 请求失败后重试次数（默认为 0 次不重试）\n  ssl-protocol: tls            # 单向验证的https的默认tls协议（默认为 tls）\n  log-enabled: true            # 打开或关闭日志（默认为 true）\n  log-request: true            # 打开/关闭forest请求日志（默认为 true）\n  log-response-status: true    # 打开/关闭forest响应状态日志（默认为 true）\n  log-response-content: true   # 打开/关闭forest响应内容日志（默认为 false）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 后端http框架（默认为 okhttp3）\nforest.backend=okhttp3\n# 连接池最大连接数（默认为 500）\nforest.max-connections=1000\n# 每个路由的最大连接数（默认为 500）\nforest.max-route-connections=500\n# [自v1.5.22版本起可用] 最大请求等待队列大小\nforest.max-request-queue-size=800\n# [自v1.5.21版本起可用] 最大异步线程数\nforest.max-async-thread-size=300\n# [自v1.5.22版本起可用] 最大异步线程池队列大小\nforest.max-async-queue-size=16\n# (已不推荐使用) 请求超时时间，单位为毫秒（默认为 3000）\nforest.timeout=3000\n# 连接超时时间，单位为毫秒（默认为 timeout）\nforest.connect-timeout=3000\n# 数据读取超时时间，单位为毫秒（默认为 timeout）\nforest.read-timeout=3000\n# 请求失败后重试次数（默认为 0 次不重试）\nforest.max-retry-count=0\n# 单向验证的https的默认tls协议（默认为 tls）\nforest.ssl-protocol=tls\n# 打开或关闭日志（默认为 true）\nforest.log-enabled=true\n# 打开/关闭forest请求日志（默认为 true）\nforest.log-request=true\n# 打开/关闭forest响应状态日志（默认为 true）\nforest.log-response-status=true\n# 打开/关闭forest响应内容日志（默认为 false）\nforest.log-response-content=true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n注意\n\n * 这里max-retry-count只是简单机械的请求失败后的重试次数，所以一般建议设置为0。\n * 如果一定要多次重试，请一定要在保证服务端的幂等性的基础上进行重试，否则容易引发生产事故！\n\n\n# 全局变量定义\n\nforest 可以在forest.variables属性下自定义全局变量。\n\n其中 key 为变量名，value 为变量值。\n\n全局变量可以在任何模板表达式中进行数据绑定。\n\nforest:\n  variables:\n    username: foo      # 声明全局变量，变量名: username，变量值: foo\n    userpwd: bar       # 声明全局变量，变量名: userpwd，变量值: bar\n\n\n1\n2\n3\n4\n\n\n# 声明全局变量，变量名: username，变量值: foo\nforest.variables.username=foo\n# 声明全局变量，变量名: userpwd，变量值: bar\nforest.variables.userpwd=bar\n\n\n1\n2\n3\n4\n\n\n\n# 配置 bean id\n\nforest 允许您在 yaml 文件中配置 bean id，它对应着forestconfiguration对象在 spring 上下文中的 bean 名称。\n\nforest:\n  bean-id: config0 # 在spring上下文中bean的id，默认值为forestconfiguration\n\n\n1\n2\n\n\n# 在spring上下文中bean的id，默认值为forestconfiguration\nforest.bean-id: config0\n\n\n1\n2\n\n\n然后便可以在 spring 中通过 bean 的名称引用到它\n\n@resource(name = "config0")\nprivate forestconfiguration config0;\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"👝 Spring环境配置项",frontmatter:{id:"spring_config",title:"👝 Spring环境配置项",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/spring_config_items/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/030.%E9%85%8D%E7%BD%AE%E9%A1%B9/002.spring_config_items.html",relativePath:"001.v1.5.x文档/030.配置项/002.spring_config_items.md",key:"v-356ce46f",path:"/pages/1.5.x/spring_config_items/",headers:[{level:3,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:5},{level:3,title:"配置 XML SCEHEMA",slug:"配置-xml-scehema",normalizedTitle:"配置 xml scehema",charIndex:325},{level:3,title:"添加Forest基本配置的定义",slug:"添加forest基本配置的定义",normalizedTitle:"添加forest基本配置的定义",charIndex:1134},{level:4,title:"创建Client Bean",slug:"创建client-bean",normalizedTitle:"创建client bean",charIndex:3657}],headersStr:"依赖 配置 XML SCEHEMA 添加Forest基本配置的定义 创建Client Bean",content:'若您的项目依赖的是Spring，而非Spring Boot，或者使用xml方式进行Spring Bean的配置，那么您可以通过Spring xml的方式定义配置。\n\n\n# 依赖\n\n在进行Spring方式配置前，需要先确保您的项目在Maven中除了forest-core和spring外，还依赖forest-spring包\n\n <dependency>\n     <groupId>com.dtflys.forest</groupId>\n     <artifactId>forest-spring</artifactId>\n     <version>1.5.25</version>\n </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配置 XML SCEHEMA\n\n打开spring的上下文配置文件，在beans开头定义的属性中加入Forest的Schema\n\nxmlns:forest="http://forest.dtflyx.com/schema/forest" \n   ...\nxsi:schemaLocation=" ...\nhttp://forest.dtflyx.com/schema/forest\nhttp://forest.dtflyx.com/schema/forest/forest-spring.xsd \n..."\n\n\n1\n2\n3\n4\n5\n6\n\n\n加入完成后类似如下效果\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:forest="http://forest.dtflyx.com/schema/forest"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://forest.dtflyx.com/schema/forest\n       http://forest.dtflyx.com/schema/forest/forest-spring.xsd">\n    \n   ...\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 添加Forest基本配置的定义\n\n\x3c!-- Forest 全局配置 --\x3e\n\x3c!-- id 在spring上下文中bean的id, 默认值为forestConfiguration --\x3e\n\x3c!-- backend 后端HTTP API： okhttp3 --\x3e\n\x3c!-- timeout 请求超时时间，单位为毫秒, 默认值为3000 --\x3e\n\x3c!-- connectTimeout 连接超时时间，单位为毫秒, 默认值为2000 --\x3e\n\x3c!-- retryCount 请求失败后重试次数，默认为0次不重试 --\x3e\n\x3c!-- retryer 重试器类 --\x3e\n\x3c!-- sslProtocol 单向验证的HTTPS的默认SSL协议，默认为SSLv3 --\x3e\n\x3c!-- maxConnections 每个路由的最大连接数，默认为500 --\x3e\n\x3c!-- maxRouteConnections 每个路由的最大连接数，默认为500 --\x3e\n\x3c!-- maxRequestQueueSize [自v1.5.22版本起可用] 最大请求等待队列大小 --\x3e\n\x3c!-- maxAsyncThreadSize [自v1.5.21版本起可用] 最大异步线程数 --\x3e\n\x3c!-- maxAsyncQueueSize [自v1.5.22版本起可用] 最大异步线程池队列大小 --\x3e\n\x3c!-- logEnabled 打开或关闭日志总开关，默认为true --\x3e\n\x3c!-- logRequest 打开/关闭Forest请求日志（默认为 true） --\x3e\n\x3c!-- logResponseStatus 打开/关闭Forest响应状态日志（默认为 true） --\x3e\n\x3c!-- logResponseContent 打开/关闭Forest响应内容日志（默认为 false） --\x3e\n<forest:configuration\n    id="config0"\n    backend="httpclient"\n    timeout="30000"\n    connectTimeout="10000"\n    retryCount="3"\n    retryer="com.dtflys.forest.retryer.NoneRetryer"\n    charset="UTF-8"\n    sslProtocol="SSLv3"\n    maxConnections="500"\n    maxRouteConnections="500"\n    maxRequestQueueSize="100"\n    maxAsyncThreadSize="256"\n    maxAsyncQueueSize="128"\n    logEnabled="true"\n    logRequest="false"\n    logResponseStatus="false"\n    logResponseContent="true">\n\n   \x3c!-- forest变量定义 开始 --\x3e\n   <forest:var name="baseUrl" value="http://www.xxx.com"/>\n   <forest:var name="x" value="0"/>\n   <forest:var name="y" value="1"/>\n   \x3c!-- forest变量定义 结束 --\x3e\n\n    \x3c!-- SSL KeyStore定义 开始 --\x3e\n    <forest:ssl-keystore id="keystore1" file="test.keystore" keystorePass="123456" certPass="123456"/>\n    <forest:ssl-keystore id="keystore2" file="test2.keystore" keystorePass="foo" certPass="bar"/>\n    \x3c!-- SSL KeyStore定义 结束 --\x3e\n    \n    \x3c!-- Forest转换器定义 开始 --\x3e\n    \x3c!-- 设置JSON转换器 --\x3e\n    <forest:converter dataType="json" class="com.dtflys.forest.converter.json.ForestGsonConverter">\n        <forest:parameter name="dateFormat" value="yyyy/MM/dd hh:mm:ss"/>\n    </forest:converter>\n\n    \x3c!-- 设置XML转换器 --\x3e\n    <forest:converter dataType="xml" class="com.dtflys.forest.converter.xml.ForestJaxbConverter">\n    </forest:converter>\n    \x3c!-- Forest转换器定义 结束 --\x3e\n    \n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n 1. 使用forest:configuration标签创建在Spring中的ForestConfiguration Bean\n\n 2. 使用forest:var标签定义变量\n    \n    注意：变量的作用域为该ForestConfiguration之下，所有跟这个配置对象绑定的Client都能访问到其下的变量，而别的ForestConfiguration下定义的变量不能访问。\n\n# 创建Client Bean\n\n创建Client Bean有两种方式\n\n 1. 通过forest:client标签创建单个Client Bean\n\n   <forest:client id="siteAClient" configuration="config0" class="com.xxx.client.SiteAClient"/>\n\n\n1\n\n 2. 通过forest:scan标签制定back-package的方式批量创建Client Bean\n\n    <forest:scan configuration="config0" base-package="com.xxx.client"/>\n\n\n1\n',normalizedContent:'若您的项目依赖的是spring，而非spring boot，或者使用xml方式进行spring bean的配置，那么您可以通过spring xml的方式定义配置。\n\n\n# 依赖\n\n在进行spring方式配置前，需要先确保您的项目在maven中除了forest-core和spring外，还依赖forest-spring包\n\n <dependency>\n     <groupid>com.dtflys.forest</groupid>\n     <artifactid>forest-spring</artifactid>\n     <version>1.5.25</version>\n </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配置 xml scehema\n\n打开spring的上下文配置文件，在beans开头定义的属性中加入forest的schema\n\nxmlns:forest="http://forest.dtflyx.com/schema/forest" \n   ...\nxsi:schemalocation=" ...\nhttp://forest.dtflyx.com/schema/forest\nhttp://forest.dtflyx.com/schema/forest/forest-spring.xsd \n..."\n\n\n1\n2\n3\n4\n5\n6\n\n\n加入完成后类似如下效果\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:forest="http://forest.dtflyx.com/schema/forest"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://forest.dtflyx.com/schema/forest\n       http://forest.dtflyx.com/schema/forest/forest-spring.xsd">\n    \n   ...\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 添加forest基本配置的定义\n\n\x3c!-- forest 全局配置 --\x3e\n\x3c!-- id 在spring上下文中bean的id, 默认值为forestconfiguration --\x3e\n\x3c!-- backend 后端http api： okhttp3 --\x3e\n\x3c!-- timeout 请求超时时间，单位为毫秒, 默认值为3000 --\x3e\n\x3c!-- connecttimeout 连接超时时间，单位为毫秒, 默认值为2000 --\x3e\n\x3c!-- retrycount 请求失败后重试次数，默认为0次不重试 --\x3e\n\x3c!-- retryer 重试器类 --\x3e\n\x3c!-- sslprotocol 单向验证的https的默认ssl协议，默认为sslv3 --\x3e\n\x3c!-- maxconnections 每个路由的最大连接数，默认为500 --\x3e\n\x3c!-- maxrouteconnections 每个路由的最大连接数，默认为500 --\x3e\n\x3c!-- maxrequestqueuesize [自v1.5.22版本起可用] 最大请求等待队列大小 --\x3e\n\x3c!-- maxasyncthreadsize [自v1.5.21版本起可用] 最大异步线程数 --\x3e\n\x3c!-- maxasyncqueuesize [自v1.5.22版本起可用] 最大异步线程池队列大小 --\x3e\n\x3c!-- logenabled 打开或关闭日志总开关，默认为true --\x3e\n\x3c!-- logrequest 打开/关闭forest请求日志（默认为 true） --\x3e\n\x3c!-- logresponsestatus 打开/关闭forest响应状态日志（默认为 true） --\x3e\n\x3c!-- logresponsecontent 打开/关闭forest响应内容日志（默认为 false） --\x3e\n<forest:configuration\n    id="config0"\n    backend="httpclient"\n    timeout="30000"\n    connecttimeout="10000"\n    retrycount="3"\n    retryer="com.dtflys.forest.retryer.noneretryer"\n    charset="utf-8"\n    sslprotocol="sslv3"\n    maxconnections="500"\n    maxrouteconnections="500"\n    maxrequestqueuesize="100"\n    maxasyncthreadsize="256"\n    maxasyncqueuesize="128"\n    logenabled="true"\n    logrequest="false"\n    logresponsestatus="false"\n    logresponsecontent="true">\n\n   \x3c!-- forest变量定义 开始 --\x3e\n   <forest:var name="baseurl" value="http://www.xxx.com"/>\n   <forest:var name="x" value="0"/>\n   <forest:var name="y" value="1"/>\n   \x3c!-- forest变量定义 结束 --\x3e\n\n    \x3c!-- ssl keystore定义 开始 --\x3e\n    <forest:ssl-keystore id="keystore1" file="test.keystore" keystorepass="123456" certpass="123456"/>\n    <forest:ssl-keystore id="keystore2" file="test2.keystore" keystorepass="foo" certpass="bar"/>\n    \x3c!-- ssl keystore定义 结束 --\x3e\n    \n    \x3c!-- forest转换器定义 开始 --\x3e\n    \x3c!-- 设置json转换器 --\x3e\n    <forest:converter datatype="json" class="com.dtflys.forest.converter.json.forestgsonconverter">\n        <forest:parameter name="dateformat" value="yyyy/mm/dd hh:mm:ss"/>\n    </forest:converter>\n\n    \x3c!-- 设置xml转换器 --\x3e\n    <forest:converter datatype="xml" class="com.dtflys.forest.converter.xml.forestjaxbconverter">\n    </forest:converter>\n    \x3c!-- forest转换器定义 结束 --\x3e\n    \n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n 1. 使用forest:configuration标签创建在spring中的forestconfiguration bean\n\n 2. 使用forest:var标签定义变量\n    \n    注意：变量的作用域为该forestconfiguration之下，所有跟这个配置对象绑定的client都能访问到其下的变量，而别的forestconfiguration下定义的变量不能访问。\n\n# 创建client bean\n\n创建client bean有两种方式\n\n 1. 通过forest:client标签创建单个client bean\n\n   <forest:client id="siteaclient" configuration="config0" class="com.xxx.client.siteaclient"/>\n\n\n1\n\n 2. 通过forest:scan标签制定back-package的方式批量创建client bean\n\n    <forest:scan configuration="config0" base-package="com.xxx.client"/>\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🧱 构建接口",frontmatter:{id:"build_interface",title:"🧱 构建接口",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/build_interface/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/001.build_interface.html",relativePath:"001.v1.5.x文档/040.声明式接口/001.build_interface.md",key:"v-72d1cb9a",path:"/pages/1.5.x/build_interface/",headers:[{level:3,title:"简单请求",slug:"简单请求",normalizedTitle:"简单请求",charIndex:176},{level:3,title:"稍复杂点的请求",slug:"稍复杂点的请求",normalizedTitle:"稍复杂点的请求",charIndex:476}],headersStr:"简单请求 稍复杂点的请求",content:'在 Forest 依赖加入好之后，就可以构建 HTTP 请求的接口了。\n\n在 Forest 中，所有的 HTTP 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 HTTP 请求信息的接口方法，自动去执行 HTTP 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 HTTP 请求信息。\n\n\n# 简单请求\n\n创建一个interface，并用@Request注解修饰接口方法。\n\npublic interface MyClient {\n\n    @Request("http://localhost:8080/hello")\n    String simpleRequest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@Request注解，将上面的MyClient接口中的simpleRequest()方法绑定了一个 HTTP 请求， 其 URL 为http://localhost:8080/hello ，并默认使用GET方式，且将请求响应的数据以String的方式返回给调用者。\n\n\n# 稍复杂点的请求\n\npublic interface MyClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            headers = "Accept: text/plain"\n    )\n    String sendRequest(@Query("uname") String username);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的sendRequest方法绑定的 HTTP 请求，定义了 URL 信息，以及把Accept:text/plain加到了请求头中， 方法的参数String username绑定了注解@Query("uname")，它的作用是将调用者传入入参 username 时，自动将username的值加入到 HTTP 的请求参数uname中。\n\n如果调用方代码如下所示：\n\n@Resource\nMyClient myClient;\n\nmyClient.sendRequest("foo");\n\n\n1\n2\n3\n4\n\n\nMyClient myClient = Forest.client(MyClient.class);\n\nmyClient.sendRequest("foo");\n\n\n1\n2\n3\n\n\n这段调用所实际产生的 HTTP 请求如下：\n\nGET http://localhost:8080/hello/user?uname=foo\nHEADER:\n    Accept: text/plain\n',normalizedContent:'在 forest 依赖加入好之后，就可以构建 http 请求的接口了。\n\n在 forest 中，所有的 http 请求信息都要绑定到某一个接口的方法上，不需要编写具体的代码去发送请求。请求发送方通过调用事先定义好 http 请求信息的接口方法，自动去执行 http 发送请求的过程，其具体发送请求信息就是该方法对应绑定的 http 请求信息。\n\n\n# 简单请求\n\n创建一个interface，并用@request注解修饰接口方法。\n\npublic interface myclient {\n\n    @request("http://localhost:8080/hello")\n    string simplerequest();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过@request注解，将上面的myclient接口中的simplerequest()方法绑定了一个 http 请求， 其 url 为http://localhost:8080/hello ，并默认使用get方式，且将请求响应的数据以string的方式返回给调用者。\n\n\n# 稍复杂点的请求\n\npublic interface myclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user",\n            headers = "accept: text/plain"\n    )\n    string sendrequest(@query("uname") string username);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的sendrequest方法绑定的 http 请求，定义了 url 信息，以及把accept:text/plain加到了请求头中， 方法的参数string username绑定了注解@query("uname")，它的作用是将调用者传入入参 username 时，自动将username的值加入到 http 的请求参数uname中。\n\n如果调用方代码如下所示：\n\n@resource\nmyclient myclient;\n\nmyclient.sendrequest("foo");\n\n\n1\n2\n3\n4\n\n\nmyclient myclient = forest.client(myclient.class);\n\nmyclient.sendrequest("foo");\n\n\n1\n2\n3\n\n\n这段调用所实际产生的 http 请求如下：\n\nget http://localhost:8080/hello/user?uname=foo\nheader:\n    accept: text/plain\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎒 原生Java环境配置项",frontmatter:{id:"non_spring_boot_config",title:"🎒 原生Java环境配置项",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/java_config_items/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/030.%E9%85%8D%E7%BD%AE%E9%A1%B9/003.java_config_items.html",relativePath:"001.v1.5.x文档/030.配置项/003.java_config_items.md",key:"v-b12b9d52",path:"/pages/1.5.x/java_config_items/",headers:[{level:3,title:"创建 ForestConfiguration 对象",slug:"创建-forestconfiguration-对象",normalizedTitle:"创建 forestconfiguration 对象",charIndex:80},{level:3,title:"配置后端 HTTP API",slug:"配置后端-http-api",normalizedTitle:"配置后端 http api",charIndex:332},{level:3,title:"全局基本配置",slug:"全局基本配置",normalizedTitle:"全局基本配置",charIndex:156},{level:3,title:"全局变量定义",slug:"全局变量定义",normalizedTitle:"全局变量定义",charIndex:1410}],headersStr:"创建 ForestConfiguration 对象 配置后端 HTTP API 全局基本配置 全局变量定义",content:'若您的项目不是Spring Boot项目，或者没有依赖spring-boot-starter-forest，可以通过下面方式定义 Forest 配置。\n\n\n# 创建 ForestConfiguration 对象\n\nForestConfiguration为 Forest 的全局配置对象类，所有的 Forest 的全局基本配置信息由此类进行管理。\n\nForestConfiguration对象的创建方式：调用静态方法Forest.config()，此方法会创建/获取全局唯一的 ForestConfiguration 对象并初始化默认值。\n\nForestConfiguration configuration = Forest.config();\n\n\n1\n\n\n\n# 配置后端 HTTP API\n\nconfiguration.setBackendName("okhttp3");\n\n\n1\n\n\n目前 Forest 支持okhttp3和httpclient两种后端 HTTP API，若不配置该属性，默认为okhttp3。\n\n当然，您也可以改为httpclient\n\nconfiguration.setBackendName("httpclient");\n\n\n1\n\n\n\n# 全局基本配置\n\n// 连接池最大连接数，默认值为500\nconfiguration.setMaxConnections(123);\n// 每个路由的最大连接数，默认值为500\nconfiguration.setMaxRouteConnections(222);\n// [自v1.5.22版本起可用] 最大请求等待队列大小\nconfiguration.setMaxRequestQueueSize(100);\n// [自v1.5.21版本起可用] 最大异步线程数\nconfiguration.setMaxAsyncThreadSize(300);\n// [自v1.5.22版本起可用] 最大异步线程池队列大小\nconfiguration.setMaxAsyncQueueSize(16);\n// 请求超时时间，单位为毫秒, 默认值为3000\nconfiguration.setTimeout(3000);\n// 连接超时时间，单位为毫秒, 默认值为2000\nconfiguration.setConnectTimeout(2000);\n// 设置重试器\nconfiguration.setRetryer(BackOffRetryer.class);\n// 请求失败后重试次数，默认为0次不重试\nconfiguration.setMaxRetryCount(0);\n// 单向验证的HTTPS的默认SSL协议，默认为SSLv3\nconfiguration.setSslProtocol(SSLUtils.SSLv3);\n// 打开或关闭日志，默认为true\nconfiguration.setLogEnabled(true);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意\n\n * 这里setRetryCount只是简单机械的请求失败后的重试次数，所以一般建议设置为0。\n * 如果一定要多次重试，请一定要在保证服务端的幂等性的基础上进行重试，否则容易引发生产事故！\n\n\n# 全局变量定义\n\nForest 可以通过ForestConfiguration对象的setVariableValue方法自定义全局变量。\n\n其中第一个参数为变量名，第二个为变量值。\n\n全局变量可以在任何模板表达式中进行数据绑定。\n\nForestConfiguration configuration = ForestConfiguration.configuration();\n...\nconfiguration.setVariableValue("username", "foo");\nconfiguration.setVariableValue("userpwd", "bar");\n\n\n1\n2\n3\n4\n',normalizedContent:'若您的项目不是spring boot项目，或者没有依赖spring-boot-starter-forest，可以通过下面方式定义 forest 配置。\n\n\n# 创建 forestconfiguration 对象\n\nforestconfiguration为 forest 的全局配置对象类，所有的 forest 的全局基本配置信息由此类进行管理。\n\nforestconfiguration对象的创建方式：调用静态方法forest.config()，此方法会创建/获取全局唯一的 forestconfiguration 对象并初始化默认值。\n\nforestconfiguration configuration = forest.config();\n\n\n1\n\n\n\n# 配置后端 http api\n\nconfiguration.setbackendname("okhttp3");\n\n\n1\n\n\n目前 forest 支持okhttp3和httpclient两种后端 http api，若不配置该属性，默认为okhttp3。\n\n当然，您也可以改为httpclient\n\nconfiguration.setbackendname("httpclient");\n\n\n1\n\n\n\n# 全局基本配置\n\n// 连接池最大连接数，默认值为500\nconfiguration.setmaxconnections(123);\n// 每个路由的最大连接数，默认值为500\nconfiguration.setmaxrouteconnections(222);\n// [自v1.5.22版本起可用] 最大请求等待队列大小\nconfiguration.setmaxrequestqueuesize(100);\n// [自v1.5.21版本起可用] 最大异步线程数\nconfiguration.setmaxasyncthreadsize(300);\n// [自v1.5.22版本起可用] 最大异步线程池队列大小\nconfiguration.setmaxasyncqueuesize(16);\n// 请求超时时间，单位为毫秒, 默认值为3000\nconfiguration.settimeout(3000);\n// 连接超时时间，单位为毫秒, 默认值为2000\nconfiguration.setconnecttimeout(2000);\n// 设置重试器\nconfiguration.setretryer(backoffretryer.class);\n// 请求失败后重试次数，默认为0次不重试\nconfiguration.setmaxretrycount(0);\n// 单向验证的https的默认ssl协议，默认为sslv3\nconfiguration.setsslprotocol(sslutils.sslv3);\n// 打开或关闭日志，默认为true\nconfiguration.setlogenabled(true);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意\n\n * 这里setretrycount只是简单机械的请求失败后的重试次数，所以一般建议设置为0。\n * 如果一定要多次重试，请一定要在保证服务端的幂等性的基础上进行重试，否则容易引发生产事故！\n\n\n# 全局变量定义\n\nforest 可以通过forestconfiguration对象的setvariablevalue方法自定义全局变量。\n\n其中第一个参数为变量名，第二个为变量值。\n\n全局变量可以在任何模板表达式中进行数据绑定。\n\nforestconfiguration configuration = forestconfiguration.configuration();\n...\nconfiguration.setvariablevalue("username", "foo");\nconfiguration.setvariablevalue("userpwd", "bar");\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🍀 请求方法",frontmatter:{id:"http_method",title:"🍀 请求方法",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/http_method/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/002.http_method.html",relativePath:"001.v1.5.x文档/040.声明式接口/002.http_method.md",key:"v-10f1c410",path:"/pages/1.5.x/http_method/",headers:[{level:2,title:"GET 请求",slug:"get-请求",normalizedTitle:"get 请求",charIndex:517},{level:2,title:"POST 请求",slug:"post-请求",normalizedTitle:"post 请求",charIndex:688},{level:2,title:"PUT 请求",slug:"put-请求",normalizedTitle:"put 请求",charIndex:866},{level:2,title:"HEAD 请求",slug:"head-请求",normalizedTitle:"head 请求",charIndex:1037},{level:2,title:"DELETE 请求",slug:"delete-请求",normalizedTitle:"delete 请求",charIndex:1182},{level:2,title:"OPTIONS 请求",slug:"options-请求",normalizedTitle:"options 请求",charIndex:1374},{level:2,title:"OPTIONS 请求",slug:"options-请求-2",normalizedTitle:"options 请求",charIndex:1374},{level:2,title:"TRACE 请求",slug:"trace-请求",normalizedTitle:"trace 请求",charIndex:1772},{level:2,title:"PATCH 请求",slug:"patch-请求",normalizedTitle:"patch 请求",charIndex:1957},{level:2,title:"动态 HTTP 请求方法",slug:"动态-http-请求方法",normalizedTitle:"动态 http 请求方法",charIndex:2142}],headersStr:"GET 请求 POST 请求 PUT 请求 HEAD 请求 DELETE 请求 OPTIONS 请求 OPTIONS 请求 TRACE 请求 PATCH 请求 动态 HTTP 请求方法",content:'Forest 使用不同的请求注解来标识某个接口方法来进行发送不同类型的请求，其支持的HTTP方法如下表所示:\n\nHTTP 请求方法   请求注解                       描述\nGET         @Get、@GetRequest           获取资源\nPOST        @Post、@PostRequest         传输实体文本\nPUT         @Put、@PutRequest           上传资源\nHEAD        @HeadRequest               获取报文首部\nDELETE      @Delete、@DeleteRequest     删除资源\nOPTIONS     @Options、@OptionsRequest   询问支持的方法\nTRACE       @Trace、@TraceRequest       追踪路径\nPATCH       @Patch、@PatchRequest       更新资源的某一部分\n不定方法        @Request                   可动态传入HTTP方法\n\n\n# GET 请求\n\n使用@Get注解或@GetRequest注解\n\n@Get("http://localhost:8080/hello")\nString simpleGet1();\n\n@GetRequest("http://localhost:8080/hello")\nString simpleGet2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# POST 请求\n\n使用@Post注解或@PostRequest注解\n\n@Post("http://localhost:8080/hello")\nString simplePost1();\n\n@PostRequest("http://localhost:8080/hello")\nString simplePost2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# PUT 请求\n\n使用@Put注解或@PutRequest注解\n\n@Put("http://localhost:8080/hello")\nString simplePut1();\n\n@PutRequest("http://localhost:8080/hello")\nString simplePut2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# HEAD 请求\n\n使用@HeadRequest注解\n\n为了避免于@Header注解产生歧义和混淆，Forest 没有提供@Head注解\n\n@HeadRequest("http://localhost:8080/hello")\nString simpleHead();\n\n\n1\n2\n\n\n\n# DELETE 请求\n\n使用@Delete注解或@DeleteRequest注解\n\n@Delete("http://localhost:8080/hello")\nString simpleDelete1();\n\n@DeleteRequest("http://localhost:8080/hello")\nString simpleDelete2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# OPTIONS 请求\n\n使用@Options注解或@OptionsRequest注解\n\n@Options("http://localhost:8080/hello")\nString simpleOptions1();\n\n@OptionsRequest("http://localhost:8080/hello")\nString simpleOptions2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# OPTIONS 请求\n\n使用@Options注解或@OptionsRequest注解\n\n@Options("http://localhost:8080/hello")\nString simpleOptions1();\n\n@OptionsRequest("http://localhost:8080/hello")\nString simpleOptions2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# TRACE 请求\n\n使用@Trace注解或@TraceRequest注解\n\n@Trace("http://localhost:8080/hello")\nString simpleTrace1();\n\n@TraceRequest("http://localhost:8080/hello")\nString simpleTrace2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# PATCH 请求\n\n使用@Patch注解或@PatchRequest注解\n\n@Patch("http://localhost:8080/hello")\nString simplePatch1();\n\n@PatchRequest("http://localhost:8080/hello")\nString simplePatch2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# 动态 HTTP 请求方法\n\n若不想在接口定义的时候直接定死为某个具体的 HTTP 请求方法，而是想从全局变量或方法参数中动态传入\n\n可以使用 @Request 请求注解\n\n/**\n * 通过在 @Request 注解的 type 属性中定义字符串模板\n * 在字符串模板中引用方法的参数\n */\n@Request(\n    url = "http://localhost:8080/hello",\n    type = "{type}"\n)\nString simpleRequest(@Var("type") String type);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在调用改方法时通过参数传入 HTTP 请求方法类型（字符串类型，大小写不敏感）\n\n// POST 请求\nString result1 = simpleRequest("post");\n// DELETE 请求\nString result2 = simpleRequest("DELETE");\n\n\n1\n2\n3\n4\n',normalizedContent:'forest 使用不同的请求注解来标识某个接口方法来进行发送不同类型的请求，其支持的http方法如下表所示:\n\nhttp 请求方法   请求注解                       描述\nget         @get、@getrequest           获取资源\npost        @post、@postrequest         传输实体文本\nput         @put、@putrequest           上传资源\nhead        @headrequest               获取报文首部\ndelete      @delete、@deleterequest     删除资源\noptions     @options、@optionsrequest   询问支持的方法\ntrace       @trace、@tracerequest       追踪路径\npatch       @patch、@patchrequest       更新资源的某一部分\n不定方法        @request                   可动态传入http方法\n\n\n# get 请求\n\n使用@get注解或@getrequest注解\n\n@get("http://localhost:8080/hello")\nstring simpleget1();\n\n@getrequest("http://localhost:8080/hello")\nstring simpleget2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# post 请求\n\n使用@post注解或@postrequest注解\n\n@post("http://localhost:8080/hello")\nstring simplepost1();\n\n@postrequest("http://localhost:8080/hello")\nstring simplepost2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# put 请求\n\n使用@put注解或@putrequest注解\n\n@put("http://localhost:8080/hello")\nstring simpleput1();\n\n@putrequest("http://localhost:8080/hello")\nstring simpleput2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# head 请求\n\n使用@headrequest注解\n\n为了避免于@header注解产生歧义和混淆，forest 没有提供@head注解\n\n@headrequest("http://localhost:8080/hello")\nstring simplehead();\n\n\n1\n2\n\n\n\n# delete 请求\n\n使用@delete注解或@deleterequest注解\n\n@delete("http://localhost:8080/hello")\nstring simpledelete1();\n\n@deleterequest("http://localhost:8080/hello")\nstring simpledelete2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# options 请求\n\n使用@options注解或@optionsrequest注解\n\n@options("http://localhost:8080/hello")\nstring simpleoptions1();\n\n@optionsrequest("http://localhost:8080/hello")\nstring simpleoptions2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# options 请求\n\n使用@options注解或@optionsrequest注解\n\n@options("http://localhost:8080/hello")\nstring simpleoptions1();\n\n@optionsrequest("http://localhost:8080/hello")\nstring simpleoptions2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# trace 请求\n\n使用@trace注解或@tracerequest注解\n\n@trace("http://localhost:8080/hello")\nstring simpletrace1();\n\n@tracerequest("http://localhost:8080/hello")\nstring simpletrace2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# patch 请求\n\n使用@patch注解或@patchrequest注解\n\n@patch("http://localhost:8080/hello")\nstring simplepatch1();\n\n@patchrequest("http://localhost:8080/hello")\nstring simplepatch2();\n\n\n1\n2\n3\n4\n5\n\n\n\n# 动态 http 请求方法\n\n若不想在接口定义的时候直接定死为某个具体的 http 请求方法，而是想从全局变量或方法参数中动态传入\n\n可以使用 @request 请求注解\n\n/**\n * 通过在 @request 注解的 type 属性中定义字符串模板\n * 在字符串模板中引用方法的参数\n */\n@request(\n    url = "http://localhost:8080/hello",\n    type = "{type}"\n)\nstring simplerequest(@var("type") string type);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在调用改方法时通过参数传入 http 请求方法类型（字符串类型，大小写不敏感）\n\n// post 请求\nstring result1 = simplerequest("post");\n// delete 请求\nstring result2 = simplerequest("delete");\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"📚 配置优先级/作用域",frontmatter:{id:"config_level",title:"📚 配置优先级/作用域",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/config_level/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/030.%E9%85%8D%E7%BD%AE%E9%A1%B9/004.config_level.html",relativePath:"001.v1.5.x文档/030.配置项/004.config_level.md",key:"v-75bc8ce7",path:"/pages/1.5.x/config_level/",headersStr:null,content:"上面介绍的application.yml / application.properties配置以及通过ForestConfiguration对象设置的配置都是全局配置。\n\n除了全局配置，Forest 还提供了接口配置和请求配置。\n\n这三种配置的作用域和读取优先级各不相同。\n\n作用域： 配置作用域指的是配置所影响的请求范围。\n\n优先级： 优先级值的是是否优先读取该配置。比如您优先级最高@Request中定义了timeout为500，那么即便在全局配置中定了timeout为1000，最终该请求实际的timeout为优先级配置最高的@Request中定义的500。\n\n具体的配置层级如图所示：\n\nForest 的配置层级介绍：\n\n 1. 全局配置：针对全局所有请求，作用域最大，配置读取的优先级最小。\n\n 2. 接口配置： 作用域为某一个interface中定义的请求，读取的优先级最小。您可以通过在interface上修饰@BaseRequest注解进行配置。\n\n 3. 请求配置： 作用域为某一个具体的请求，读取的优先级最高。您可以在接口的方法上修饰@Request注解进行 HTTP 信息配置的定义。",normalizedContent:"上面介绍的application.yml / application.properties配置以及通过forestconfiguration对象设置的配置都是全局配置。\n\n除了全局配置，forest 还提供了接口配置和请求配置。\n\n这三种配置的作用域和读取优先级各不相同。\n\n作用域： 配置作用域指的是配置所影响的请求范围。\n\n优先级： 优先级值的是是否优先读取该配置。比如您优先级最高@request中定义了timeout为500，那么即便在全局配置中定了timeout为1000，最终该请求实际的timeout为优先级配置最高的@request中定义的500。\n\n具体的配置层级如图所示：\n\nforest 的配置层级介绍：\n\n 1. 全局配置：针对全局所有请求，作用域最大，配置读取的优先级最小。\n\n 2. 接口配置： 作用域为某一个interface中定义的请求，读取的优先级最小。您可以通过在interface上修饰@baserequest注解进行配置。\n\n 3. 请求配置： 作用域为某一个具体的请求，读取的优先级最高。您可以在接口的方法上修饰@request注解进行 http 信息配置的定义。",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🚚 请求地址",frontmatter:{id:"http_url",title:"🚚 请求地址",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/http_url/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/003.http_url.html",relativePath:"001.v1.5.x文档/040.声明式接口/003.http_url.md",key:"v-3f6f28e8",path:"/pages/1.5.x/http_url/",headers:[{level:2,title:"设置URL",slug:"设置url",normalizedTitle:"设置url",charIndex:66},{level:2,title:"URL结构",slug:"url结构",normalizedTitle:"url结构",charIndex:637},{level:2,title:"根地址",slug:"根地址",normalizedTitle:"根地址",charIndex:1094},{level:3,title:"@Address 注解",slug:"address-注解",normalizedTitle:"@address 注解",charIndex:1284},{level:3,title:"动态根地址",slug:"动态根地址",normalizedTitle:"动态根地址",charIndex:2243}],headersStr:"设置URL URL结构 根地址 @Address 注解 动态根地址",content:'HTTP请求可以没有请求头、请求体，但一定会有请求地址，即URL，以及很多请求的参数都是直接绑定在URL的Query部分上\n\n\n# 设置URL\n\n基本URL设置方法就如 《简单请求》 的例子所示，只要在url属性中填入完整的请求地址即可。\n\n除此之外，也可以通过 @Var 注解修饰的参数从外部动态传入URL:\n\n/**\n * 整个完整的URL都通过参数传入\n * {0}代表引用第一个参数\n */\n@Get("{0}")\nString send1(String myURL);\n\n/**\n * 整个完整的URL都通过 @Var 注解修饰的参数动态传入\n */\n@Get("{myURL}")\nString send2(@Var("myURL") String myURL);\n\n/**\n * 通过参数转入的值作为URL的一部分\n */\n@Get("http://{myURL}/abc")\nString send3(@Var("myURL") String myURL);\n\n/**\n * 参数转入的值可以作为URL的任意一部分\n */\n@Get("http://localhost:8080/test/{myURL}?a=1&b=2")\nString send4(@Var("myURL") String myURL);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# URL结构\n\n再继续介绍之后的Forest URL相关内容之前，我认为有必要先讲解下URL的标准结构 (已经对此非常了解的小伙伴可以跳过此节)\n\n一个标准的URL一般会包含以下几个部分：\n\n * 协议: 如URL的协议部分为http ，就代表请求使用的是HTTP协议\n * 域名: 如URL的域名部分为baidu.com，就代表请求域名地址为baidu.com，IP地址和主机名也可以当作域名一样使用\n * 端口号: 跟在域名后面的是端口，域名和端口之间使用:作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，HTTP协议请求将采用默认端口80，HTTPS则用默认端口443\n * 路径地址: 路径地址是从域名后的第一个/开始，一直到?为止的部分，如果没有?，则是从域名后的最后一个/开始到#为止的部分，如果没有？和#，那么从域名后的第一个/开始到结束，都是路径地址部分\n * 查询参数: 从？开始到#为止之间的部分为查询参数部分，又称搜索部分、查询部分\n * 锚: 从#开始到最后，都是锚部分\n\n\n# 根地址\n\n我们都知道，一个URL地址包含协议、站点地址(域名/IP地址/主机名)、端口号、路径地址、查询参数等几个部分。\n\n而协议、站点地址(域名/IP地址/主机名)、端口号这三部分称为根地址。\n\n但如果代码中大量URL接口都来自同一个站点，那就会存在两大重复的域名或IP地址，如果它们都以字符串形式散落在各个Forest请求接口方法的URL属性中，那就会变得难以维护。\n\n\n# @Address 注解\n\nForest 从1.5.3版本开始提供了 @Address 注解，帮助您将URL的地址部分提取出来，方便管理\n\n// 通过 @Address 注解绑定根地址\n// host 绑定到第一个参数， port 绑定到第二个参数\n@Post("/data")\n@Address(host = "{0}", port = "{1}")\nForestRequest<String> sendHostPort(String host, int port);\n\n// 若调用 sendHostPort("192.168.0.2", 8080);\n// 则最终产生URL:\n// http://192.168.0.2:8080/data\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n@Address 注解可以绑定到接口类上，根地址绑定返回就扩展到整个接口下的所有方法\n\n// 整个接口下的所有方法请求都默认绑定该根地址\n@Address(host = "127.0.0.1", port = "8080")\npublic interface MyClient {\n\n    // 绑定接口上的默认根地址\n    // 最终URL: http://127.0.0.1:8080/data1\n    @Post("/data1")\n    ForestRequest<String> sendData1();\n\n    // 绑定接口上的默认根地址\n    // 最终URL: http://127.0.0.1:8080/data2\n    @Post("/data2")\n    ForestRequest<String> sendData2();\n\n    // 使用方法上的根地址\n    // 最终URL: http://192.168.0.1:7000/data3\n    @Post("/data3")\n    @Address(host = "192.168.0.1", port = "7000")\n    ForestRequest<String> sendData3();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 动态根地址\n\n以上的方法虽然可以方便管理和批量配置多个请求的根地址，但如果想要实时动态地变更根地址就很困难\n\n比如：我想每次发送请求的时候，动态地从3个IP地址中随机选取一个作为根地址，该怎么做呢？\n\nForest 提供了地址来源接口，即AddressSource接口来帮您实现该功能\n\n// 实现 AddressSource 接口\npublic class MyAddressSource implements AddressSource {\n\n    @Override\n    public ForestAddress getAddress(ForestRequest request) {\n        // 定义 3 个 IP 地址\n        String[] ipArray = new String[] {\n                "192.168.0.1",\n                "192.168.0.2",\n                "192.168.0.3",\n        };\n        // 随机选出其中一个\n        Random random = new Random();\n        int i = random.nextInt(3);\n        String ip = ipArray[i];\n        // 返回 Forest 地址对象\n        return new ForestAddress(ip, 80);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n绑定自定义的AddressSource接口实现类\n\n// 也是通过 @Address 注解来绑定动态地址来源\n// 每次调用该方法，都可能是不同的根地址\n@Post("/data")\n@Address(source = MyAddressSource.class)\nForestRequest<String> sendData();\n\n\n1\n2\n3\n4\n5\n\n\n若连续调用多次sendData()，则每次请求的URL根地址都可能会不同\n\nmyClient.sendData(); // 第一次调用, URL: http://192.168.0.2/data\nmyClient.sendData(); // 第二次调用, URL: http://192.168.0.2/data\nmyClient.sendData(); // 第三次调用, URL: http://192.168.0.1/data\nmyClient.sendData(); // 第四次调用, URL: http://192.168.0.3/data\nmyClient.sendData(); // 第五次调用, URL: http://192.168.0.1/data\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'http请求可以没有请求头、请求体，但一定会有请求地址，即url，以及很多请求的参数都是直接绑定在url的query部分上\n\n\n# 设置url\n\n基本url设置方法就如 《简单请求》 的例子所示，只要在url属性中填入完整的请求地址即可。\n\n除此之外，也可以通过 @var 注解修饰的参数从外部动态传入url:\n\n/**\n * 整个完整的url都通过参数传入\n * {0}代表引用第一个参数\n */\n@get("{0}")\nstring send1(string myurl);\n\n/**\n * 整个完整的url都通过 @var 注解修饰的参数动态传入\n */\n@get("{myurl}")\nstring send2(@var("myurl") string myurl);\n\n/**\n * 通过参数转入的值作为url的一部分\n */\n@get("http://{myurl}/abc")\nstring send3(@var("myurl") string myurl);\n\n/**\n * 参数转入的值可以作为url的任意一部分\n */\n@get("http://localhost:8080/test/{myurl}?a=1&b=2")\nstring send4(@var("myurl") string myurl);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# url结构\n\n再继续介绍之后的forest url相关内容之前，我认为有必要先讲解下url的标准结构 (已经对此非常了解的小伙伴可以跳过此节)\n\n一个标准的url一般会包含以下几个部分：\n\n * 协议: 如url的协议部分为http ，就代表请求使用的是http协议\n * 域名: 如url的域名部分为baidu.com，就代表请求域名地址为baidu.com，ip地址和主机名也可以当作域名一样使用\n * 端口号: 跟在域名后面的是端口，域名和端口之间使用:作为分隔符。端口不是一个url必须的部分，如果省略端口部分，http协议请求将采用默认端口80，https则用默认端口443\n * 路径地址: 路径地址是从域名后的第一个/开始，一直到?为止的部分，如果没有?，则是从域名后的最后一个/开始到#为止的部分，如果没有？和#，那么从域名后的第一个/开始到结束，都是路径地址部分\n * 查询参数: 从？开始到#为止之间的部分为查询参数部分，又称搜索部分、查询部分\n * 锚: 从#开始到最后，都是锚部分\n\n\n# 根地址\n\n我们都知道，一个url地址包含协议、站点地址(域名/ip地址/主机名)、端口号、路径地址、查询参数等几个部分。\n\n而协议、站点地址(域名/ip地址/主机名)、端口号这三部分称为根地址。\n\n但如果代码中大量url接口都来自同一个站点，那就会存在两大重复的域名或ip地址，如果它们都以字符串形式散落在各个forest请求接口方法的url属性中，那就会变得难以维护。\n\n\n# @address 注解\n\nforest 从1.5.3版本开始提供了 @address 注解，帮助您将url的地址部分提取出来，方便管理\n\n// 通过 @address 注解绑定根地址\n// host 绑定到第一个参数， port 绑定到第二个参数\n@post("/data")\n@address(host = "{0}", port = "{1}")\nforestrequest<string> sendhostport(string host, int port);\n\n// 若调用 sendhostport("192.168.0.2", 8080);\n// 则最终产生url:\n// http://192.168.0.2:8080/data\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n@address 注解可以绑定到接口类上，根地址绑定返回就扩展到整个接口下的所有方法\n\n// 整个接口下的所有方法请求都默认绑定该根地址\n@address(host = "127.0.0.1", port = "8080")\npublic interface myclient {\n\n    // 绑定接口上的默认根地址\n    // 最终url: http://127.0.0.1:8080/data1\n    @post("/data1")\n    forestrequest<string> senddata1();\n\n    // 绑定接口上的默认根地址\n    // 最终url: http://127.0.0.1:8080/data2\n    @post("/data2")\n    forestrequest<string> senddata2();\n\n    // 使用方法上的根地址\n    // 最终url: http://192.168.0.1:7000/data3\n    @post("/data3")\n    @address(host = "192.168.0.1", port = "7000")\n    forestrequest<string> senddata3();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 动态根地址\n\n以上的方法虽然可以方便管理和批量配置多个请求的根地址，但如果想要实时动态地变更根地址就很困难\n\n比如：我想每次发送请求的时候，动态地从3个ip地址中随机选取一个作为根地址，该怎么做呢？\n\nforest 提供了地址来源接口，即addresssource接口来帮您实现该功能\n\n// 实现 addresssource 接口\npublic class myaddresssource implements addresssource {\n\n    @override\n    public forestaddress getaddress(forestrequest request) {\n        // 定义 3 个 ip 地址\n        string[] iparray = new string[] {\n                "192.168.0.1",\n                "192.168.0.2",\n                "192.168.0.3",\n        };\n        // 随机选出其中一个\n        random random = new random();\n        int i = random.nextint(3);\n        string ip = iparray[i];\n        // 返回 forest 地址对象\n        return new forestaddress(ip, 80);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n绑定自定义的addresssource接口实现类\n\n// 也是通过 @address 注解来绑定动态地址来源\n// 每次调用该方法，都可能是不同的根地址\n@post("/data")\n@address(source = myaddresssource.class)\nforestrequest<string> senddata();\n\n\n1\n2\n3\n4\n5\n\n\n若连续调用多次senddata()，则每次请求的url根地址都可能会不同\n\nmyclient.senddata(); // 第一次调用, url: http://192.168.0.2/data\nmyclient.senddata(); // 第二次调用, url: http://192.168.0.2/data\nmyclient.senddata(); // 第三次调用, url: http://192.168.0.1/data\nmyclient.senddata(); // 第四次调用, url: http://192.168.0.3/data\nmyclient.senddata(); // 第五次调用, url: http://192.168.0.1/data\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🎈 URL 参数",frontmatter:{title:"🎈 URL 参数",date:"2022-07-20T21:30:56.000Z",permalink:"/pages/http_query/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/004.http_query.html",relativePath:"001.v1.5.x文档/040.声明式接口/004.http_query.md",key:"v-304de9cc",path:"/pages/http_query/",headers:[{level:2,title:"字符串模板传参",slug:"字符串模板传参",normalizedTitle:"字符串模板传参",charIndex:141},{level:2,title:"@Query 注解",slug:"query-注解",normalizedTitle:"@query 注解",charIndex:1588},{level:2,title:"数组参数",slug:"数组参数",normalizedTitle:"数组参数",charIndex:2617},{level:2,title:"带 [] 的数组参数",slug:"带-的数组参数",normalizedTitle:"带 [] 的数组参数",charIndex:3098},{level:2,title:"带下标的数组参数",slug:"带下标的数组参数",normalizedTitle:"带下标的数组参数",charIndex:3384},{level:2,title:"JSON参数",slug:"json参数",normalizedTitle:"json参数",charIndex:3658}],headersStr:"字符串模板传参 @Query 注解 数组参数 带 [] 的数组参数 带下标的数组参数 JSON参数",content:'URL参数，也称为 URL 查询字符串，即跟在 URL 地址中?后面的那串字符串，可以用=表示一对键值对，多个键值对用&隔开，其可以作为 HTTP 请求的参数\n\n通过这些参数可以告诉服务端要做哪些事情，以及这些事相关的数据（简单数据，数据大小受到 URL 长度标准的限制）\n\n\n# 字符串模板传参\n\nHTTP的URL不光有协议名、域名、端口号等等基本信息，更为重要的是它能携带各种参数，称为Query参数，它通常包含参数名和参数值两部分。\n\nForest给URL的Query部分传参也有多种方式，其中最简洁直白的就数字符串拼接了。\n\n/**\n * 直接在url字符串的问号后面部分直接写上 参数名=参数值 的形式\n * 等号后面的参数值部分可以用 {参数序号} 这种字符串模板的形式替代\n * 在发送请求时会动态拼接成一个完整的URL\n * 使用这种形式不需要为参数定义额外的注解\n * \n * 注：参数序号是从 0 开始记的方法参数的序号\n * 0 代表第一个参数，1 代表第二个参数，以此类推\n */\n@Get("http://localhost:8080/abc?a={0}&b={1}&id=0")\nString send1(String a, String b);\n\n/**\n * 直接在url字符串的问号后面部分直接写上 参数名=参数值 的形式\n * 等号后面的参数值部分可以用 {变量名} 这种字符串模板的形式替代\n * 在发送请求时会动态拼接成一个完整的URL\n * 使用这种方式需要通过 @Var 注解或全局配置声明变量\n */\n@Get("http://localhost:8080/abc?a={a}&b={b}&id=0")\nString send2(@Var("a") String a, @Var("b") String b);\n\n\n/**\n * 如果一个一个变量包含多个Query参数，比如: "a=1&b=2&c=3"\n * 为变量 parameters 的字符串值\n * 就用 ${变量名} 这种字符串模板格式\n * 使用这种方式需要通过 @Var 注解或全局配置声明变量\n */\n@Get("http://localhost:8080/abc?${parameters}")\nString send3(@Var("parameters") String parameters);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n调用{参数序号}字符串模板的方法\n\n// 会对第二个参数 B&c=C 进行URL Encode\nmyClient.send1("A", "B&c=C");\n\n// 产生的URL为\n// http://localhost:8080/abc?a=A&b=B%26c%3DC&id=0\n\n\n1\n2\n3\n4\n5\n\n\n调用{变量名}字符串模板的方法\n\n// 会对第二个参数 B&c=C 进行URL Encode\nmyClient.send2("A", "B&c=C");\n\n// 产生的URL为\n// http://localhost:8080/abc?a=A&b=B%26c%3DC&id=0\n\n\n1\n2\n3\n4\n5\n\n\n调用${变量名}字符串模板的方法\n\n// 会用参数输入的字符串替换URL中的 ${parameters} 部分\nmyClient.send3("a=A&b=B&c=C");\n\n// 产生的URL为\n// http://localhost:8080/abc?a=A&b=B&c=C\n\n\n1\n2\n3\n4\n5\n\n\n文档导航\n\n关于字符串模板的详细用法，请参见《模板表达式》\n\n\n# @Query 注解\n\n但把所有Query参数直接写在url属性的字符串里面是不是也太简单粗暴了，有没有优雅点的方式？有的。\n\n\n/**\n * 使用 @Query 注解，可以直接将该注解修饰的参数动态绑定到请求url中\n * 注解的 value 值即代表它在url的Query部分的参数名\n */\n@Get("http://localhost:8080/abc?id=0")\nString send(@Query("a") String a, @Query("b") String b);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n友情提示\n\n@Query 注解修饰的参数一定会出现在 URL 中。\n\n若是要传的URL参数太多了呢？难道要我在方法上定义十几二十个@Query修饰的参数？那也太难看了吧。别急，Forest还是有办法让您变的代码变得优雅的。\n\n\n/**\n * 使用 @Query 注解，可以修饰 Map 类型的参数\n * 很自然的，Map 的 Key 将作为 URL 的参数名， Value 将作为 URL 的参数值\n * 这时候 @Query 注解不定义名称\n */\n@Get("http://localhost:8080/abc?id=0")\nString send1(@Query Map<String, Object> map);\n\n\n/**\n * @Query 注解也可以修饰自定义类型的对象参数\n * 依据对象类的 Getter 和 Setter 的规则取出属性\n * 其属性名为 URL 参数名，属性值为 URL 参数值\n * 这时候 @Query 注解不定义名称\n */\n@Get("http://localhost:8080/abc?id=0")\nString send2(@Query UserInfo user);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n是不是瞬间简洁不少，但用@Query注解绑定参数的时候也有需要注意的地方：\n\n注意\n\n * (1) 需要单个单个定义 参数名=参数值 的时候，@Query注解的value值一定要有，比如 @Query("name") String name\n\n * (2) 需要绑定对象的时候，@Query注解的value值一定要空着，比如 @Query User user 或 @Query Map map\n\n\n# 数组参数\n\n有些时候，需要通过URL参数传递一个数组或者一个列表\n\n列表类型参数\n\n/*\n * 接受列表参数为URL查询参数\n */\n@Get("http://localhost:8080/abc")\nString send1(@Query("id") List idList);\n\n\n1\n2\n3\n4\n5\n\n\n若调用 send1(Arrays.asList(1, 2, 3, 4))\n\n则产生的最终URL为\n\nhttp://localhost:8080/abc?id=1&id=2&id=3&id=4\n\n\n1\n\n\n数组类型参数\n\n/*\n * 接受数组参数为URL查询参数\n */\n@Get("http://localhost:8080/abc")\nString send2(@Query("id") int[] idList);\n\n\n1\n2\n3\n4\n5\n\n\n若调用 send2(new int[] {1, 2, 3, 4})\n\n则产生的最终URL为\n\nhttp://localhost:8080/abc?id=1&id=2&id=3&id=4\n\n\n1\n\n\n\n# 带 [] 的数组参数\n\n有些场景用带方括号([])的参数名来表示数组类型的 Query 参数\n\n/*\n * 在 @Query 注解的参数名后跟上 [] 即可\n */\n@Get("http://localhost:8080/abc")\nString send(@Query("id[]") int[] idList);\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n若调用 send2(new int[] {1, 2, 3, 4})\n\n则产生的最终URL为\n\nhttp://localhost:8080/abc?id[]=1&id[]=2&id[]=3&id[]=4\n\n\n1\n\n\n\n# 带下标的数组参数\n\n在字符串模板中引用内置变量_index\n\n/*\n * 内置变量 _index 代表数组的下标\n */\n@Get("http://localhost:8080/abc")\nString send(@Query("id[${_index}]") int[] idList);\n\n\n1\n2\n3\n4\n5\n\n\n若调用 send2(new int[] {1, 2, 3, 4})\n\n则产生的最终URL为\n\nhttp://localhost:8080/abc?id[0]=1&id[1]=2&id[2]=3&id[3]=4\n\n\n1\n\n\n\n# JSON参数\n\n如果不想以URL参数的标准格式传递列表或者数组，JSON字符串也是一种选择\n\n这时，可以使用@JSONQuery注解\n\n@Get("http://localhost:8080/abc")\nString send(@JSONQuery("id") List idList);\n\n\n1\n2\n\n\n若调用 send(Arrays.asList(1, 2, 3, 4))\n\n则产生的最终URL为\n\nhttp://localhost:8080/abc?id=[1, 2, 3, 4]\n\n\n1\n',normalizedContent:'url参数，也称为 url 查询字符串，即跟在 url 地址中?后面的那串字符串，可以用=表示一对键值对，多个键值对用&隔开，其可以作为 http 请求的参数\n\n通过这些参数可以告诉服务端要做哪些事情，以及这些事相关的数据（简单数据，数据大小受到 url 长度标准的限制）\n\n\n# 字符串模板传参\n\nhttp的url不光有协议名、域名、端口号等等基本信息，更为重要的是它能携带各种参数，称为query参数，它通常包含参数名和参数值两部分。\n\nforest给url的query部分传参也有多种方式，其中最简洁直白的就数字符串拼接了。\n\n/**\n * 直接在url字符串的问号后面部分直接写上 参数名=参数值 的形式\n * 等号后面的参数值部分可以用 {参数序号} 这种字符串模板的形式替代\n * 在发送请求时会动态拼接成一个完整的url\n * 使用这种形式不需要为参数定义额外的注解\n * \n * 注：参数序号是从 0 开始记的方法参数的序号\n * 0 代表第一个参数，1 代表第二个参数，以此类推\n */\n@get("http://localhost:8080/abc?a={0}&b={1}&id=0")\nstring send1(string a, string b);\n\n/**\n * 直接在url字符串的问号后面部分直接写上 参数名=参数值 的形式\n * 等号后面的参数值部分可以用 {变量名} 这种字符串模板的形式替代\n * 在发送请求时会动态拼接成一个完整的url\n * 使用这种方式需要通过 @var 注解或全局配置声明变量\n */\n@get("http://localhost:8080/abc?a={a}&b={b}&id=0")\nstring send2(@var("a") string a, @var("b") string b);\n\n\n/**\n * 如果一个一个变量包含多个query参数，比如: "a=1&b=2&c=3"\n * 为变量 parameters 的字符串值\n * 就用 ${变量名} 这种字符串模板格式\n * 使用这种方式需要通过 @var 注解或全局配置声明变量\n */\n@get("http://localhost:8080/abc?${parameters}")\nstring send3(@var("parameters") string parameters);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n调用{参数序号}字符串模板的方法\n\n// 会对第二个参数 b&c=c 进行url encode\nmyclient.send1("a", "b&c=c");\n\n// 产生的url为\n// http://localhost:8080/abc?a=a&b=b%26c%3dc&id=0\n\n\n1\n2\n3\n4\n5\n\n\n调用{变量名}字符串模板的方法\n\n// 会对第二个参数 b&c=c 进行url encode\nmyclient.send2("a", "b&c=c");\n\n// 产生的url为\n// http://localhost:8080/abc?a=a&b=b%26c%3dc&id=0\n\n\n1\n2\n3\n4\n5\n\n\n调用${变量名}字符串模板的方法\n\n// 会用参数输入的字符串替换url中的 ${parameters} 部分\nmyclient.send3("a=a&b=b&c=c");\n\n// 产生的url为\n// http://localhost:8080/abc?a=a&b=b&c=c\n\n\n1\n2\n3\n4\n5\n\n\n文档导航\n\n关于字符串模板的详细用法，请参见《模板表达式》\n\n\n# @query 注解\n\n但把所有query参数直接写在url属性的字符串里面是不是也太简单粗暴了，有没有优雅点的方式？有的。\n\n\n/**\n * 使用 @query 注解，可以直接将该注解修饰的参数动态绑定到请求url中\n * 注解的 value 值即代表它在url的query部分的参数名\n */\n@get("http://localhost:8080/abc?id=0")\nstring send(@query("a") string a, @query("b") string b);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n友情提示\n\n@query 注解修饰的参数一定会出现在 url 中。\n\n若是要传的url参数太多了呢？难道要我在方法上定义十几二十个@query修饰的参数？那也太难看了吧。别急，forest还是有办法让您变的代码变得优雅的。\n\n\n/**\n * 使用 @query 注解，可以修饰 map 类型的参数\n * 很自然的，map 的 key 将作为 url 的参数名， value 将作为 url 的参数值\n * 这时候 @query 注解不定义名称\n */\n@get("http://localhost:8080/abc?id=0")\nstring send1(@query map<string, object> map);\n\n\n/**\n * @query 注解也可以修饰自定义类型的对象参数\n * 依据对象类的 getter 和 setter 的规则取出属性\n * 其属性名为 url 参数名，属性值为 url 参数值\n * 这时候 @query 注解不定义名称\n */\n@get("http://localhost:8080/abc?id=0")\nstring send2(@query userinfo user);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n是不是瞬间简洁不少，但用@query注解绑定参数的时候也有需要注意的地方：\n\n注意\n\n * (1) 需要单个单个定义 参数名=参数值 的时候，@query注解的value值一定要有，比如 @query("name") string name\n\n * (2) 需要绑定对象的时候，@query注解的value值一定要空着，比如 @query user user 或 @query map map\n\n\n# 数组参数\n\n有些时候，需要通过url参数传递一个数组或者一个列表\n\n列表类型参数\n\n/*\n * 接受列表参数为url查询参数\n */\n@get("http://localhost:8080/abc")\nstring send1(@query("id") list idlist);\n\n\n1\n2\n3\n4\n5\n\n\n若调用 send1(arrays.aslist(1, 2, 3, 4))\n\n则产生的最终url为\n\nhttp://localhost:8080/abc?id=1&id=2&id=3&id=4\n\n\n1\n\n\n数组类型参数\n\n/*\n * 接受数组参数为url查询参数\n */\n@get("http://localhost:8080/abc")\nstring send2(@query("id") int[] idlist);\n\n\n1\n2\n3\n4\n5\n\n\n若调用 send2(new int[] {1, 2, 3, 4})\n\n则产生的最终url为\n\nhttp://localhost:8080/abc?id=1&id=2&id=3&id=4\n\n\n1\n\n\n\n# 带 [] 的数组参数\n\n有些场景用带方括号([])的参数名来表示数组类型的 query 参数\n\n/*\n * 在 @query 注解的参数名后跟上 [] 即可\n */\n@get("http://localhost:8080/abc")\nstring send(@query("id[]") int[] idlist);\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n若调用 send2(new int[] {1, 2, 3, 4})\n\n则产生的最终url为\n\nhttp://localhost:8080/abc?id[]=1&id[]=2&id[]=3&id[]=4\n\n\n1\n\n\n\n# 带下标的数组参数\n\n在字符串模板中引用内置变量_index\n\n/*\n * 内置变量 _index 代表数组的下标\n */\n@get("http://localhost:8080/abc")\nstring send(@query("id[${_index}]") int[] idlist);\n\n\n1\n2\n3\n4\n5\n\n\n若调用 send2(new int[] {1, 2, 3, 4})\n\n则产生的最终url为\n\nhttp://localhost:8080/abc?id[0]=1&id[1]=2&id[2]=3&id[3]=4\n\n\n1\n\n\n\n# json参数\n\n如果不想以url参数的标准格式传递列表或者数组，json字符串也是一种选择\n\n这时，可以使用@jsonquery注解\n\n@get("http://localhost:8080/abc")\nstring send(@jsonquery("id") list idlist);\n\n\n1\n2\n\n\n若调用 send(arrays.aslist(1, 2, 3, 4))\n\n则产生的最终url为\n\nhttp://localhost:8080/abc?id=[1, 2, 3, 4]\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍭 请求头",frontmatter:{id:"http_header",title:"🍭 请求头",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/http_header/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/005.http_header.html",relativePath:"001.v1.5.x文档/040.声明式接口/005.http_header.md",key:"v-67914a1a",path:"/pages/1.5.x/http_header/",headers:[{level:3,title:"headers属性",slug:"headers属性",normalizedTitle:"headers属性",charIndex:34},{level:3,title:"@Header 注解",slug:"header-注解",normalizedTitle:"@header 注解",charIndex:1243}],headersStr:"headers属性 @Header 注解",content:'在《构建接口》的例子中，我们已经知道了可以通过@Request注解的headers属性设置一条 HTTP 请求头。\n\n现在我们来看看如何添加多条请求头。\n\n\n# headers属性\n\n其中headers属性接受的是一个字符串数组，在接受多个请求头信息时以以下形式填入请求头：\n\n{\n    "请求头名称1: 请求头值1",\n    "请求头名称2: 请求头值2",\n    "请求头名称3: 请求头值3",\n    ...\n }\n\n\n1\n2\n3\n4\n5\n6\n\n\n其中组数每一项都是一个字符串，每个字符串代表一个请求头。请求头的名称和值用:分割。\n\n具体代码请看如下示例：\n\npublic interface MyClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            headers = {\n                "Accept-Charset: utf-8",\n                "Content-Type: text/plain"\n            }\n    )\n    String multipleHeaders();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n该接口调用后所实际产生的 HTTP 请求如下：\n\nGET http://localhost:8080/hello/user\nHEADER:\n    Accept-Charset: utf-8\n    Content-Type: text/plain\n\n\n如果要每次请求传入不同的请求头内容，可以在headers属性的请求头定义中加入数据绑定。\n\npublic interface MyClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            headers = {\n                "Accept-Charset: ${encoding}",\n                "Content-Type: text/plain"\n            }\n    )\n    String bindingHeader(@Var("encoding") String encoding);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果调用方代码如下所示：\n\nmyClient.bindingHeader("gbk");\n\n\n1\n\n\n这段调用所实际产生的 HTTP 请求如下：\n\nGET http://localhost:8080/hello/user\nHEADER:\n    Accept-Charset: gbk\n    Content-Type: text/plain\n\n\n\n# @Header 注解\n\n想必大家都已经了解通过 headers 属性设置请求头的方法了。不过这种方式虽然直观，但如要没通过参数传入到请求头中就显得比较啰嗦了。\n\n所以Forest还提供了 @Header 注解来帮助您把方法的参数直接绑定到请求体中。\n\n\n/**\n * 使用 @Header 注解将参数绑定到请求头上\n * @Header 注解的 value 指为请求头的名称，参数值为请求头的值\n * @Header("Accept") String accept将字符串类型参数绑定到请求头 Accept 上\n * @Header("accessToken") String accessToken将字符串类型参数绑定到请求头 accessToken 上\n */\n@Post("http://localhost:8080/hello/user?username=foo")\nvoid postUser(@Header("Accept") String accept, @Header("accessToken") String accessToken);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果有很多很多的请求头要通过参数传入，我需要定义很多很多参数吗？当然不用！\n\n/**\n * 使用 @Header 注解可以修饰 Map 类型的参数\n * Map 的 Key 指为请求头的名称，Value 为请求头的值\n * 通过此方式，可以将 Map 中所有的键值对批量地绑定到请求头中\n */\n@Post("http://localhost:8080/hello/user?username=foo")\nvoid headHelloUser(@Header Map<String, Object> headerMap);\n\n\n/**\n * 使用 @Header 注解可以修饰自定义类型的对象参数\n * 依据对象类的 Getter 和 Setter 的规则取出属性\n * 其属性名为 URL 请求头的名称，属性值为请求头的值\n * 以此方式，将一个对象中的所有属性批量地绑定到请求头中\n */\n@Post("http://localhost:8080/hello/user?username=foo")\nvoid headHelloUser(@Header MyHeaderInfo headersInfo);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n注意\n\n * (1) 需要单个单个定义请求头的时候，@Header注解的value值一定要有，比如 @Header("Content-Type") String contentType\n\n * (2) 需要绑定对象的时候，@Header注解的value值一定要空着，比如 @Header MyHeaders headers 或 @Header Map headerMap',normalizedContent:'在《构建接口》的例子中，我们已经知道了可以通过@request注解的headers属性设置一条 http 请求头。\n\n现在我们来看看如何添加多条请求头。\n\n\n# headers属性\n\n其中headers属性接受的是一个字符串数组，在接受多个请求头信息时以以下形式填入请求头：\n\n{\n    "请求头名称1: 请求头值1",\n    "请求头名称2: 请求头值2",\n    "请求头名称3: 请求头值3",\n    ...\n }\n\n\n1\n2\n3\n4\n5\n6\n\n\n其中组数每一项都是一个字符串，每个字符串代表一个请求头。请求头的名称和值用:分割。\n\n具体代码请看如下示例：\n\npublic interface myclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user",\n            headers = {\n                "accept-charset: utf-8",\n                "content-type: text/plain"\n            }\n    )\n    string multipleheaders();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n该接口调用后所实际产生的 http 请求如下：\n\nget http://localhost:8080/hello/user\nheader:\n    accept-charset: utf-8\n    content-type: text/plain\n\n\n如果要每次请求传入不同的请求头内容，可以在headers属性的请求头定义中加入数据绑定。\n\npublic interface myclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user",\n            headers = {\n                "accept-charset: ${encoding}",\n                "content-type: text/plain"\n            }\n    )\n    string bindingheader(@var("encoding") string encoding);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果调用方代码如下所示：\n\nmyclient.bindingheader("gbk");\n\n\n1\n\n\n这段调用所实际产生的 http 请求如下：\n\nget http://localhost:8080/hello/user\nheader:\n    accept-charset: gbk\n    content-type: text/plain\n\n\n\n# @header 注解\n\n想必大家都已经了解通过 headers 属性设置请求头的方法了。不过这种方式虽然直观，但如要没通过参数传入到请求头中就显得比较啰嗦了。\n\n所以forest还提供了 @header 注解来帮助您把方法的参数直接绑定到请求体中。\n\n\n/**\n * 使用 @header 注解将参数绑定到请求头上\n * @header 注解的 value 指为请求头的名称，参数值为请求头的值\n * @header("accept") string accept将字符串类型参数绑定到请求头 accept 上\n * @header("accesstoken") string accesstoken将字符串类型参数绑定到请求头 accesstoken 上\n */\n@post("http://localhost:8080/hello/user?username=foo")\nvoid postuser(@header("accept") string accept, @header("accesstoken") string accesstoken);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果有很多很多的请求头要通过参数传入，我需要定义很多很多参数吗？当然不用！\n\n/**\n * 使用 @header 注解可以修饰 map 类型的参数\n * map 的 key 指为请求头的名称，value 为请求头的值\n * 通过此方式，可以将 map 中所有的键值对批量地绑定到请求头中\n */\n@post("http://localhost:8080/hello/user?username=foo")\nvoid headhellouser(@header map<string, object> headermap);\n\n\n/**\n * 使用 @header 注解可以修饰自定义类型的对象参数\n * 依据对象类的 getter 和 setter 的规则取出属性\n * 其属性名为 url 请求头的名称，属性值为请求头的值\n * 以此方式，将一个对象中的所有属性批量地绑定到请求头中\n */\n@post("http://localhost:8080/hello/user?username=foo")\nvoid headhellouser(@header myheaderinfo headersinfo);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n注意\n\n * (1) 需要单个单个定义请求头的时候，@header注解的value值一定要有，比如 @header("content-type") string contenttype\n\n * (2) 需要绑定对象的时候，@header注解的value值一定要空着，比如 @header myheaders headers 或 @header map headermap',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"👔 请求体",frontmatter:{id:"http_body",title:"👔 请求体",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/http_body/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/006.http_body.html",relativePath:"001.v1.5.x文档/040.声明式接口/006.http_body.md",key:"v-87ea91a4",path:"/pages/1.5.x/http_body/",headers:[{level:2,title:"@Body 注解",slug:"body-注解",normalizedTitle:"@body 注解",charIndex:64},{level:2,title:"表单格式",slug:"表单格式",normalizedTitle:"表单格式",charIndex:364},{level:2,title:"JSON格式",slug:"json格式",normalizedTitle:"json格式",charIndex:1677},{level:3,title:"@JSONBody注解修饰对象",slug:"jsonbody注解修饰对象",normalizedTitle:"@jsonbody注解修饰对象",charIndex:1688},{level:3,title:"@JSONBody注解修饰键值对",slug:"jsonbody注解修饰键值对",normalizedTitle:"@jsonbody注解修饰键值对",charIndex:2179},{level:3,title:"@JSONBody注解修饰集合对象",slug:"jsonbody注解修饰集合对象",normalizedTitle:"@jsonbody注解修饰集合对象",charIndex:2665},{level:3,title:"@JSONBody注解修饰字符串",slug:"jsonbody注解修饰字符串",normalizedTitle:"@jsonbody注解修饰字符串",charIndex:3576},{level:3,title:"@Body注解 + contentType",slug:"body注解-contenttype",normalizedTitle:"@body注解 + contenttype",charIndex:3766},{level:2,title:"XML格式",slug:"xml格式",normalizedTitle:"xml格式",charIndex:4165},{level:3,title:"@XMLBody注解修饰对象",slug:"xmlbody注解修饰对象",normalizedTitle:"@xmlbody注解修饰对象",charIndex:4175},{level:3,title:"@XMLBody注解修饰字符串",slug:"xmlbody注解修饰字符串",normalizedTitle:"@xmlbody注解修饰字符串",charIndex:5176},{level:2,title:"Protobuf格式",slug:"protobuf格式",normalizedTitle:"protobuf格式",charIndex:5378},{level:2,title:"二进制格式",slug:"二进制格式",normalizedTitle:"二进制格式",charIndex:6157},{level:2,title:"data 属性",slug:"data-属性",normalizedTitle:"data 属性",charIndex:7009},{level:2,title:"请求体类型",slug:"请求体类型",normalizedTitle:"请求体类型",charIndex:10035},{level:3,title:"@BodyType 注解",slug:"bodytype-注解",normalizedTitle:"@bodytype 注解",charIndex:10756},{level:3,title:"可指定的请求体类型",slug:"可指定的请求体类型",normalizedTitle:"可指定的请求体类型",charIndex:11546},{level:3,title:"指定 Encoder",slug:"指定-encoder",normalizedTitle:"指定 encoder",charIndex:11851},{level:3,title:"JSON 编码器快捷注解",slug:"json-编码器快捷注解",normalizedTitle:"json 编码器快捷注解",charIndex:12131}],headersStr:"@Body 注解 表单格式 JSON格式 @JSONBody注解修饰对象 @JSONBody注解修饰键值对 @JSONBody注解修饰集合对象 @JSONBody注解修饰字符串 @Body注解 + contentType XML格式 @XMLBody注解修饰对象 @XMLBody注解修饰字符串 Protobuf格式 二进制格式 data 属性 请求体类型 @BodyType 注解 可指定的请求体类型 指定 Encoder JSON 编码器快捷注解",content:'在POST和PUT等请求方法中，通常使用 HTTP 请求体进行传输数据。在 Forest 中有多种方式设置请求体数据。\n\n\n# @Body 注解\n\n您可以使用@Body注解修饰参数的方式，将传入参数的数据绑定到 HTTP 请求体中。\n\n@Body注解修饰的参数一定会绑定到请求体中，不用担心它会出现在其他地方\n\n/**\n * 默认body格式为 application/x-www-form-urlencoded，即以表单形式序列化数据\n */\n@Post("http://localhost:8080/user")\nString sendPost(@Body("username") String username,  @Body("password") String password);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 表单格式\n\n上面使用 @Body 注解的例子用的是普通的表单格式，也就是contentType属性为application/x-www-form-urlencoded的格式，即contentType不做配置时的默认值。\n\n表单格式的请求体以字符串 key1=value1&key2=value2&...&key{n}=value{n} 的形式进行传输数据，其中value都是已经过 URL Encode 编码过的字符串。\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n/**\n * contentType属性设置为 application/x-www-form-urlencoded 即为表单格式，\n * 当然不设置的时候默认值也为 application/x-www-form-urlencoded， 也同样是表单格式。\n * 在 @Body 注解的 value 属性中设置的名称为表单项的 key 名，\n * 而注解所修饰的参数值即为表单项的值，它可以为任何类型，不过最终都会转换为字符串进行传输。\n */\n@Post(\n    url = "http://localhost:8080/user",\n    contentType = "application/x-www-form-urlencoded"\n)\nString sendPost(@Body("key1") String value1,  @Body("key2") Integer value2, @Body("key3") Long value3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用后产生的结果可能如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/x-www-form-urlencoded\nBODY:\n    key1=xxx&key2=1000&key3=9999\n\n\n当@Body注解修饰的参数为一个对象，并注解的value属性不设置任何名称的时候，会将注解所修饰参数值对象视为一整个表单，其对象中的所有属性将按 属性名1=属性值1&属性名2=属性值2&...&属性名{n}=属性值{n} 的形式通过请求体进行传输数据。\n\n/**\n * contentType 属性不设置默认为 application/x-www-form-urlencoded\n * 要以对象作为表达传输项时，其 @Body 注解的 value 名称不能设置\n */\n@Post("http://localhost:8080/hello/user")\nString send(@Body User user);\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用后产生的结果如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/x-www-form-urlencoded\nBODY:\n    username=foo&password=bar\n\n\n\n# JSON格式\n\n\n# @JSONBody注解修饰对象\n\n发送JSON非常简单，只要用@JSONBody注解修饰相关参数就可以了，该注解自1.5.0-RC1版本起可以使用。 使用@JSONBody注解的同时就可以省略 contentType = "application/json"属性设置。\n\n/**\n * 被@JSONBody注解修饰的参数会根据其类型被自定解析为JSON字符串\n * 使用@JSONBody注解时可以省略 contentType = "application/json"属性设置\n */\n@Post("http://localhost:8080/hello/user")\nString helloUser(@JSONBody User user);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用后产生的结果如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    {"username": "foo", "password": "bar"}\n\n\n\n# @JSONBody注解修饰键值对\n\n@JSONBody注解可以按键值对拆分成多个参数进行传入，在发送的时候再合成一个完成的JSON字符串：\n\n\n/**\n * 按键值对分别修饰不同的参数\n * 这时每个参数前的 @JSONBody 注解必须填上 value 属性或 name 属性的值，作为JSON的字段名称\n */\n@Post("http://localhost:8080/hello/user")\nString helloUser(@JSONBody("username") String username, @JSONBody("password") String password);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如调用helloUser("foo", "bar");会产生如下结果：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    {"username": "foo", "password": "bar"}\n\n\n\n# @JSONBody注解修饰集合对象\n\n@JSONBody注解也支持Map、List等集合类型参数\n\n/**\n * 被@JSONBody注解修饰的Map类型参数会被自定解析为JSON字符串\n */\n@Post(url = "http://localhost:8080/hello/user")\nString helloUser(@JSONBody Map<String, Object> user);\n\n\n1\n2\n3\n4\n5\n\n\n若调用代码如下：\n\nMap<String, Object> map = new HashMap<>();\nmap.put("name", "foo");\nmap.put("password", "bar");\nclient.helloUser(map);\n\n\n1\n2\n3\n4\n\n\n会产生如下结果：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    {"username": "foo", "password": "bar"}\n\n\nList等列表对象也同理：\n\n/**\n * 被@JSONBody注解修饰的List类型参数会被自定解析为JSON字符串\n */\n@Post(url = "http://localhost:8080/hello/user-names")\nString helloUserNames(@JSONBody List<String> usernames);\n\n\n1\n2\n3\n4\n5\n\n\n若调用代码如下：\n\nList<String> names = Lists.newArrayList("A", "B", "C");\nclient.helloUserNames(names);\n\n\n1\n2\n\n\n会产生如下结果：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    ["A", "B", "C"]\n\n\n\n# @JSONBody注解修饰字符串\n\n@JSONBody注解还支持字符串类型参数，可以直接传入一个JSON字符串进行传输\n\n/**\n * 直接修饰一个JSON字符串\n */\n@Post("http://localhost:8080/hello/user")\nString helloUser(@JSONBody String userJson);\n\n\n1\n2\n3\n4\n5\n\n\n\n# @Body注解 + contentType\n\n除了@JSONBody注解，使用@Body注解也可以，只要将contentType属性或Content-Type请求头指定为application/json便可。\n\n\n\n\n \n\n\n\n\n@Post(\n    url = "http://localhost:8080/hello/user",\n    contentType = "application/json"\n)\nString send(@Body User user);\n\n\n1\n2\n3\n4\n5\n\n\n调用后产生的结果如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    {"username": "foo", "password": "bar"}\n\n\n\n# XML格式\n\n\n# @XMLBody注解修饰对象\n\n发送XML也非常简单，只要用@XMLBody注解修饰相关参数就可以了，该注解自1.5.0-RC1版本起可以使用。\n\n/**\n * 被@JSONBody注解修饰的参数会根据其类型被自定解析为XML字符串\n * 其修饰的参数类型必须支持JAXB，可以使用JAXB的注解进行修饰\n * 使用@XMLBody注解时可以省略 contentType = "application/xml"属性设置\n */\n@Post("http://localhost:8080/hello/user")\nString sendXmlMessage(@XMLBody User user);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n要注意的是，这里的User对象要绑定JAXB注解：\n\n@XmlRootElement(name = "misc")\npublic User {\n\n    private String usrname;\n\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n调用传入User对象后的结果如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/xml\nBODY:\n    <misc><username>foo</username><password>bar</password></misc>\n\n\n\n# @XMLBody注解修饰字符串\n\n@XMLBody支持的另一种形式就是直接传入一个XML字符串\n\n/**\n * @XMLBody注解可以修饰一个字符串参数，作为要传输的XML字符串\n */\n@Post("http://localhost:8080/hello/user")\nString sendXmlMessage(@XMLBody String userXml);\n\n\n1\n2\n3\n4\n5\n\n\n\n# Protobuf格式\n\n在使用 Protobuf 之前，首先需要有引入 google 的 protobuf 包依赖， 如何加相关依赖请参见《添加Protobuf框架依赖》\n\n假设，您已经有了 protobuf 的相关依赖包，而且也有了 protobuf 生成的数据类，如 ProtobufProto.MyData\n\n就可以直接使用 @ProtobufBody 注解修饰 protobuf 生成的数据类为类型的参数\n\n@Post("/proto/data")\nProtobufProto.MyData protobufTest2(@ProtobufBody ProtobufProto.MyData myData);\n\n// 调用改方法，会将 myData 数据对象自动转换为 Protobuf 格式字节流\n// 并发送到服务端\n// @ProtobufBody 在默认请情况下会将 Content-Type 设为\n// application/x-protobuf\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n若要不想使 Content-Type 为 application/x-protobuf, 可以自行设置\n\n@Post(url = "/proto/data", contentType = "application/octet-stream")\nProtobufProto.MyData protobufTest2(@ProtobufBody ProtobufProto.MyData myData);\n\n// 调用改方法，会将 myData 数据对象自动转换为 Protobuf 格式字节流\n// 并发送到服务端\n// 且此时 Content-Type 为\n// application/octet-stream\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 二进制格式\n\n对于application/otect-stream等二进制形式的Body数据，直接用 @Body 注解修饰参数即可。\n\n现在支持的二进制 Content-Type 有：\n\n * application/octect-stream\n * image/* (包括 image/png, image/jpeg 等)\n\n/**\n * 发送Byte数组类型数据\n */\n@Post(\n        url = "/upload/${filename}",\n        contentType = "application/octet-stream"\n)\nString sendByteArryr(@Body byte[] body, @Var("filename") String filename);\n\n/**\n * 发送File类型数据\n */\n@Post(\n    url = "/upload/${filename}",\n    contentType = "application/octet-stream"\n)\nString sendFile(@Body File file, @Var("filename") String filename);\n\n/**\n * 发送输入流类型数据\n */\n@Post(\n    url = "/upload/${filename}",\n    contentType = "application/octet-stream"\n)\nString sendInputStream(@Body InputStream inputStream, @Var("filename") String filename);\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n文档导航\n\n关于更多二进制传输以及文件上传内容，请见《上传下载》\n\n\n# data 属性\n\n您也可以通过@Request、以及@Get、@Post等请求注解的data属性把数据添加到请求体。需要注意的是只有当type为POST、PUT、PATCH这类 HTTP Method 时，data属性中的值才会绑定到请求体中，而GET请求在有些情况会绑定到url的参数中。\n\n具体type属性和data属性数据绑定位置的具体关系如下表：\n\nTYPE      DATA属性数据绑定位置   支持的CONTENTTYPE或CONTENT-TYPE请求头\nGET       url参数部分        只有application/x-www-form-urlencoded\nPOST      请求体            任何contentType\nPUT       请求体            任何contentType\nPATCH     请求体            任何contentType\nHEAD      url参数部分        只有application/x-www-form-urlencoded\nOPTIONS   url参数部分        只有application/x-www-form-urlencoded\nDELETE    url参数部分        只有application/x-www-form-urlencoded\nTRACE     url参数部分        只有application/x-www-form-urlencoded\n\ndata属性在POST请求中绑定请求体\n\npublic interface MyClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "username=foo&password=bar",\n            headers = {"Accept:text/plain"}\n    )\n    String dataPost();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n该接口调用后所实际产生的 HTTP 请求如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Accept:text/plain\nBODY:\n    username=foo&password=bar\n\n\n在data属性中进行数据绑定：\n\npublic interface MyClient {\n\n    /**\n     * 这里 data 属性中设置的字符串内容会绑定到请求体中\n     * 其中 ${0} 和 ${1} 为参数序号绑定，会将序号对应的参数绑定到字符串中对应的位置\n     * ${0} 会替换为 username 的值，${1} 会替换为 password 的值\n     */\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "username=${0}&password=${1}",\n            headers = {"Accept:text/plain"}\n    )\n    String dataPost(String username, String password);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n提示\n\n其中${数字}的语法用到了《参数序号引用》\n\n如果调用方代码如下所示：\n\nmyClient.dataPost("foo", "bar");\n\n\n1\n\n\n实际产生的 HTTP 请求如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Accept: text/plain\nBODY:\n    username=foo&password=bar\n\n\n您可以直接把 JSON 数据加入到请求体中，其中header设置为Content-Type: application/json\n\npublic interface MyClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "{\\"username\\": \\"${0}\\", \\"password\\": \\"${1}\\"}",\n            headers = {"Content-Type: application/json"}\n    )\n    String postJson(String username, String password);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果调用方代码如下所示：\n\nmyClient.postJson("foo", "bar");\n\n\n1\n\n\n实际产生的 HTTP 请求如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    {"username": "foo", "password": "bar"}\n\n\n把 XML 数据加入到请求体中，其中header设置为Content-Type: application/json\n\npublic interface MyClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "<misc><username>${0}</username><password>${1}</password></misc>",\n            headers = {"Content-Type: application/xml"}\n    )\n    String postXml(String username, String password);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果调用方代码如下所示：\n\nmyClient.postXml("foo", "bar");\n\n\n1\n\n\n实际产生的 HTTP 请求如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/xml\nBODY:\n    <misc><username>foo</username><password>bar</password></misc>\n\n\n\n# 请求体类型\n\n友情提示\n\n请求体类型的概念在v1.5.14版本后引入的，如果版本过低请使用最新版本\n\n以上例子都是通过设置 Content-Type 头来确定请求体的类型 (也是比较推荐的方式)\n\n但事实上，请求体的最终发送的格式是由Encoder（编码器）决定的，而一个请求用何编码器则使用请求体类型决定的，而且请求体类型在不设置的情况下可以由Content-Type推导出来！\n\n有点绕哈~，但看下面就清楚了\n\n请求体数据格式的推导过程：\n\nContent-Type 头 => BodyType 请求体类型 => Encoder 编码器 => 具体的请求体数据格式\n\n\n1\n2\n3\n\n\n比如：如果设置了 Content-Type 请求头为application/json，而请求体类型没有设置，那么请求体类型就会被推导为json类型，下一步则会根据接口配置信息和全局配置信息选择一个适配的 JSON 编码器（如：Jackson 转换器）\n\n也即是说，如果设置了请求体类型，那么 Content-Type 头就不会再影响到最终请求体的具体数据格式\n\n同理，如果设置了Encoder，那么请求体类型就被无视了，Content-Type 头设置成什么也无关紧要\n\n请求体数据格式相关属性优先级：\n\nEncoder 编码器 > BodyType 请求体类型 > Content-Type 头\n\n\n1\n2\n3\n\n\n如果明白了这一点，就可以实现一些不常见的请求，如：\n\n① 不填 Content-Type 头，而请求体是您想要的格式（如 JSON）；\n\n② Content-Type 为application/json，但请求体却是表单格式\n\n\n# @BodyType 注解\n\n请求体类型可以通过@BodyType注解来指定\n\n/**\n * 该方法不设置 Content-Type, 也可以指定 JSON 格式请求体\n */\n@Post(url = "/")\n@BodyType("json")\nString send(@Body("name") String name, @Body("value") Object value);\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用后产生的结果如下：\n\nPOST http://localhost:8080/hello/user\nBODY:\n    {"name": "foo", "value": "bar"}\n\n\n可以看到，该请求中没有 Content-Type 请求头，但请求体是 JSON 数据\n\n@BodyType注解也可用于发送请求体格式与 ContentType 头相异的数据\n\n/**\n * 此请求Content-Type头为 application/json\n * 而请求体的格式却可以是表单格式\n */\n@BodyType("form")\n@Post(url = "/", contentType = "application/json")\nString send(@Body("name") String name, @Body("value") Object value);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用后产生的结果如下：\n\nPOST http://localhost:8080/hello/user\nHEADER:\n    Content-Type: application/json\nBODY:\n    name=foo&value=bar\n\n\n该请求 Content-Type 为 application/json，但请求体却是表单格式数据\n\n\n# 可指定的请求体类型\n\nForest有多种请求体类型可供选择，分别是：text,form, json, xml, binary, multipart, protobuf\n\n请求体类型       描述\ntext        文本格式，即普通的字符串\nform        表单格式，即 x-www-form-urlencoded 格式\njson        JSON 格式\nxml         XML 格式\nbinary      二进制格式，即二进制字节流\nmultipart   多部件格式，即 multipart/data-form 格式\nprotobuf    Protobuf 格式\n\n\n# 指定 Encoder\n\n@BodyType注解同时可以指定Encoder\n\n/**\n * 指定请求体格式为json的同时，指定Encoder为Jackson转换器\n */\n@BodyType(type = "json", encoder = ForestJacksonConverter.class)\n@Post(url = "/", contentType = ContentType.APPLICATION_X_WWW_FORM_URLENCODED)\nString send(@Body Entry entry);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JSON 编码器快捷注解\n\n如果要指定特定JSON转换器为某一请求的Encoder，可以使用对应 JSON 编码器的快捷注解\n\n/**\n * 指定 Fastjson 为 Encoder\n */\n@FastjsonEncoder\n@Post("/")\nString sendFastjson(@Body Entry entry);\n\n/**\n * 指定 Jackson 为 Encoder\n */\n@JacksonEncoder\n@Post("/")\nString sendJackson(@Body Entry entry);\n\n/**\n * 指定 Gson 为 Encoder\n */\n@GsonEncoder\n@Post("/")\nString sendGson(@Body Entry entry);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'在post和put等请求方法中，通常使用 http 请求体进行传输数据。在 forest 中有多种方式设置请求体数据。\n\n\n# @body 注解\n\n您可以使用@body注解修饰参数的方式，将传入参数的数据绑定到 http 请求体中。\n\n@body注解修饰的参数一定会绑定到请求体中，不用担心它会出现在其他地方\n\n/**\n * 默认body格式为 application/x-www-form-urlencoded，即以表单形式序列化数据\n */\n@post("http://localhost:8080/user")\nstring sendpost(@body("username") string username,  @body("password") string password);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 表单格式\n\n上面使用 @body 注解的例子用的是普通的表单格式，也就是contenttype属性为application/x-www-form-urlencoded的格式，即contenttype不做配置时的默认值。\n\n表单格式的请求体以字符串 key1=value1&key2=value2&...&key{n}=value{n} 的形式进行传输数据，其中value都是已经过 url encode 编码过的字符串。\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n/**\n * contenttype属性设置为 application/x-www-form-urlencoded 即为表单格式，\n * 当然不设置的时候默认值也为 application/x-www-form-urlencoded， 也同样是表单格式。\n * 在 @body 注解的 value 属性中设置的名称为表单项的 key 名，\n * 而注解所修饰的参数值即为表单项的值，它可以为任何类型，不过最终都会转换为字符串进行传输。\n */\n@post(\n    url = "http://localhost:8080/user",\n    contenttype = "application/x-www-form-urlencoded"\n)\nstring sendpost(@body("key1") string value1,  @body("key2") integer value2, @body("key3") long value3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用后产生的结果可能如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/x-www-form-urlencoded\nbody:\n    key1=xxx&key2=1000&key3=9999\n\n\n当@body注解修饰的参数为一个对象，并注解的value属性不设置任何名称的时候，会将注解所修饰参数值对象视为一整个表单，其对象中的所有属性将按 属性名1=属性值1&属性名2=属性值2&...&属性名{n}=属性值{n} 的形式通过请求体进行传输数据。\n\n/**\n * contenttype 属性不设置默认为 application/x-www-form-urlencoded\n * 要以对象作为表达传输项时，其 @body 注解的 value 名称不能设置\n */\n@post("http://localhost:8080/hello/user")\nstring send(@body user user);\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用后产生的结果如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/x-www-form-urlencoded\nbody:\n    username=foo&password=bar\n\n\n\n# json格式\n\n\n# @jsonbody注解修饰对象\n\n发送json非常简单，只要用@jsonbody注解修饰相关参数就可以了，该注解自1.5.0-rc1版本起可以使用。 使用@jsonbody注解的同时就可以省略 contenttype = "application/json"属性设置。\n\n/**\n * 被@jsonbody注解修饰的参数会根据其类型被自定解析为json字符串\n * 使用@jsonbody注解时可以省略 contenttype = "application/json"属性设置\n */\n@post("http://localhost:8080/hello/user")\nstring hellouser(@jsonbody user user);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用后产生的结果如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    {"username": "foo", "password": "bar"}\n\n\n\n# @jsonbody注解修饰键值对\n\n@jsonbody注解可以按键值对拆分成多个参数进行传入，在发送的时候再合成一个完成的json字符串：\n\n\n/**\n * 按键值对分别修饰不同的参数\n * 这时每个参数前的 @jsonbody 注解必须填上 value 属性或 name 属性的值，作为json的字段名称\n */\n@post("http://localhost:8080/hello/user")\nstring hellouser(@jsonbody("username") string username, @jsonbody("password") string password);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如调用hellouser("foo", "bar");会产生如下结果：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    {"username": "foo", "password": "bar"}\n\n\n\n# @jsonbody注解修饰集合对象\n\n@jsonbody注解也支持map、list等集合类型参数\n\n/**\n * 被@jsonbody注解修饰的map类型参数会被自定解析为json字符串\n */\n@post(url = "http://localhost:8080/hello/user")\nstring hellouser(@jsonbody map<string, object> user);\n\n\n1\n2\n3\n4\n5\n\n\n若调用代码如下：\n\nmap<string, object> map = new hashmap<>();\nmap.put("name", "foo");\nmap.put("password", "bar");\nclient.hellouser(map);\n\n\n1\n2\n3\n4\n\n\n会产生如下结果：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    {"username": "foo", "password": "bar"}\n\n\nlist等列表对象也同理：\n\n/**\n * 被@jsonbody注解修饰的list类型参数会被自定解析为json字符串\n */\n@post(url = "http://localhost:8080/hello/user-names")\nstring hellousernames(@jsonbody list<string> usernames);\n\n\n1\n2\n3\n4\n5\n\n\n若调用代码如下：\n\nlist<string> names = lists.newarraylist("a", "b", "c");\nclient.hellousernames(names);\n\n\n1\n2\n\n\n会产生如下结果：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    ["a", "b", "c"]\n\n\n\n# @jsonbody注解修饰字符串\n\n@jsonbody注解还支持字符串类型参数，可以直接传入一个json字符串进行传输\n\n/**\n * 直接修饰一个json字符串\n */\n@post("http://localhost:8080/hello/user")\nstring hellouser(@jsonbody string userjson);\n\n\n1\n2\n3\n4\n5\n\n\n\n# @body注解 + contenttype\n\n除了@jsonbody注解，使用@body注解也可以，只要将contenttype属性或content-type请求头指定为application/json便可。\n\n\n\n\n \n\n\n\n\n@post(\n    url = "http://localhost:8080/hello/user",\n    contenttype = "application/json"\n)\nstring send(@body user user);\n\n\n1\n2\n3\n4\n5\n\n\n调用后产生的结果如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    {"username": "foo", "password": "bar"}\n\n\n\n# xml格式\n\n\n# @xmlbody注解修饰对象\n\n发送xml也非常简单，只要用@xmlbody注解修饰相关参数就可以了，该注解自1.5.0-rc1版本起可以使用。\n\n/**\n * 被@jsonbody注解修饰的参数会根据其类型被自定解析为xml字符串\n * 其修饰的参数类型必须支持jaxb，可以使用jaxb的注解进行修饰\n * 使用@xmlbody注解时可以省略 contenttype = "application/xml"属性设置\n */\n@post("http://localhost:8080/hello/user")\nstring sendxmlmessage(@xmlbody user user);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n要注意的是，这里的user对象要绑定jaxb注解：\n\n@xmlrootelement(name = "misc")\npublic user {\n\n    private string usrname;\n\n    private string password;\n\n    public string getusername() {\n        return username;\n    }\n\n    public void setusername(string username) {\n        this.username = username;\n    }\n\n    public string getpassword() {\n        return password;\n    }\n\n    public void setpassword(string password) {\n        this.password = password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n调用传入user对象后的结果如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/xml\nbody:\n    <misc><username>foo</username><password>bar</password></misc>\n\n\n\n# @xmlbody注解修饰字符串\n\n@xmlbody支持的另一种形式就是直接传入一个xml字符串\n\n/**\n * @xmlbody注解可以修饰一个字符串参数，作为要传输的xml字符串\n */\n@post("http://localhost:8080/hello/user")\nstring sendxmlmessage(@xmlbody string userxml);\n\n\n1\n2\n3\n4\n5\n\n\n\n# protobuf格式\n\n在使用 protobuf 之前，首先需要有引入 google 的 protobuf 包依赖， 如何加相关依赖请参见《添加protobuf框架依赖》\n\n假设，您已经有了 protobuf 的相关依赖包，而且也有了 protobuf 生成的数据类，如 protobufproto.mydata\n\n就可以直接使用 @protobufbody 注解修饰 protobuf 生成的数据类为类型的参数\n\n@post("/proto/data")\nprotobufproto.mydata protobuftest2(@protobufbody protobufproto.mydata mydata);\n\n// 调用改方法，会将 mydata 数据对象自动转换为 protobuf 格式字节流\n// 并发送到服务端\n// @protobufbody 在默认请情况下会将 content-type 设为\n// application/x-protobuf\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n若要不想使 content-type 为 application/x-protobuf, 可以自行设置\n\n@post(url = "/proto/data", contenttype = "application/octet-stream")\nprotobufproto.mydata protobuftest2(@protobufbody protobufproto.mydata mydata);\n\n// 调用改方法，会将 mydata 数据对象自动转换为 protobuf 格式字节流\n// 并发送到服务端\n// 且此时 content-type 为\n// application/octet-stream\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 二进制格式\n\n对于application/otect-stream等二进制形式的body数据，直接用 @body 注解修饰参数即可。\n\n现在支持的二进制 content-type 有：\n\n * application/octect-stream\n * image/* (包括 image/png, image/jpeg 等)\n\n/**\n * 发送byte数组类型数据\n */\n@post(\n        url = "/upload/${filename}",\n        contenttype = "application/octet-stream"\n)\nstring sendbytearryr(@body byte[] body, @var("filename") string filename);\n\n/**\n * 发送file类型数据\n */\n@post(\n    url = "/upload/${filename}",\n    contenttype = "application/octet-stream"\n)\nstring sendfile(@body file file, @var("filename") string filename);\n\n/**\n * 发送输入流类型数据\n */\n@post(\n    url = "/upload/${filename}",\n    contenttype = "application/octet-stream"\n)\nstring sendinputstream(@body inputstream inputstream, @var("filename") string filename);\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n文档导航\n\n关于更多二进制传输以及文件上传内容，请见《上传下载》\n\n\n# data 属性\n\n您也可以通过@request、以及@get、@post等请求注解的data属性把数据添加到请求体。需要注意的是只有当type为post、put、patch这类 http method 时，data属性中的值才会绑定到请求体中，而get请求在有些情况会绑定到url的参数中。\n\n具体type属性和data属性数据绑定位置的具体关系如下表：\n\ntype      data属性数据绑定位置   支持的contenttype或content-type请求头\nget       url参数部分        只有application/x-www-form-urlencoded\npost      请求体            任何contenttype\nput       请求体            任何contenttype\npatch     请求体            任何contenttype\nhead      url参数部分        只有application/x-www-form-urlencoded\noptions   url参数部分        只有application/x-www-form-urlencoded\ndelete    url参数部分        只有application/x-www-form-urlencoded\ntrace     url参数部分        只有application/x-www-form-urlencoded\n\ndata属性在post请求中绑定请求体\n\npublic interface myclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "username=foo&password=bar",\n            headers = {"accept:text/plain"}\n    )\n    string datapost();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n该接口调用后所实际产生的 http 请求如下：\n\npost http://localhost:8080/hello/user\nheader:\n    accept:text/plain\nbody:\n    username=foo&password=bar\n\n\n在data属性中进行数据绑定：\n\npublic interface myclient {\n\n    /**\n     * 这里 data 属性中设置的字符串内容会绑定到请求体中\n     * 其中 ${0} 和 ${1} 为参数序号绑定，会将序号对应的参数绑定到字符串中对应的位置\n     * ${0} 会替换为 username 的值，${1} 会替换为 password 的值\n     */\n    @request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "username=${0}&password=${1}",\n            headers = {"accept:text/plain"}\n    )\n    string datapost(string username, string password);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n提示\n\n其中${数字}的语法用到了《参数序号引用》\n\n如果调用方代码如下所示：\n\nmyclient.datapost("foo", "bar");\n\n\n1\n\n\n实际产生的 http 请求如下：\n\npost http://localhost:8080/hello/user\nheader:\n    accept: text/plain\nbody:\n    username=foo&password=bar\n\n\n您可以直接把 json 数据加入到请求体中，其中header设置为content-type: application/json\n\npublic interface myclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "{\\"username\\": \\"${0}\\", \\"password\\": \\"${1}\\"}",\n            headers = {"content-type: application/json"}\n    )\n    string postjson(string username, string password);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果调用方代码如下所示：\n\nmyclient.postjson("foo", "bar");\n\n\n1\n\n\n实际产生的 http 请求如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    {"username": "foo", "password": "bar"}\n\n\n把 xml 数据加入到请求体中，其中header设置为content-type: application/json\n\npublic interface myclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user",\n            type = "post",\n            data = "<misc><username>${0}</username><password>${1}</password></misc>",\n            headers = {"content-type: application/xml"}\n    )\n    string postxml(string username, string password);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果调用方代码如下所示：\n\nmyclient.postxml("foo", "bar");\n\n\n1\n\n\n实际产生的 http 请求如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/xml\nbody:\n    <misc><username>foo</username><password>bar</password></misc>\n\n\n\n# 请求体类型\n\n友情提示\n\n请求体类型的概念在v1.5.14版本后引入的，如果版本过低请使用最新版本\n\n以上例子都是通过设置 content-type 头来确定请求体的类型 (也是比较推荐的方式)\n\n但事实上，请求体的最终发送的格式是由encoder（编码器）决定的，而一个请求用何编码器则使用请求体类型决定的，而且请求体类型在不设置的情况下可以由content-type推导出来！\n\n有点绕哈~，但看下面就清楚了\n\n请求体数据格式的推导过程：\n\ncontent-type 头 => bodytype 请求体类型 => encoder 编码器 => 具体的请求体数据格式\n\n\n1\n2\n3\n\n\n比如：如果设置了 content-type 请求头为application/json，而请求体类型没有设置，那么请求体类型就会被推导为json类型，下一步则会根据接口配置信息和全局配置信息选择一个适配的 json 编码器（如：jackson 转换器）\n\n也即是说，如果设置了请求体类型，那么 content-type 头就不会再影响到最终请求体的具体数据格式\n\n同理，如果设置了encoder，那么请求体类型就被无视了，content-type 头设置成什么也无关紧要\n\n请求体数据格式相关属性优先级：\n\nencoder 编码器 > bodytype 请求体类型 > content-type 头\n\n\n1\n2\n3\n\n\n如果明白了这一点，就可以实现一些不常见的请求，如：\n\n① 不填 content-type 头，而请求体是您想要的格式（如 json）；\n\n② content-type 为application/json，但请求体却是表单格式\n\n\n# @bodytype 注解\n\n请求体类型可以通过@bodytype注解来指定\n\n/**\n * 该方法不设置 content-type, 也可以指定 json 格式请求体\n */\n@post(url = "/")\n@bodytype("json")\nstring send(@body("name") string name, @body("value") object value);\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用后产生的结果如下：\n\npost http://localhost:8080/hello/user\nbody:\n    {"name": "foo", "value": "bar"}\n\n\n可以看到，该请求中没有 content-type 请求头，但请求体是 json 数据\n\n@bodytype注解也可用于发送请求体格式与 contenttype 头相异的数据\n\n/**\n * 此请求content-type头为 application/json\n * 而请求体的格式却可以是表单格式\n */\n@bodytype("form")\n@post(url = "/", contenttype = "application/json")\nstring send(@body("name") string name, @body("value") object value);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用后产生的结果如下：\n\npost http://localhost:8080/hello/user\nheader:\n    content-type: application/json\nbody:\n    name=foo&value=bar\n\n\n该请求 content-type 为 application/json，但请求体却是表单格式数据\n\n\n# 可指定的请求体类型\n\nforest有多种请求体类型可供选择，分别是：text,form, json, xml, binary, multipart, protobuf\n\n请求体类型       描述\ntext        文本格式，即普通的字符串\nform        表单格式，即 x-www-form-urlencoded 格式\njson        json 格式\nxml         xml 格式\nbinary      二进制格式，即二进制字节流\nmultipart   多部件格式，即 multipart/data-form 格式\nprotobuf    protobuf 格式\n\n\n# 指定 encoder\n\n@bodytype注解同时可以指定encoder\n\n/**\n * 指定请求体格式为json的同时，指定encoder为jackson转换器\n */\n@bodytype(type = "json", encoder = forestjacksonconverter.class)\n@post(url = "/", contenttype = contenttype.application_x_www_form_urlencoded)\nstring send(@body entry entry);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# json 编码器快捷注解\n\n如果要指定特定json转换器为某一请求的encoder，可以使用对应 json 编码器的快捷注解\n\n/**\n * 指定 fastjson 为 encoder\n */\n@fastjsonencoder\n@post("/")\nstring sendfastjson(@body entry entry);\n\n/**\n * 指定 jackson 为 encoder\n */\n@jacksonencoder\n@post("/")\nstring sendjackson(@body entry entry);\n\n/**\n * 指定 gson 为 encoder\n */\n@gsonencoder\n@post("/")\nstring sendgson(@body entry entry);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🧁 接口注解",frontmatter:{id:"base_request",hide_title:!1,title:"🧁 接口注解",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/base_request/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/008.base_request.html",relativePath:"001.v1.5.x文档/040.声明式接口/008.base_request.md",key:"v-56e3e48c",path:"/pages/1.5.x/base_request/",headers:[{level:2,title:"@BaseRequest 注解",slug:"baserequest-注解",normalizedTitle:"@baserequest 注解",charIndex:2},{level:2,title:"方法注解",slug:"方法注解",normalizedTitle:"方法注解",charIndex:1606}],headersStr:"@BaseRequest 注解 方法注解",content:'# @BaseRequest 注解\n\n@BaseRequest注解定义在接口类上，在@BaseRequest上定义的属性会被分配到该接口中每一个方法上，但方法上定义的请求属性会覆盖@BaseRequest上重复定义的内容。 因此可以认为@BaseRequest上定义的属性内容是所在接口中所有请求的默认属性。\n\n/**\n * @BaseRequest 为配置接口层级请求信息的注解\n * 其属性会成为该接口下所有请求的默认属性\n * 但可以被方法上定义的属性所覆盖\n */\n@BaseRequest(\n    baseURL = "http://localhost:8080",     // 默认域名\n    headers = {\n        "Accept:text/plain"                // 默认请求头\n    },\n    sslProtocol = "TLS"                    // 默认单向SSL协议\n)\npublic interface MyClient {\n  \n    // 方法的URL不必再写域名部分\n    @Get("/hello/user")\n    String send1(@Query("username") String username);\n\n    // 若方法的URL是完整包含http://开头的，那么会以方法的URL中域名为准，不会被接口层级中的baseURL属性覆盖\n    @Get("http://www.xxx.com/hello/user")\n    String send2(@Query("username") String username);\n  \n\n    @Get(\n        url = "/hello/user",\n        headers = {\n            "Accept:application/json"      // 覆盖接口层级配置的请求头信息\n        }\n    )     \n    String send3(@Query("username") String username);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n@BaseRequest注解中的所有字符串属性都可以通过模板表达式引用全局变量或方法中的参数。\n\n/** \n * 若全局变量中已定义 baseUrl 和 accept，\n * 便会将全局变量中的值绑定到 @BaseRequest 的属性中\n */\n@BaseRequest(\n    baseURL = "${baseUrl}",     // 默认域名\n    headers = {\n        "Accept:${accept}"      // 默认请求头\n    }\n)\npublic interface MyClient {\n\n    // 方法的URL的域名将会引用全局变量中定义的 baseUrl\n    @Get("/hello/user")     \n    String send1(@Query("username") String username);\n\n    // @BaseRequest 中的属性亦可以引用方法中的绑定变量名的参数\n    @Get("/hello/user")\n    String send2(@Var("baseUrl") String baseUrl);\n  \n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 方法注解\n\n在 Forest 中，方法注解（除了@Post这类请求注解之外）也可以放置在 interface 接口上，其注解效果会涵盖接口下的所有方法\n\n如果方法上有同样的注解，则会覆盖接口上注解的配置信息\n\n/**\n * @Backend 是一个方法维度的注解，但也可以挂在接口上\n * 它可以为接口下的每一个方法请求设置HTTP后端框架\n * 所以该接口下所有请求默认都会使用 OkHttp3\n */\n@Backend("okhttp3")\n@Address(host = "localhost", port = "8080")\npublic interface MyClient {\n\n    /**\n     * 使用接口默认后端框架，即 OkHttp3\n     */\n    @Post("/data1")\n    String sendData1(@Body MyData data);\n\n    /**\n     * 使用接口默认后端框架，即 OkHttp3\n     */\n    @Post("/data2")\n    String sendData2(@Body MyData data);\n\n    /**\n     * 使用了接口上相同的注解 @Backend\n     * 覆盖了改接口默认后端框架配置\n     * 所以该请求会使用 HttpClient 作为后端框架\n     */\n    @Backend("httpclient")\n    @Post("/data3")\n    String sendData3(@Body MyData data);\n\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',normalizedContent:'# @baserequest 注解\n\n@baserequest注解定义在接口类上，在@baserequest上定义的属性会被分配到该接口中每一个方法上，但方法上定义的请求属性会覆盖@baserequest上重复定义的内容。 因此可以认为@baserequest上定义的属性内容是所在接口中所有请求的默认属性。\n\n/**\n * @baserequest 为配置接口层级请求信息的注解\n * 其属性会成为该接口下所有请求的默认属性\n * 但可以被方法上定义的属性所覆盖\n */\n@baserequest(\n    baseurl = "http://localhost:8080",     // 默认域名\n    headers = {\n        "accept:text/plain"                // 默认请求头\n    },\n    sslprotocol = "tls"                    // 默认单向ssl协议\n)\npublic interface myclient {\n  \n    // 方法的url不必再写域名部分\n    @get("/hello/user")\n    string send1(@query("username") string username);\n\n    // 若方法的url是完整包含http://开头的，那么会以方法的url中域名为准，不会被接口层级中的baseurl属性覆盖\n    @get("http://www.xxx.com/hello/user")\n    string send2(@query("username") string username);\n  \n\n    @get(\n        url = "/hello/user",\n        headers = {\n            "accept:application/json"      // 覆盖接口层级配置的请求头信息\n        }\n    )     \n    string send3(@query("username") string username);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n@baserequest注解中的所有字符串属性都可以通过模板表达式引用全局变量或方法中的参数。\n\n/** \n * 若全局变量中已定义 baseurl 和 accept，\n * 便会将全局变量中的值绑定到 @baserequest 的属性中\n */\n@baserequest(\n    baseurl = "${baseurl}",     // 默认域名\n    headers = {\n        "accept:${accept}"      // 默认请求头\n    }\n)\npublic interface myclient {\n\n    // 方法的url的域名将会引用全局变量中定义的 baseurl\n    @get("/hello/user")     \n    string send1(@query("username") string username);\n\n    // @baserequest 中的属性亦可以引用方法中的绑定变量名的参数\n    @get("/hello/user")\n    string send2(@var("baseurl") string baseurl);\n  \n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 方法注解\n\n在 forest 中，方法注解（除了@post这类请求注解之外）也可以放置在 interface 接口上，其注解效果会涵盖接口下的所有方法\n\n如果方法上有同样的注解，则会覆盖接口上注解的配置信息\n\n/**\n * @backend 是一个方法维度的注解，但也可以挂在接口上\n * 它可以为接口下的每一个方法请求设置http后端框架\n * 所以该接口下所有请求默认都会使用 okhttp3\n */\n@backend("okhttp3")\n@address(host = "localhost", port = "8080")\npublic interface myclient {\n\n    /**\n     * 使用接口默认后端框架，即 okhttp3\n     */\n    @post("/data1")\n    string senddata1(@body mydata data);\n\n    /**\n     * 使用接口默认后端框架，即 okhttp3\n     */\n    @post("/data2")\n    string senddata2(@body mydata data);\n\n    /**\n     * 使用了接口上相同的注解 @backend\n     * 覆盖了改接口默认后端框架配置\n     * 所以该请求会使用 httpclient 作为后端框架\n     */\n    @backend("httpclient")\n    @post("/data3")\n    string senddata3(@body mydata data);\n\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍛 数据转换",frontmatter:{id:"converter",title:"🍛 数据转换",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/converter/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.converter.html",relativePath:"001.v1.5.x文档/040.声明式接口/010.converter.md",key:"v-2932182e",path:"/pages/1.5.x/converter/",headers:[{level:2,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:54},{level:3,title:"Content-Type 请求头",slug:"content-type-请求头",normalizedTitle:"content-type 请求头",charIndex:169},{level:3,title:"请求体类型",slug:"请求体类型",normalizedTitle:"请求体类型",charIndex:562},{level:3,title:"Encoder",slug:"encoder",normalizedTitle:"encoder",charIndex:812},{level:2,title:"反序列化",slug:"反序列化",normalizedTitle:"反序列化",charIndex:77},{level:3,title:"自动识别结果数据类型",slug:"自动识别结果数据类型",normalizedTitle:"自动识别结果数据类型",charIndex:1248},{level:3,title:"指定结果数据类型",slug:"指定结果数据类型",normalizedTitle:"指定结果数据类型",charIndex:1810},{level:3,title:"Decoder",slug:"decoder",normalizedTitle:"decoder",charIndex:2038},{level:2,title:"转换器",slug:"转换器",normalizedTitle:"转换器",charIndex:849},{level:2,title:"配置全局转换器",slug:"配置全局转换器",normalizedTitle:"配置全局转换器",charIndex:3307},{level:2,title:"Springboot 下配置全局转换器",slug:"springboot-下配置全局转换器",normalizedTitle:"springboot 下配置全局转换器",charIndex:6743},{level:3,title:"Fastjson 转换器",slug:"fastjson-转换器",normalizedTitle:"fastjson 转换器",charIndex:6875},{level:3,title:"Jackson 转换器",slug:"jackson-转换器",normalizedTitle:"jackson 转换器",charIndex:873},{level:3,title:"Gson 转换器",slug:"gson-转换器",normalizedTitle:"gson 转换器",charIndex:7617},{level:2,title:"配置接口/方法级别转换器",slug:"配置接口-方法级别转换器",normalizedTitle:"配置接口/方法级别转换器",charIndex:7989},{level:2,title:"自定义转换器",slug:"自定义转换器",normalizedTitle:"自定义转换器",charIndex:8345}],headersStr:"序列化 Content-Type 请求头 请求体类型 Encoder 反序列化 自动识别结果数据类型 指定结果数据类型 Decoder 转换器 配置全局转换器 Springboot 下配置全局转换器 Fastjson 转换器 Jackson 转换器 Gson 转换器 配置接口/方法级别转换器 自定义转换器",content:'Forest支持JSON、XML、普通文本等数据转换形式。不需要接口调用者自己写具体的数据转换代码\n\n\n# 序列化\n\n几乎所有数据格式的转换都包含序列化和反序列化，Forest的数据转换同样如此\n\n序列化是指，将原始的 Java 类型数据对象转化为 HTTP 请求想要发送的数据格式（如：JSON、XML、Protobuf 等）\n\n\n# Content-Type 请求头\n\nForest中对数据进行序列化可以通过指定contentType属性或Content-Type头指定内容格式\n\n\n\n\n \n\n\n\n\n@Post(\n        url = "http://localhost:8080/hello/user",\n        contentType = "application/json"    // 指定contentType为application/json\n)\nString postJson(@Body MyUser user);   // 自动将user对象序列化为JSON格式\n\n\n1\n2\n3\n4\n5\n\n\n同理，指定为application/xml会将参数序列化为XML格式，text/plain则为文本，默认的application/x-www-form-urlencoded则为表格格式。\n\n\n# 请求体类型\n\n或者，也可以通过@BodyType注解指定type属性\n\n\n\n\n\n \n\n\n\n// 自动将user对象序列化为JSON格式\n// 但此方式不会在请求中带有 Content-Type 请求头\n@Post("http://localhost:8080/hello/user")\n@BodyType("json")\nString postJson(@Body MyUser user);\n\n\n1\n2\n3\n4\n5\n\n\n@BodyType的具体使用方式，请参见《@BodyType 注解》\n\n\n# Encoder\n\n通过@BodyType的encoder属性设置一个具体的转换器类\n\n\n\n\n \n\n\n\n// 指定仅仅使用 Jackson 转换器来序列化数据\n@Post("http://localhost:8080/hello/user")\n@BodyType(type = "json", encoder = ForestJacksonConverter.class)\nString postJson(@Body MyUser user);\n\n\n1\n2\n3\n4\n\n\n提示\n\n在方法不指定 Encoder 的默认情况下，会去找接口上有没有设置 Encoder，如接口上也没有则使用全局的转换器为改方法请求的 Encoder\n\n\n# 反序列化\n\n反序列化则是正好与序列化的逆过程，是将远端服务接受到的原始数据格式（如：JSON、XML、Protobuf 等）转换为在 Java 程序中可以方便读取操作的 Java 数据对象\n\nForest 提供了多种反序列化的方式\n\n\n# 自动识别结果数据类型\n\nForest 会将根据返回结果自动识别响应的数据格式，并进行反序列化转换\n\n// 如结果是一串类似 {"a": 1, "b": 2} 形式的JSON字符串\n// 则会自动识别并进行转换\n\n@Get("http://localhost:8080/data")\nMap getDataAsMap();  // 自动识别转换为 Map 对象\n\n@Get("http://localhost:8080/data")\nMyData getMyData();  // 自动识别转换为自定义类型对象\n\n// 如结果是一串 XML 字符串\n// 也能自动识别并转换\n// 但前提是自定义的类型要有 JAXB 注解标注        \nMyXmlData getXmlData();\n\n// 如果结果是一串类似 [{"name": "xxx"}, {"name": "yyy"}] 格式的 JSON 数组字符串\n// Forest 也一样能自动识别并转换为 Java 集合对象\n@Get("http://localhost:8080/data/list")\nList<MyData> getDataList();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 指定结果数据类型\n\n您也可以通过dataType指定返回数据的反序列化格式\n\n\n\n\n \n\n\n\n\n@Get(\n    url = "http://localhost:8080/data",\n    dataType = "json"        // 指定dataType为json，将按JSON格式反序列化数据\n)\nMap getData();               // 请求响应的结果将被转换为Map类型对象\n\n\n1\n2\n3\n4\n5\n\n\n\n# Decoder\n\nForest 也可以通过请求注解 (诸如：@Request、@Get、@Post 等) 的decoder属性来指定具体处理该请求结果的反序列化的转换器\n\n\n\n\n\n \n\n\n\n\n// 指定由 Jackson 转换器处理请求的反序列化\n@Get(\n    url = "http://localhost:8080/data",\n    decoder = ForestJacksonConverter.class\n)\nMap getData();\n\n\n1\n2\n3\n4\n5\n6\n\n\n提示\n\n和 Encoder 一样的道理，如方法不指定 Decoder，则会去找接口上有没有设置 Decoder，如接口上也没有则使用全局的转换器为改方法请求的 Decoder\n\n\n# 转换器\n\n在Forest中，序列化和反序列化过程都有Forest转换器来实现，其数据在Forest中的转换过程如图所示:\n\nForest提供了默认的转换器，其分成五大类：文本转换器、JSON转换器、XML转换器、二进制转换器、自动转换器。 各大类还可以继续细分为更具体的转换器，可以按类继承理解其分类。\n\n转换器的继承体系请看如下树状结构：\n\nForestConverter接口\n ├── DefaultTextConverter类\n ├── ForestJsonConverter接口\n |    ├── ForestFastjsonConverter类\n |    ├── ForestJacksonConverter类\n |    └── ForestGsonConverter类\n ├── ForestXmlConverter接口\n |    └── ForestJaxbConverter类\n ├── DefaultBinaryConverter类\n └── DefaultAutoConverter类\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以替换和使用的转换器类如下表：\n\n转换器类                      类型       描述\nDefaultTextConverter      text     默认文本数据转换器\nForestFastjsonConverter   json     基于Fastjson框架的JSON转换器\nForestJacksonConverter    json     基于Jackson框架的JSON转换器\nForestGsonConverter       json     基于Gson框架的JSON转换器\nForestJaxbConverter       xml      基于Jaxb框架的XML转换器\nDefaultBinaryConverter    binary   默认二进制转换器，多在文件下载时使用\nDefaultAutoConverter      auto     自动类型转换器，可以根据响应返回的数据自动嗅探数据类型并使用对应的转换器进行转换\n\n\n# 配置全局转换器\n\n在Forest中已定义好默认的转换器，比如JSON的默认转为器为ForestFastjsonConverter，即FastJson的转换器\n\nforest:\n  # 转换器配置，支持 json, xml, text, binary 四种数据类型的配置\n  converters:\n    # JSON转换器\n    json:\n      # JSON转换器设置为Jackson转换器\n      type: com.dtflys.forest.converter.json.ForestJacksonConverter\n      # JSON转换器设置为GSON转换器\n      # type: com.dtflys.forest.converter.json.ForestGsonConverter\n      # JSON转换器设置为Fastjson转换器\n      # type: com.dtflys.forest.converter.json.ForestFastjsonConverter\n      \n      # 转换器的参数设置\n      parameters:\n        # JSON数据转换器的全局日期格式化配置\n        dateFormat: yyyy/MM/dd hh:mm:ss\n        \n    # XML转换器\n    xml:\n      # 配置为JAXB转换器\n      type: com.dtflys.forest.converter.xml.ForestJaxbConverter\n\n    # 二进制转换器\n    binary:\n      # 配置为Forest默认二进制转换器\n      type: com.dtflys.forest.converter.binary.DefaultBinaryConverter\n\n    # 文本转换器\n    text:\n      # 配置为Forest默认文本转换器\n      type: com.dtflys.forest.converter.text.DefaultTextConverter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 转换器配置，支持 json, xml, text, binary 四种数据类型的配置\n\n# JSON转换器\n# JSON转换器设置为Jackson的转换器\nforest.converters.json.type=com.dtflys.forest.converter.json.ForestJacksonConverter\n# JSON转换器设置为GSON转换器\n# forest.converters.json.type=com.dtflys.forest.converter.json.ForestGsonConverter\n# JSON转换器设置为Fastjson转换器\n# forest.converters.json.type=com.dtflys.forest.converter.json.ForestFastjsonConverter\n      \n# 转换器的参数设置\n# JSON数据转换器的全局日期格式化配置\nforest.converters.json.parameters.dateFormat: yyyy/MM/dd hh:mm:ss\n        \n# XML转换器\n# 配置为JAXB转换器\nforest.converters.xml.type=com.dtflys.forest.converter.xml.ForestJaxbConverter\n\n# 二进制转换器\n# 配置为Forest默认二进制转换器\nforest.converters.binary.type: com.dtflys.forest.converter.binary.DefaultBinaryConverter\n\n# 文本转换器\n# 配置为Forest默认文本转换器\nforest.converters.text.type: com.dtflys.forest.converter.text.DefaultTextConverter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n<forest:configuration>\n    \x3c!-- Forest转换器定义 开始 --\x3e\n    \x3c!-- 设置JSON转换器 --\x3e\n    \x3c!-- JSON转换器设置为Jackson的转换器 --\x3e\n    <forest:converter dataType="json" class="com.dtflys.forest.converter.json.ForestJacksonConverter">\n        <forest:parameter name="dateFormat" value="yyyy/MM/dd hh:mm:ss"/>\n    </forest:converter>\n    \n    \x3c!-- JSON转换器设置为GSON转换器 --\x3e\n    \x3c!--\n    <forest:converter dataType="json" class="com.dtflys.forest.converter.json.ForestGsonConverter">\n        <forest:parameter name="dateFormat" value="yyyy/MM/dd hh:mm:ss"/>\n    </forest:converter>\n    --\x3e\n\n    \x3c!-- JSON转换器设置为Fastjson转换器 --\x3e\n    \x3c!--\n    <forest:converter dataType="json" class="com.dtflys.forest.converter.json.ForestFastjsonConverter">\n        <forest:parameter name="dateFormat" value="yyyy/MM/dd hh:mm:ss"/>\n    </forest:converter>\n    --\x3e\n\n    \x3c!-- 设置XML转换器 --\x3e\n    <forest:converter dataType="xml" class="com.dtflys.forest.converter.xml.ForestJaxbConverter">\n    </forest:converter>\n    \x3c!-- Forest转换器定义 结束 --\x3e\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n// 获取全局默认配置对象\nForestConfiguration configuration = Forest.config();\n// 更换JSON转换器为FastJson\nconfiguration.setJsonConverter(new ForestFastjsonConverter());\n// 更换JSON转换器为Jackson\nconfiguration.setJsonConverter(new ForestJacksonConverter());\n// 更换JSON转换器Gson\nconfiguration.setJsonConverter(new ForestGsonConverter());\n// 更换XML转换器JAXB\nconfiguration.getConverterMap().put(ForestDataType.XML, new ForestJaxbConverter());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Springboot 下配置全局转换器\n\n在 Springboot 环境下，可以无视上面的配置文件，取而代之的是一个更简单、更灵活、更 Springboot 的做法，即通过 @Bean 注解定义的方法返回一个ForestConverter接口的现实类实例\n\n\n# Fastjson 转换器\n\n@Bean\npublic ForestJsonConverter forestFastjsonConverter() {\n    ForestFastjsonConverter converter = new ForestFastjsonConverter();\n    // 设置日期格式\n    converter.setDateFormat("yyyy-MM-dd hh:mm:ss");\n    // 设置序列化特性\n    converter.setSerializerFeature(SerializerFeature.IgnoreErrorGetter);\n    return converter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Jackson 转换器\n\n@Bean\npublic ForestJsonConverter forestJacksonConverter() {\n    ForestJacksonConverter converter = new ForestJacksonConverter();\n    // 设置日期格式\n    converter.setDateFormat("yyyy-MM-dd hh:mm:ss");\n    // 获取 Jackson 的 ObjectMapper 对象\n    ObjectMapper mapper = converter.getMapper();\n    // 通过 ObjectMapper 对象可以对 Jackson 转换器做更细致的设置\n    return converter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Gson 转换器\n\n@Bean\npublic ForestJsonConverter forestGsonConverter() {\n    ForestGsonConverter converter = new ForestGsonConverter();\n    // 设置日期格式\n    converter.setDateFormat("yyyy-MM-dd hh:mm:ss");\n    return converter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n各类转换器 (如 JSON、XML转换器) 全局的 Bean 只能有一个，同时定义了多个 ForestJsonConverter (以 JSON 为例) 的 Bean 到 Spring 上下文中\n\n则要通过上文介绍的配置方式来指定全局转换具体是哪一个\n\n\n# 配置接口/方法级别转换器\n\n使用@BodyType注解定义encoder\n\n// 接口级别转换器定义\n@BodyType(type = "json", encoder = ForestJacksonConverter.class)\npublic interface MyClient {\n\n    // 方法级别转换器定义\n    @Get("/data")\n    @BodyType(type = "json", encoder = ForestFastjsonConverter.class)\n    String sendData(@Body MyData data);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n具体使用方式，请参见《指定 Encoder》和《JSON 编码器快捷注解》\n\n\n# 自定义转换器\n\n请参见 《自定义转换器》',normalizedContent:'forest支持json、xml、普通文本等数据转换形式。不需要接口调用者自己写具体的数据转换代码\n\n\n# 序列化\n\n几乎所有数据格式的转换都包含序列化和反序列化，forest的数据转换同样如此\n\n序列化是指，将原始的 java 类型数据对象转化为 http 请求想要发送的数据格式（如：json、xml、protobuf 等）\n\n\n# content-type 请求头\n\nforest中对数据进行序列化可以通过指定contenttype属性或content-type头指定内容格式\n\n\n\n\n \n\n\n\n\n@post(\n        url = "http://localhost:8080/hello/user",\n        contenttype = "application/json"    // 指定contenttype为application/json\n)\nstring postjson(@body myuser user);   // 自动将user对象序列化为json格式\n\n\n1\n2\n3\n4\n5\n\n\n同理，指定为application/xml会将参数序列化为xml格式，text/plain则为文本，默认的application/x-www-form-urlencoded则为表格格式。\n\n\n# 请求体类型\n\n或者，也可以通过@bodytype注解指定type属性\n\n\n\n\n\n \n\n\n\n// 自动将user对象序列化为json格式\n// 但此方式不会在请求中带有 content-type 请求头\n@post("http://localhost:8080/hello/user")\n@bodytype("json")\nstring postjson(@body myuser user);\n\n\n1\n2\n3\n4\n5\n\n\n@bodytype的具体使用方式，请参见《@bodytype 注解》\n\n\n# encoder\n\n通过@bodytype的encoder属性设置一个具体的转换器类\n\n\n\n\n \n\n\n\n// 指定仅仅使用 jackson 转换器来序列化数据\n@post("http://localhost:8080/hello/user")\n@bodytype(type = "json", encoder = forestjacksonconverter.class)\nstring postjson(@body myuser user);\n\n\n1\n2\n3\n4\n\n\n提示\n\n在方法不指定 encoder 的默认情况下，会去找接口上有没有设置 encoder，如接口上也没有则使用全局的转换器为改方法请求的 encoder\n\n\n# 反序列化\n\n反序列化则是正好与序列化的逆过程，是将远端服务接受到的原始数据格式（如：json、xml、protobuf 等）转换为在 java 程序中可以方便读取操作的 java 数据对象\n\nforest 提供了多种反序列化的方式\n\n\n# 自动识别结果数据类型\n\nforest 会将根据返回结果自动识别响应的数据格式，并进行反序列化转换\n\n// 如结果是一串类似 {"a": 1, "b": 2} 形式的json字符串\n// 则会自动识别并进行转换\n\n@get("http://localhost:8080/data")\nmap getdataasmap();  // 自动识别转换为 map 对象\n\n@get("http://localhost:8080/data")\nmydata getmydata();  // 自动识别转换为自定义类型对象\n\n// 如结果是一串 xml 字符串\n// 也能自动识别并转换\n// 但前提是自定义的类型要有 jaxb 注解标注        \nmyxmldata getxmldata();\n\n// 如果结果是一串类似 [{"name": "xxx"}, {"name": "yyy"}] 格式的 json 数组字符串\n// forest 也一样能自动识别并转换为 java 集合对象\n@get("http://localhost:8080/data/list")\nlist<mydata> getdatalist();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 指定结果数据类型\n\n您也可以通过datatype指定返回数据的反序列化格式\n\n\n\n\n \n\n\n\n\n@get(\n    url = "http://localhost:8080/data",\n    datatype = "json"        // 指定datatype为json，将按json格式反序列化数据\n)\nmap getdata();               // 请求响应的结果将被转换为map类型对象\n\n\n1\n2\n3\n4\n5\n\n\n\n# decoder\n\nforest 也可以通过请求注解 (诸如：@request、@get、@post 等) 的decoder属性来指定具体处理该请求结果的反序列化的转换器\n\n\n\n\n\n \n\n\n\n\n// 指定由 jackson 转换器处理请求的反序列化\n@get(\n    url = "http://localhost:8080/data",\n    decoder = forestjacksonconverter.class\n)\nmap getdata();\n\n\n1\n2\n3\n4\n5\n6\n\n\n提示\n\n和 encoder 一样的道理，如方法不指定 decoder，则会去找接口上有没有设置 decoder，如接口上也没有则使用全局的转换器为改方法请求的 decoder\n\n\n# 转换器\n\n在forest中，序列化和反序列化过程都有forest转换器来实现，其数据在forest中的转换过程如图所示:\n\nforest提供了默认的转换器，其分成五大类：文本转换器、json转换器、xml转换器、二进制转换器、自动转换器。 各大类还可以继续细分为更具体的转换器，可以按类继承理解其分类。\n\n转换器的继承体系请看如下树状结构：\n\nforestconverter接口\n ├── defaulttextconverter类\n ├── forestjsonconverter接口\n |    ├── forestfastjsonconverter类\n |    ├── forestjacksonconverter类\n |    └── forestgsonconverter类\n ├── forestxmlconverter接口\n |    └── forestjaxbconverter类\n ├── defaultbinaryconverter类\n └── defaultautoconverter类\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以替换和使用的转换器类如下表：\n\n转换器类                      类型       描述\ndefaulttextconverter      text     默认文本数据转换器\nforestfastjsonconverter   json     基于fastjson框架的json转换器\nforestjacksonconverter    json     基于jackson框架的json转换器\nforestgsonconverter       json     基于gson框架的json转换器\nforestjaxbconverter       xml      基于jaxb框架的xml转换器\ndefaultbinaryconverter    binary   默认二进制转换器，多在文件下载时使用\ndefaultautoconverter      auto     自动类型转换器，可以根据响应返回的数据自动嗅探数据类型并使用对应的转换器进行转换\n\n\n# 配置全局转换器\n\n在forest中已定义好默认的转换器，比如json的默认转为器为forestfastjsonconverter，即fastjson的转换器\n\nforest:\n  # 转换器配置，支持 json, xml, text, binary 四种数据类型的配置\n  converters:\n    # json转换器\n    json:\n      # json转换器设置为jackson转换器\n      type: com.dtflys.forest.converter.json.forestjacksonconverter\n      # json转换器设置为gson转换器\n      # type: com.dtflys.forest.converter.json.forestgsonconverter\n      # json转换器设置为fastjson转换器\n      # type: com.dtflys.forest.converter.json.forestfastjsonconverter\n      \n      # 转换器的参数设置\n      parameters:\n        # json数据转换器的全局日期格式化配置\n        dateformat: yyyy/mm/dd hh:mm:ss\n        \n    # xml转换器\n    xml:\n      # 配置为jaxb转换器\n      type: com.dtflys.forest.converter.xml.forestjaxbconverter\n\n    # 二进制转换器\n    binary:\n      # 配置为forest默认二进制转换器\n      type: com.dtflys.forest.converter.binary.defaultbinaryconverter\n\n    # 文本转换器\n    text:\n      # 配置为forest默认文本转换器\n      type: com.dtflys.forest.converter.text.defaulttextconverter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 转换器配置，支持 json, xml, text, binary 四种数据类型的配置\n\n# json转换器\n# json转换器设置为jackson的转换器\nforest.converters.json.type=com.dtflys.forest.converter.json.forestjacksonconverter\n# json转换器设置为gson转换器\n# forest.converters.json.type=com.dtflys.forest.converter.json.forestgsonconverter\n# json转换器设置为fastjson转换器\n# forest.converters.json.type=com.dtflys.forest.converter.json.forestfastjsonconverter\n      \n# 转换器的参数设置\n# json数据转换器的全局日期格式化配置\nforest.converters.json.parameters.dateformat: yyyy/mm/dd hh:mm:ss\n        \n# xml转换器\n# 配置为jaxb转换器\nforest.converters.xml.type=com.dtflys.forest.converter.xml.forestjaxbconverter\n\n# 二进制转换器\n# 配置为forest默认二进制转换器\nforest.converters.binary.type: com.dtflys.forest.converter.binary.defaultbinaryconverter\n\n# 文本转换器\n# 配置为forest默认文本转换器\nforest.converters.text.type: com.dtflys.forest.converter.text.defaulttextconverter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n<forest:configuration>\n    \x3c!-- forest转换器定义 开始 --\x3e\n    \x3c!-- 设置json转换器 --\x3e\n    \x3c!-- json转换器设置为jackson的转换器 --\x3e\n    <forest:converter datatype="json" class="com.dtflys.forest.converter.json.forestjacksonconverter">\n        <forest:parameter name="dateformat" value="yyyy/mm/dd hh:mm:ss"/>\n    </forest:converter>\n    \n    \x3c!-- json转换器设置为gson转换器 --\x3e\n    \x3c!--\n    <forest:converter datatype="json" class="com.dtflys.forest.converter.json.forestgsonconverter">\n        <forest:parameter name="dateformat" value="yyyy/mm/dd hh:mm:ss"/>\n    </forest:converter>\n    --\x3e\n\n    \x3c!-- json转换器设置为fastjson转换器 --\x3e\n    \x3c!--\n    <forest:converter datatype="json" class="com.dtflys.forest.converter.json.forestfastjsonconverter">\n        <forest:parameter name="dateformat" value="yyyy/mm/dd hh:mm:ss"/>\n    </forest:converter>\n    --\x3e\n\n    \x3c!-- 设置xml转换器 --\x3e\n    <forest:converter datatype="xml" class="com.dtflys.forest.converter.xml.forestjaxbconverter">\n    </forest:converter>\n    \x3c!-- forest转换器定义 结束 --\x3e\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n// 获取全局默认配置对象\nforestconfiguration configuration = forest.config();\n// 更换json转换器为fastjson\nconfiguration.setjsonconverter(new forestfastjsonconverter());\n// 更换json转换器为jackson\nconfiguration.setjsonconverter(new forestjacksonconverter());\n// 更换json转换器gson\nconfiguration.setjsonconverter(new forestgsonconverter());\n// 更换xml转换器jaxb\nconfiguration.getconvertermap().put(forestdatatype.xml, new forestjaxbconverter());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# springboot 下配置全局转换器\n\n在 springboot 环境下，可以无视上面的配置文件，取而代之的是一个更简单、更灵活、更 springboot 的做法，即通过 @bean 注解定义的方法返回一个forestconverter接口的现实类实例\n\n\n# fastjson 转换器\n\n@bean\npublic forestjsonconverter forestfastjsonconverter() {\n    forestfastjsonconverter converter = new forestfastjsonconverter();\n    // 设置日期格式\n    converter.setdateformat("yyyy-mm-dd hh:mm:ss");\n    // 设置序列化特性\n    converter.setserializerfeature(serializerfeature.ignoreerrorgetter);\n    return converter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# jackson 转换器\n\n@bean\npublic forestjsonconverter forestjacksonconverter() {\n    forestjacksonconverter converter = new forestjacksonconverter();\n    // 设置日期格式\n    converter.setdateformat("yyyy-mm-dd hh:mm:ss");\n    // 获取 jackson 的 objectmapper 对象\n    objectmapper mapper = converter.getmapper();\n    // 通过 objectmapper 对象可以对 jackson 转换器做更细致的设置\n    return converter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# gson 转换器\n\n@bean\npublic forestjsonconverter forestgsonconverter() {\n    forestgsonconverter converter = new forestgsonconverter();\n    // 设置日期格式\n    converter.setdateformat("yyyy-mm-dd hh:mm:ss");\n    return converter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n提示\n\n各类转换器 (如 json、xml转换器) 全局的 bean 只能有一个，同时定义了多个 forestjsonconverter (以 json 为例) 的 bean 到 spring 上下文中\n\n则要通过上文介绍的配置方式来指定全局转换具体是哪一个\n\n\n# 配置接口/方法级别转换器\n\n使用@bodytype注解定义encoder\n\n// 接口级别转换器定义\n@bodytype(type = "json", encoder = forestjacksonconverter.class)\npublic interface myclient {\n\n    // 方法级别转换器定义\n    @get("/data")\n    @bodytype(type = "json", encoder = forestfastjsonconverter.class)\n    string senddata(@body mydata data);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n具体使用方式，请参见《指定 encoder》和《json 编码器快捷注解》\n\n\n# 自定义转换器\n\n请参见 《自定义转换器》',charsets:{cjk:!0},lastUpdated:"2022/07/21, 00:37:03",lastUpdatedTimestamp:1658335023e3},{title:"📬 接收数据",frontmatter:{id:"receive_data",title:"📬 接收数据",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/receive_data/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/009.receive_data.html",relativePath:"001.v1.5.x文档/040.声明式接口/009.receive_data.md",key:"v-5954d9e8",path:"/pages/1.5.x/receive_data/",headers:[{level:3,title:"反序列化",slug:"反序列化",normalizedTitle:"反序列化",charIndex:2},{level:3,title:"返回请求对象",slug:"返回请求对象",normalizedTitle:"返回请求对象",charIndex:1372},{level:3,title:"返回响应对象",slug:"返回响应对象",normalizedTitle:"返回响应对象",charIndex:2183},{level:3,title:"拦截器中获取响应对象",slug:"拦截器中获取响应对象",normalizedTitle:"拦截器中获取响应对象",charIndex:3930},{level:3,title:"回调函数中获取响应对象",slug:"回调函数中获取响应对象",normalizedTitle:"回调函数中获取响应对象",charIndex:4431},{level:3,title:"获取响应头",slug:"获取响应头",normalizedTitle:"获取响应头",charIndex:4903}],headersStr:"反序列化 返回请求对象 返回响应对象 拦截器中获取响应对象 回调函数中获取响应对象 获取响应头",content:'# 反序列化\n\nForest请求会自动将响应的返回数据反序列化成您要的数据类型。想要接受指定类型的数据需要完成两步操作：\n\n第一步：定义dataType属性\n\ndataType属性指定了该请求响应返回的数据类型，目前可选的数据类型有三种: text, json, xml\n\nForest会根据您指定的dataType属性选择不同的反序列化方式。其中dataType的默认值为text，如果您不指定其他数据类型，那么Forest就不会做任何形式的序列化，并以文本字符串的形式返回给你数据。\n\n/**\n * dataType为text或不填时，请求响应的数据将以文本字符串的形式返回回来\n */\n@Request(\n    url = "http://localhost:8080/text/data",\n    dataType = "text"\n)\nString getData();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n若您指定为json或xml，那就告诉了Forest该请求的响应数据类型为JSON或XML形式的数据，就会以相应的形式进行反序列化。\n\n/**\n * dataType为json或xml时，Forest会进行相应的反序列化\n */\n@Request(\n    url = "http://localhost:8080/text/data",\n    dataType = "json"\n)\nMap getData();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第二步：指定反序列化的目标类型\n\n反序列化需要一个目标类型，而该类型其实就是方法的返回值类型，如返回值为String就会反序列成String字符串，返回值为Map就会反序列化成一个HashMap对象，您也可以指定为自定义的Class类型。\n\npublic class User {\n    private String username;\n    private String score;\n    \n    // Setter和Getter ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如有上面这样的User类，并把它指定为方法的返回类型，而且相应返回的数据这样一段JSON：\n\n{"username":  "Foo", "score":  "82"}\n\n\n1\n\n\n那请求接口就应该定义成这样：\n\n/**\n * dataType属性指明了返回的数据类型为JSON\n */\n@Get(\n    url = "http://localhost:8080/user?id=${0}",\n    dataType = "json"\n)\nUser getUser(Integer id)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n从1.4.0版本开始，dataType 属性默认为 auto（自动判断数据类型）， 也就是说 dataType 属性可以完全省略不填，Forest会自行判断返回的数据类型是哪种格式。\n\n/**\n * 省略dataType属性会自动判断返回的数据格式并进行反序列化\n */\n@Get("http://localhost:8080/user?id=${0}")\nUser getUser(Integer id)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 返回请求对象\n\n如果将ForestRequest作为请求方法的返回值类型，调用该方法时不会立即执行请求发送的过程，而是直接返回一个ForestRequest对象。\n\n这样做的好处是，可以延迟发送HTTP请求，并对要即将发送的请求参数做进一步的修改和加工。\n\npublic interface MyForestClient {\n\n    /**\n     * Get类型请求，url路径为 /test\n     * <p>ForestRequest是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return Forest请求对象\n     */\n    @Get("/test")\n    ForestRequest<?> getForestRequest();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在调用getForestRequest()方法后获得该请求方法所对应的请求对象\n\n// 如果请求方法以 ForestRequest 作为返回值类型\n// 不会直接发送请求\n// 而是直接返回 Forest 请求对象\nForestRequest<?> request = myForestClient.getForestRequest();\nString path = request.path(); // 得到字符串 /test\n// 手动执行发送请求，并以字符串形式接受响应数据\nString ret = request.execute(String.class); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n获得 Forest 请求对象时并不会自动发送请求，需要调用execute()或execute(Class)这类方法手动执行请求发送的过程。\n\n文档导航\n\n要详细了解如何手动执行请求发送，请参见《执行请求》\n\n\n# 返回响应对象\n\n直接用普通的对象类型作为请求方法的返回类型，可以将响应数据方便的反序列化，以满足大部分的需求。但还有很多时候不光需要获取响应内容，也需要得到响应头等信息，这时候就需要 ForestResponse 出场了。\n\n将ForestResponse作为请求方法的返回值类型\n\n\n/**\n * ForestResponse 可以作为请求方法的返回类型\n * ForestResponse 为带泛型的类，其泛型参数中填的类作为其响应反序列化的目标类型\n */\n@Post("http://localhost:8080/user")\nForestResponse<String> postUser(@JSONBody User user);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n用ForestResponse对象接到请求响应数据后便可以获取响应内容\n\n// 以ForestResponse类型变量接受响应数据\nForestResponse<String> response = client.postUser(user);\n\n// 用isError方法去判断请求是否失败\nif (response.isError()) {\n    ... ...\n}\n\n// 用isSuccess方法去判断请求是否成功\nif (response.isSuccess()) {\n    ... ...\n}\n\n// 以字符串方式读取请求响应内容\nString text = response.readAsString();\n\n// getContent方法可以获取请求响应内容文本\n// 和readAsString方法不同的地方在于，getContent方法不会读取二进制形式数据内容，\n// 而readAsString方法会将二进制数据转换成字符串读取\nString content = response.getContent();\n\n// 获取反序列化成对象类型的请求响应内容\n// 因为返回类型为ForetReponse<String>, 其泛型参数为String\n// 所以这里也用String类型获取结果        \nString result = response.getResult();\n\n// 以字节数组的形式获取请求响应内容\nbyte[] byteArray = response.getByteArray();\n\n// 以输入流的形式获取请求响应内容\nInputStream in = response.getInputStream();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n因为ForestResponse为带泛型的类型，其泛型参数可以是任何其他类型，所以可以根据它的泛型参数中的类型不同，而将响应内容反序列化成不同的对象。\n\n\n/**\n * ForestResponse 可以作为请求方法的返回类型\n * ForestResponse 为带泛型的类，其泛型参数中填的类作为其响应反序列化的目标类型\n */\n@Get("http://localhost:8080/user")\nForestResponse<User> getUser(@Query("id") String userId);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同样是用ForestResponse类型变量去接受响应数据\n\nForestResponse<User> response = client.postUser(user);\n// 判断请求是否成功\nif (response.isSuccess()) {\n    // 通过getResult方法获取其响应内容反序列化后的结果\n    // 因为返回类型 ForestResponse<User> 中泛型参数为 User,\n    // 所以得到反序列化后的对象也是User类型对象    \n    User user = response.getResult();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 拦截器中获取响应对象\n\npublic class SimpleInterceptor1 implements Interceptor<String> {\n    ... ...\n    /**\n     * 该方法在请求发送之后被调用\n     */\n    @Override\n    public void afterExecute(ForestRequest request, ForestResponse response) {\n        // 执行在发送请求之后处理的代码\n        int status = response.getStatusCode(); // 获取请求响应状态码\n        String content = response.getContent(); // 获取请求的响应内容\n        String result = response.getResult(); // 获取方法返回类型对应的最终数据结果\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n文档导航\n\n拦截器详细内容请参见《拦截器》\n\n\n# 回调函数中获取响应对象\n\n@Post("http://localhost:8080/user")\nvoid postUser(@JSONBody User user, OnSuccess<String> onSuccess);\n\n... ...\n\nclient.postUser(user, (String resText, ForestRequest request, ForestResponse response) -> {\n    // 在成功接收请求响应后处理\n    int status = response.getStatusCode(); // 获取请求响应状态码\n    String content = response.getContent(); // 获取请求的响应内容\n    String result = response.getResult(); // 获取方法返回类型对应的最终数据结果\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n文档导航\n\n回调函数详细内容请参见《回调函数》\n\n\n# 获取响应头\n\n要获取响应头首先要获取响应对象，也就是ForestResponse对象，这一步可以参见《获取响应对象》。\n\n获取ForestResponse对象后便可以获取响应头了\n\n\nForestResponse<String> response = client.textXXX();\n\n// 根据响应头名称获取单个请求响应头\nForestHeader header = response.getHeader("Content-Type");\n// 响应头名称\nString headerName = header.getName();\n// 响应头值\nString headerValue = header.getValue();\n\n// 根据响应头名称获取请求响应头列表\nList<ForestHeader> heaers = response.getHeaders("Content-Type");\n\n// 根据响应头名称获取请求响应头值\nString val = response.getHeaderValue("Content-Type");\n\n// 根据响应头名称获取请求响应头值列表\nList<String> vals = response.getHeaderValues("Content-Type");\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',normalizedContent:'# 反序列化\n\nforest请求会自动将响应的返回数据反序列化成您要的数据类型。想要接受指定类型的数据需要完成两步操作：\n\n第一步：定义datatype属性\n\ndatatype属性指定了该请求响应返回的数据类型，目前可选的数据类型有三种: text, json, xml\n\nforest会根据您指定的datatype属性选择不同的反序列化方式。其中datatype的默认值为text，如果您不指定其他数据类型，那么forest就不会做任何形式的序列化，并以文本字符串的形式返回给你数据。\n\n/**\n * datatype为text或不填时，请求响应的数据将以文本字符串的形式返回回来\n */\n@request(\n    url = "http://localhost:8080/text/data",\n    datatype = "text"\n)\nstring getdata();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n若您指定为json或xml，那就告诉了forest该请求的响应数据类型为json或xml形式的数据，就会以相应的形式进行反序列化。\n\n/**\n * datatype为json或xml时，forest会进行相应的反序列化\n */\n@request(\n    url = "http://localhost:8080/text/data",\n    datatype = "json"\n)\nmap getdata();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第二步：指定反序列化的目标类型\n\n反序列化需要一个目标类型，而该类型其实就是方法的返回值类型，如返回值为string就会反序列成string字符串，返回值为map就会反序列化成一个hashmap对象，您也可以指定为自定义的class类型。\n\npublic class user {\n    private string username;\n    private string score;\n    \n    // setter和getter ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如有上面这样的user类，并把它指定为方法的返回类型，而且相应返回的数据这样一段json：\n\n{"username":  "foo", "score":  "82"}\n\n\n1\n\n\n那请求接口就应该定义成这样：\n\n/**\n * datatype属性指明了返回的数据类型为json\n */\n@get(\n    url = "http://localhost:8080/user?id=${0}",\n    datatype = "json"\n)\nuser getuser(integer id)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n从1.4.0版本开始，datatype 属性默认为 auto（自动判断数据类型）， 也就是说 datatype 属性可以完全省略不填，forest会自行判断返回的数据类型是哪种格式。\n\n/**\n * 省略datatype属性会自动判断返回的数据格式并进行反序列化\n */\n@get("http://localhost:8080/user?id=${0}")\nuser getuser(integer id)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 返回请求对象\n\n如果将forestrequest作为请求方法的返回值类型，调用该方法时不会立即执行请求发送的过程，而是直接返回一个forestrequest对象。\n\n这样做的好处是，可以延迟发送http请求，并对要即将发送的请求参数做进一步的修改和加工。\n\npublic interface myforestclient {\n\n    /**\n     * get类型请求，url路径为 /test\n     * <p>forestrequest是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return forest请求对象\n     */\n    @get("/test")\n    forestrequest<?> getforestrequest();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在调用getforestrequest()方法后获得该请求方法所对应的请求对象\n\n// 如果请求方法以 forestrequest 作为返回值类型\n// 不会直接发送请求\n// 而是直接返回 forest 请求对象\nforestrequest<?> request = myforestclient.getforestrequest();\nstring path = request.path(); // 得到字符串 /test\n// 手动执行发送请求，并以字符串形式接受响应数据\nstring ret = request.execute(string.class); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n获得 forest 请求对象时并不会自动发送请求，需要调用execute()或execute(class)这类方法手动执行请求发送的过程。\n\n文档导航\n\n要详细了解如何手动执行请求发送，请参见《执行请求》\n\n\n# 返回响应对象\n\n直接用普通的对象类型作为请求方法的返回类型，可以将响应数据方便的反序列化，以满足大部分的需求。但还有很多时候不光需要获取响应内容，也需要得到响应头等信息，这时候就需要 forestresponse 出场了。\n\n将forestresponse作为请求方法的返回值类型\n\n\n/**\n * forestresponse 可以作为请求方法的返回类型\n * forestresponse 为带泛型的类，其泛型参数中填的类作为其响应反序列化的目标类型\n */\n@post("http://localhost:8080/user")\nforestresponse<string> postuser(@jsonbody user user);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n用forestresponse对象接到请求响应数据后便可以获取响应内容\n\n// 以forestresponse类型变量接受响应数据\nforestresponse<string> response = client.postuser(user);\n\n// 用iserror方法去判断请求是否失败\nif (response.iserror()) {\n    ... ...\n}\n\n// 用issuccess方法去判断请求是否成功\nif (response.issuccess()) {\n    ... ...\n}\n\n// 以字符串方式读取请求响应内容\nstring text = response.readasstring();\n\n// getcontent方法可以获取请求响应内容文本\n// 和readasstring方法不同的地方在于，getcontent方法不会读取二进制形式数据内容，\n// 而readasstring方法会将二进制数据转换成字符串读取\nstring content = response.getcontent();\n\n// 获取反序列化成对象类型的请求响应内容\n// 因为返回类型为foretreponse<string>, 其泛型参数为string\n// 所以这里也用string类型获取结果        \nstring result = response.getresult();\n\n// 以字节数组的形式获取请求响应内容\nbyte[] bytearray = response.getbytearray();\n\n// 以输入流的形式获取请求响应内容\ninputstream in = response.getinputstream();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n因为forestresponse为带泛型的类型，其泛型参数可以是任何其他类型，所以可以根据它的泛型参数中的类型不同，而将响应内容反序列化成不同的对象。\n\n\n/**\n * forestresponse 可以作为请求方法的返回类型\n * forestresponse 为带泛型的类，其泛型参数中填的类作为其响应反序列化的目标类型\n */\n@get("http://localhost:8080/user")\nforestresponse<user> getuser(@query("id") string userid);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同样是用forestresponse类型变量去接受响应数据\n\nforestresponse<user> response = client.postuser(user);\n// 判断请求是否成功\nif (response.issuccess()) {\n    // 通过getresult方法获取其响应内容反序列化后的结果\n    // 因为返回类型 forestresponse<user> 中泛型参数为 user,\n    // 所以得到反序列化后的对象也是user类型对象    \n    user user = response.getresult();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 拦截器中获取响应对象\n\npublic class simpleinterceptor1 implements interceptor<string> {\n    ... ...\n    /**\n     * 该方法在请求发送之后被调用\n     */\n    @override\n    public void afterexecute(forestrequest request, forestresponse response) {\n        // 执行在发送请求之后处理的代码\n        int status = response.getstatuscode(); // 获取请求响应状态码\n        string content = response.getcontent(); // 获取请求的响应内容\n        string result = response.getresult(); // 获取方法返回类型对应的最终数据结果\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n文档导航\n\n拦截器详细内容请参见《拦截器》\n\n\n# 回调函数中获取响应对象\n\n@post("http://localhost:8080/user")\nvoid postuser(@jsonbody user user, onsuccess<string> onsuccess);\n\n... ...\n\nclient.postuser(user, (string restext, forestrequest request, forestresponse response) -> {\n    // 在成功接收请求响应后处理\n    int status = response.getstatuscode(); // 获取请求响应状态码\n    string content = response.getcontent(); // 获取请求的响应内容\n    string result = response.getresult(); // 获取方法返回类型对应的最终数据结果\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n文档导航\n\n回调函数详细内容请参见《回调函数》\n\n\n# 获取响应头\n\n要获取响应头首先要获取响应对象，也就是forestresponse对象，这一步可以参见《获取响应对象》。\n\n获取forestresponse对象后便可以获取响应头了\n\n\nforestresponse<string> response = client.textxxx();\n\n// 根据响应头名称获取单个请求响应头\nforestheader header = response.getheader("content-type");\n// 响应头名称\nstring headername = header.getname();\n// 响应头值\nstring headervalue = header.getvalue();\n\n// 根据响应头名称获取请求响应头列表\nlist<forestheader> heaers = response.getheaders("content-type");\n\n// 根据响应头名称获取请求响应头值\nstring val = response.getheadervalue("content-type");\n\n// 根据响应头名称获取请求响应头值列表\nlist<string> vals = response.getheadervalues("content-type");\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍓 成功/失败条件",frontmatter:{id:"success",title:"🍓 成功/失败条件",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/success/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/011.success.html",relativePath:"001.v1.5.x文档/040.声明式接口/011.success.md",key:"v-a1d890b4",path:"/pages/1.5.x/success/",headers:[{level:2,title:"默认成功/失败条件",slug:"默认成功-失败条件",normalizedTitle:"默认成功/失败条件",charIndex:152},{level:2,title:"自定义成功/失败条件",slug:"自定义成功-失败条件",normalizedTitle:"自定义成功/失败条件",charIndex:407},{level:3,title:"使用 @Success 注解",slug:"使用-success-注解",normalizedTitle:"使用 @success 注解",charIndex:478},{level:4,title:"第一步，先要定义 SuccessWhen 接口的实现类",slug:"第一步-先要定义-successwhen-接口的实现类",normalizedTitle:"第一步，先要定义 successwhen 接口的实现类",charIndex:496},{level:4,title:"第二步，挂上 @Success 注解",slug:"第二步-挂上-success-注解",normalizedTitle:"第二步，挂上 @success 注解",charIndex:1391},{level:4,title:"接口上的成功/失败条件",slug:"接口上的成功-失败条件",normalizedTitle:"接口上的成功/失败条件",charIndex:1794},{level:3,title:"全局请求成功/失败条件",slug:"全局请求成功-失败条件",normalizedTitle:"全局请求成功/失败条件",charIndex:2897},{level:3,title:"手动设置请求成功/失败条件",slug:"手动设置请求成功-失败条件",normalizedTitle:"手动设置请求成功/失败条件",charIndex:3485}],headersStr:"默认成功/失败条件 自定义成功/失败条件 使用 @Success 注解 第一步，先要定义 SuccessWhen 接口的实现类 第二步，挂上 @Success 注解 接口上的成功/失败条件 全局请求成功/失败条件 手动设置请求成功/失败条件",content:'Forest 对每个请求都会判断其发送和响应结果是否成功。\n\n成功，就会去执行OnSuccess回调函数和拦截器中的onSuccess方法，并返回响应结果。\n\n失败，则会进行重试，如果该请求不允许重试，或者达到了最大重试次数限制，则会调用OnError回调函数，和拦截器中的onError方法。\n\n\n# 默认成功/失败条件\n\nForest 提供了默认的请求成功/失败条件，其逻辑如下:\n\n 1. 判断是否在发送和等待响应的过程中出现异常，如: 网络连接错误、超时等\n 2. 在取得响应结果后，判断其响应状态码是否在正常范围内 (100 ~ 399)\n\n以上两条判断条件如有一条不满足，则就判定为请求失败，否则为成功。\n\n默认的判断条件可以满足绝大部分场景的需要，也比较符合HTTP协议标准的规范，但也存在一些特殊场景，并不以HTTP标准为判断逻辑，这时候就需要用户进行自定义的请求成功/失败条件的判断了。\n\n\n# 自定义成功/失败条件\n\n这里举一个栗子，除了正常的异常判断外，当响应码为203的时候判断为请求失败。这样的条件如何定义请看如下代码：\n\n\n# 使用 @Success 注解\n\n# 第一步，先要定义 SuccessWhen 接口的实现类\n\n// 自定义成功/失败条件实现类\n// 需要实现 SuccessWhen 接口\npublic class MySuccessCondition implements SuccessWhen {\n\n    /**\n     * 请求成功条件\n     * @param req Forest请求对象\n     * @param res Forest响应对象\n     * @return 是否成功，true: 请求成功，false: 请求失败\n     */\n    @Override\n    public boolean successWhen(ForestRequest req, ForestResponse res) {\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // res 为Forest响应对象，即 ForestResponse 类实例\n        // 返回值为 ture 则表示请求成功，false 表示请求失败\n        return res.noException() &&   // 请求过程没有异常\n                res.statusOk() &&     // 并且状态码在 100 ~ 399 范围内\n                res.statusIsNot(203); // 但不能是 203\n        // 当然在这里也可以写其它条件，比如 通过 res.getResult() 或 res.getContent() 获取业务数据\n        // 再更具业务数据判断是否成功\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n特别注意\n\n在successWhen方法的逻辑代码中，千万不能调用 res.isSuccess() 或 !res.isError() 进行判断\n\n不然会引起死循环\n\n# 第二步，挂上 @Success 注解\n\npublic interface MyClient {\n    /**\n     * 挂上了 @Success 注解\n     * <p>该方法的请求是否成功\n     * <p>以自定义成功条件类 MySuccessCondition 的判断方法为准\n     * \n     * @return 请求响应结果\n     */\n    @Get("/")\n    @Success(condition = MySuccessCondition.class)\n    String sendData();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n若调用sendData()方法后，返回的状态码为 203, 就会被认为是请求失败，如果设置了重试次数大于0，就会去执行重试任务。 若没有重试次数可用，则进入 onError 请求失败流程\n\n# 接口上的成功/失败条件\n\n@Success注解也可以挂在interface接口类上，代表其下的所有请求方法都设置为此自定义条件\n\n/**\n * interface 上挂了 @Success 注解\n * <p>该接口类下的所有方法都依据\n * <p>自定义的 MySuccessCondition 请求成功条件类\n * <p>为请求是否成功的判定条件\n */\n@Success(condition = MySuccessCondition.class)\npublic interface MyClient {\n    \n    @Get("/test1")\n    String sendData1();\n\n    @Get("/test2")\n    String sendData2();\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n此时，不管是调用sendData1()还是sendData2()方法，都会依据 MySuccessCondition 的判定条件为准\n\n如果其中有一个方法想以另一种逻辑作为请求成功/失败的判断条件，可以在那个方法上加上@Success注解\n\n/**\n * interface 上挂了 @Success 注解\n * <p>该接口类下的所有方法都依据\n * <p>自定义的 MySuccessCondition1 请求成功条件类\n * <p>为请求是否成功的判定条件\n * <p>除非该方法定义了自己的请求成功条件\n */\n@Success(condition = MySuccessCondition1.class)\npublic interface MyClient {\n    \n    // 以 MySuccessCondition1 作为成功判断条件\n    @Get("/test1")\n    String sendData1();\n\n    // 以 MySuccessCondition1 作为成功判断条件\n    @Get("/test2")\n    String sendData2();\n\n    // 以 MySuccessCondition2 作为成功判断条件\n    @Get("/test3")\n    @Success(condition = MySuccessCondition2.class)\n    String sendData3();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 全局请求成功/失败条件\n\n在 spring boot 环境下，可以在 application.yml 等全局配置文件中设置全局的请求成功/失败条件\n\nforest:\n    # MySuccessCondition 为您自定义的 SuccessWhen 实现类\n    # 通过 forest.success-when 属性配置全局请求成功/失败条件类\n    success-when: com.your.site.MySuccessCondition\n\n\n1\n2\n3\n4\n\n\n在其它环境可以通过ForestConfiguration对象的setSuccessWhenClass(Class<? extends SuccessWhen> successWhenClass)进行设置\n\n// 获取默认全局配置对象\nForestConfiguration configuration = Forest.config();\n// MySuccessCondition 为您自定义的 SuccessWhen 实现类\n// 调用 setSuccessWhenClass 设置全局请求成功/失败条件类\nconfiguration.setSuccessWhenClass(com.your.site.MySuccessCondition.class);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 手动设置请求成功/失败条件\n\n文档导航\n\nForestRequest 对象如何手动设置请求成功/失败条件，请参见《请求设置对象成功/失败条件》',normalizedContent:'forest 对每个请求都会判断其发送和响应结果是否成功。\n\n成功，就会去执行onsuccess回调函数和拦截器中的onsuccess方法，并返回响应结果。\n\n失败，则会进行重试，如果该请求不允许重试，或者达到了最大重试次数限制，则会调用onerror回调函数，和拦截器中的onerror方法。\n\n\n# 默认成功/失败条件\n\nforest 提供了默认的请求成功/失败条件，其逻辑如下:\n\n 1. 判断是否在发送和等待响应的过程中出现异常，如: 网络连接错误、超时等\n 2. 在取得响应结果后，判断其响应状态码是否在正常范围内 (100 ~ 399)\n\n以上两条判断条件如有一条不满足，则就判定为请求失败，否则为成功。\n\n默认的判断条件可以满足绝大部分场景的需要，也比较符合http协议标准的规范，但也存在一些特殊场景，并不以http标准为判断逻辑，这时候就需要用户进行自定义的请求成功/失败条件的判断了。\n\n\n# 自定义成功/失败条件\n\n这里举一个栗子，除了正常的异常判断外，当响应码为203的时候判断为请求失败。这样的条件如何定义请看如下代码：\n\n\n# 使用 @success 注解\n\n# 第一步，先要定义 successwhen 接口的实现类\n\n// 自定义成功/失败条件实现类\n// 需要实现 successwhen 接口\npublic class mysuccesscondition implements successwhen {\n\n    /**\n     * 请求成功条件\n     * @param req forest请求对象\n     * @param res forest响应对象\n     * @return 是否成功，true: 请求成功，false: 请求失败\n     */\n    @override\n    public boolean successwhen(forestrequest req, forestresponse res) {\n        // req 为forest请求对象，即 forestrequest 类实例\n        // res 为forest响应对象，即 forestresponse 类实例\n        // 返回值为 ture 则表示请求成功，false 表示请求失败\n        return res.noexception() &&   // 请求过程没有异常\n                res.statusok() &&     // 并且状态码在 100 ~ 399 范围内\n                res.statusisnot(203); // 但不能是 203\n        // 当然在这里也可以写其它条件，比如 通过 res.getresult() 或 res.getcontent() 获取业务数据\n        // 再更具业务数据判断是否成功\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n特别注意\n\n在successwhen方法的逻辑代码中，千万不能调用 res.issuccess() 或 !res.iserror() 进行判断\n\n不然会引起死循环\n\n# 第二步，挂上 @success 注解\n\npublic interface myclient {\n    /**\n     * 挂上了 @success 注解\n     * <p>该方法的请求是否成功\n     * <p>以自定义成功条件类 mysuccesscondition 的判断方法为准\n     * \n     * @return 请求响应结果\n     */\n    @get("/")\n    @success(condition = mysuccesscondition.class)\n    string senddata();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n若调用senddata()方法后，返回的状态码为 203, 就会被认为是请求失败，如果设置了重试次数大于0，就会去执行重试任务。 若没有重试次数可用，则进入 onerror 请求失败流程\n\n# 接口上的成功/失败条件\n\n@success注解也可以挂在interface接口类上，代表其下的所有请求方法都设置为此自定义条件\n\n/**\n * interface 上挂了 @success 注解\n * <p>该接口类下的所有方法都依据\n * <p>自定义的 mysuccesscondition 请求成功条件类\n * <p>为请求是否成功的判定条件\n */\n@success(condition = mysuccesscondition.class)\npublic interface myclient {\n    \n    @get("/test1")\n    string senddata1();\n\n    @get("/test2")\n    string senddata2();\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n此时，不管是调用senddata1()还是senddata2()方法，都会依据 mysuccesscondition 的判定条件为准\n\n如果其中有一个方法想以另一种逻辑作为请求成功/失败的判断条件，可以在那个方法上加上@success注解\n\n/**\n * interface 上挂了 @success 注解\n * <p>该接口类下的所有方法都依据\n * <p>自定义的 mysuccesscondition1 请求成功条件类\n * <p>为请求是否成功的判定条件\n * <p>除非该方法定义了自己的请求成功条件\n */\n@success(condition = mysuccesscondition1.class)\npublic interface myclient {\n    \n    // 以 mysuccesscondition1 作为成功判断条件\n    @get("/test1")\n    string senddata1();\n\n    // 以 mysuccesscondition1 作为成功判断条件\n    @get("/test2")\n    string senddata2();\n\n    // 以 mysuccesscondition2 作为成功判断条件\n    @get("/test3")\n    @success(condition = mysuccesscondition2.class)\n    string senddata3();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 全局请求成功/失败条件\n\n在 spring boot 环境下，可以在 application.yml 等全局配置文件中设置全局的请求成功/失败条件\n\nforest:\n    # mysuccesscondition 为您自定义的 successwhen 实现类\n    # 通过 forest.success-when 属性配置全局请求成功/失败条件类\n    success-when: com.your.site.mysuccesscondition\n\n\n1\n2\n3\n4\n\n\n在其它环境可以通过forestconfiguration对象的setsuccesswhenclass(class<? extends successwhen> successwhenclass)进行设置\n\n// 获取默认全局配置对象\nforestconfiguration configuration = forest.config();\n// mysuccesscondition 为您自定义的 successwhen 实现类\n// 调用 setsuccesswhenclass 设置全局请求成功/失败条件类\nconfiguration.setsuccesswhenclass(com.your.site.mysuccesscondition.class);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 手动设置请求成功/失败条件\n\n文档导航\n\nforestrequest 对象如何手动设置请求成功/失败条件，请参见《请求设置对象成功/失败条件》',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍌 重试机制",frontmatter:{id:"retry",title:"🍌 重试机制",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/retry/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/012.retry.html",relativePath:"001.v1.5.x文档/040.声明式接口/012.retry.md",key:"v-207735cc",path:"/pages/1.5.x/retry/",headers:[{level:2,title:"配置全局重试信息",slug:"配置全局重试信息",normalizedTitle:"配置全局重试信息",charIndex:54},{level:2,title:"使用@Retry注解",slug:"使用-retry注解",normalizedTitle:"使用@retry注解",charIndex:801},{level:3,title:"在方法上挂上@Retry注解",slug:"在方法上挂上-retry注解",normalizedTitle:"在方法上挂上@retry注解",charIndex:816},{level:3,title:"接口上使用@Retry注解",slug:"接口上使用-retry注解",normalizedTitle:"接口上使用@retry注解",charIndex:1273},{level:2,title:"重试器",slug:"重试器",normalizedTitle:"重试器",charIndex:1710},{level:2,title:"重试条件",slug:"重试条件",normalizedTitle:"重试条件",charIndex:1242},{level:3,title:"重试流程",slug:"重试流程",normalizedTitle:"重试流程",charIndex:1128},{level:3,title:"使用@Success注解设置重试条件",slug:"使用-success注解设置重试条件",normalizedTitle:"使用@success注解设置重试条件",charIndex:3482},{level:3,title:"使用 RetryWhen 接口实现重试条件",slug:"使用-retrywhen-接口实现重试条件",normalizedTitle:"使用 retrywhen 接口实现重试条件",charIndex:3992},{level:2,title:"拦截器onRetry方法",slug:"拦截器onretry方法",normalizedTitle:"拦截器onretry方法",charIndex:4872}],headersStr:"配置全局重试信息 使用@Retry注解 在方法上挂上@Retry注解 接口上使用@Retry注解 重试器 重试条件 重试流程 使用@Success注解设置重试条件 使用 RetryWhen 接口实现重试条件 拦截器onRetry方法",content:'Forest请求在发送失败的情况下会触发重试机制，重试的次数限制、时间间隔、触发条件全部都可以配置\n\n\n# 配置全局重试信息\n\n重试属性的全局配置\n\n# 全局配置下，所有请求的默认重试信息按此配置进行\n\nforest:\n    max-retry-count: 3     # 最大请求重试次数，默认为 0 次\n    max-retry-interval: 10 # 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n\n\n1\n2\n3\n4\n5\n\n\n# 全局配置下，所有请求的默认重试信息按此配置进行\n\n# 最大请求重试次数，默认为 0 次\nforest.max-retry-count=3\n# 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒   \nforest.max-retry-interval=10\n\n\n1\n2\n3\n4\n5\n6\n\n\n\x3c!-- retryCount 最大请求重试次数，默认为 0 次 --\x3e\n\x3c!-- maxRetryInterval 最大重试时间间隔, 单位为毫秒，默认为 0 毫秒 --\x3e\n<forest:configuration\n    ... ...\n    retryCount="3"\n    maxRetryInterval="10">\n... ...\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// 获取全局默认配置对象\nForestConfiguration configuration = Forest.config();\n// 最大请求重试次数，默认为 0 次\nconfiguration.setMaxRetryCount(3);\n// 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\nconfiguration.setMaxRetryInterval(10);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 使用@Retry注解\n\n\n# 在方法上挂上@Retry注解\n\npublic interface MyClient {\n    // maxRetryCount 为最大重试次数，默认为 0 次\n    // maxRetryInterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n    @Get("/")\n    @Retry(maxRetryCount = "3", maxRetryInterval = "10")\n    String sendData();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里的@Retry注解设置了两个属性:\n\n * maxRetryCount: 请求的最大重试次数，当重试次数大于该属性，将停止触发请求重试流程，默认为0次，即不会触发重试\n * maxRetryInterval: 请求的最大重试时间间隔，单位为毫秒，默认为0毫秒，即没有时间间隔\n\n当调用该接口的sendData()方法后，若请求失败就会不断进行重试，直到不满足重试条件为止 (即请求成功，或达到最大请求次数限制)\n\n\n# 接口上使用@Retry注解\n\n@Retry注解也可以挂在interface接口类上，代表其下的所有请求方法都设置为此重试配置\n\n// maxRetryCount 为最大重试次数，默认为 0 次\n// maxRetryInterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n// 该接口下每个方法都以此为请求重试配置\n@Retry(maxRetryCount = "3", maxRetryInterval = "10")\npublic interface MyClient {\n    \n    @Get("/test1")\n    String sendData1();\n\n    @Get("/test2")\n    String sendData2();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n此时，不管调用sendData1()还是sendData2()方法，都会按最大重试3次，最大重试时间间隔10ms为重试属性\n\n\n# 重试器\n\nRetryer 重试器，即重试策略，可以设定每次重试请求之间的时间间隔\n\nForest 默认重试器类为 com.dtflys.forest.retryer.BackOffRetryer，它是依据二进制退避算法的重试策略类\n\n若配置该重试器，重试过程如下：\n\n * 第一次重试与第一次请求之间间隔 0的2次方 * 1s, 即0s\n * 第二次重试与第一次重试之间间隔 1的2次方 * 1s, 即1s\n * 第三次次重试与第二次重试之间间隔 2的2次方 * 1s, 即4s\n * 后面几次重试时间间隔以此类推，直到达到最大请求次数后停止重试\n * 每次时间间隔不能大于 maxRetryInterval, 若 maxRetryInterval 设置为 10, 则每次间隔只能为 10ms\n\n您也可以自定义重试器\n\n// 自定义重试器\n// 继承 BackOffRetryer 类\npublic class MyRetryer extends BackOffRetryer {\n\n    public MyRetryer(ForestRequest request) {\n        super(request);\n    }\n\n    /**\n     * 重写 nextInterval 方法\n     * 该方法用于指定每次重试的时间间隔\n     * @param currentCount 当前重试次数\n     * @return 时间间隔 (时间单位为毫秒)\n     */\n    @Override\n    protected long nextInterval(int currentCount) {\n        // 每次重试时间间隔恒定为 1s (1000ms)\n        return 1000;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n然后，再通过@Retryer注解绑定该自定义重试器类\n\npublic interface MyClient {\n    // maxRetryCount 为最大重试次数，默认为 0 次\n    // maxRetryInterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n    // @Retryer 注解绑定自定义的 MyRetryer 重试器类\n    // 将按照自定义的重试策略处理重试间隔时间\n    @Get("/")\n    @Retry(maxRetryCount = "3", maxRetryInterval = "10")\n    @Retryer(MyRetryer.class)\n    String sendData();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n@Retryer注解同样也可以挂在 interface 类上，这里不再赘述。\n\n\n# 重试条件\n\nForest 请求的重试条件有两种设置模式:\n\n * 将 请求成功/失败条件 作为重试条件\n * 设置 RetryWhen 重试条件\n\n这两种模式分别对应于两种不同的重试流程:\n\n\n# 重试流程\n\n 1. 请求失败后的重试流程\n\n请求失败  ✔\n └── 是否未达到请求最大重试次数 (maxRetryCount)  ✔\n      ├── 执行 OnRetry 回调函数\n      ├── 执行拦截器中的 onRetry 方法\n      ├── 发送重试请求\n      └── 回到第一步，重试请求是否成功\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 请求成功后的重试流程\n\n请求成功  ✔\n └── 是否满足重试条件 (自定义 RetryWhen 接口类条件)  ✔\n      └── 是否未达到请求最大重试次数 (maxRetryCount)  ✔\n           ├── 执行 OnRetry 回调函数\n           ├── 执行拦截器中的 onRetry 方法\n           ├── 发送重试请求\n           └── 回到第一步，重试请求是否成功，并且是否满足重试条件\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用@Success注解设置重试条件\n\n一般情况只会走第1种重试流程，即直通过请求的成功/失败来判断是否重试，逻辑很简单：请求成功不重试，失败就重试\n\n此时，可以配合@Success注解和@Retry注解组合使用\n\n\npublic interface MyClient {\n    // maxRetryCount 为最大重试次数，默认为 0 次\n    // maxRetryInterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n    // 同时请求成功/失败/重试的判定条件\n    // 设置为自定义的 MySuccessCondition 条件类\n    @Get("/")\n    @Retry(maxRetryCount = "3", maxRetryInterval = "10")\n    @Success(condition = MySuccessCondition.class)\n    String sendData();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这种方式可以同时设置重试最大次数、间隔时间、以及自定义的成功/失败/重试条件。\n\n\n# 使用 RetryWhen 接口实现重试条件\n\n但有些特殊情况，需要在请求成功的情况下也重试，满足一定业务条件后才停止重试，这种情况就需要 RetryWhen 重试条件上场了\n\n先定义自定义请求重试实现类\n\n// 自定义重试条件类\n// 需要实现 RetryWhen 接口\npublic class MyRetryCondition implements RetryWhen {\n    /**\n     * 请求重试条件\n     * @param req Forest请求对象\n     * @param res Forest响应对象\n     * @return true 重试，false 不重试\n     */\n    @Override\n    public boolean retryWhen(ForestRequest req, ForestResponse res) {\n        // 响应状态码为 203 就重试\n        return res.statusIs(203);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n然后，通过@Retry注解的condition属性指定该类\n\npublic interface MyClient {\n    // maxRetryCount 为最大重试次数\n    // maxRetryInterval 为最大重试时间间隔, 单位为毫秒\n    @Get("/")\n    @Retry(maxRetryCount = "3", maxRetryInterval = "10", condition = MyRetryCondition.class)\n    String sendData();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n若发送请求后，服务端返回203状态码，就不断触发重试，直到服务端不返回203，或达到最大重试次数，停止重试。 若最后一次重试服务端发送的还是203，则认为请求成功，执行onSuccess。\n\n\n# 拦截器onRetry方法\n\n拦截器的onRetry方法会在触发重试时，发送重试请求前被调用\n\npublic class MyRetryInterceptor implements Interceptor<Object> {\n\n    /**\n     * 在请重试前调用 onRetry 回调函数\n     *\n     * @param req Forest请求对象\n     * @param res Forest响应对象\n     */\n    @Override\n    public void onRetry(ForestRequest req, ForestResponse res) {\n        // req.getCurrentRetryCount() 获取请求当前重试次数\n        System.out.println("要重试了！当前重试次数：" + req.getCurrentRetryCount());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n文档导航\n\n关于如何使用拦截器，请参见《拦截器》',normalizedContent:'forest请求在发送失败的情况下会触发重试机制，重试的次数限制、时间间隔、触发条件全部都可以配置\n\n\n# 配置全局重试信息\n\n重试属性的全局配置\n\n# 全局配置下，所有请求的默认重试信息按此配置进行\n\nforest:\n    max-retry-count: 3     # 最大请求重试次数，默认为 0 次\n    max-retry-interval: 10 # 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n\n\n1\n2\n3\n4\n5\n\n\n# 全局配置下，所有请求的默认重试信息按此配置进行\n\n# 最大请求重试次数，默认为 0 次\nforest.max-retry-count=3\n# 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒   \nforest.max-retry-interval=10\n\n\n1\n2\n3\n4\n5\n6\n\n\n\x3c!-- retrycount 最大请求重试次数，默认为 0 次 --\x3e\n\x3c!-- maxretryinterval 最大重试时间间隔, 单位为毫秒，默认为 0 毫秒 --\x3e\n<forest:configuration\n    ... ...\n    retrycount="3"\n    maxretryinterval="10">\n... ...\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// 获取全局默认配置对象\nforestconfiguration configuration = forest.config();\n// 最大请求重试次数，默认为 0 次\nconfiguration.setmaxretrycount(3);\n// 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\nconfiguration.setmaxretryinterval(10);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 使用@retry注解\n\n\n# 在方法上挂上@retry注解\n\npublic interface myclient {\n    // maxretrycount 为最大重试次数，默认为 0 次\n    // maxretryinterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n    @get("/")\n    @retry(maxretrycount = "3", maxretryinterval = "10")\n    string senddata();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里的@retry注解设置了两个属性:\n\n * maxretrycount: 请求的最大重试次数，当重试次数大于该属性，将停止触发请求重试流程，默认为0次，即不会触发重试\n * maxretryinterval: 请求的最大重试时间间隔，单位为毫秒，默认为0毫秒，即没有时间间隔\n\n当调用该接口的senddata()方法后，若请求失败就会不断进行重试，直到不满足重试条件为止 (即请求成功，或达到最大请求次数限制)\n\n\n# 接口上使用@retry注解\n\n@retry注解也可以挂在interface接口类上，代表其下的所有请求方法都设置为此重试配置\n\n// maxretrycount 为最大重试次数，默认为 0 次\n// maxretryinterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n// 该接口下每个方法都以此为请求重试配置\n@retry(maxretrycount = "3", maxretryinterval = "10")\npublic interface myclient {\n    \n    @get("/test1")\n    string senddata1();\n\n    @get("/test2")\n    string senddata2();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n此时，不管调用senddata1()还是senddata2()方法，都会按最大重试3次，最大重试时间间隔10ms为重试属性\n\n\n# 重试器\n\nretryer 重试器，即重试策略，可以设定每次重试请求之间的时间间隔\n\nforest 默认重试器类为 com.dtflys.forest.retryer.backoffretryer，它是依据二进制退避算法的重试策略类\n\n若配置该重试器，重试过程如下：\n\n * 第一次重试与第一次请求之间间隔 0的2次方 * 1s, 即0s\n * 第二次重试与第一次重试之间间隔 1的2次方 * 1s, 即1s\n * 第三次次重试与第二次重试之间间隔 2的2次方 * 1s, 即4s\n * 后面几次重试时间间隔以此类推，直到达到最大请求次数后停止重试\n * 每次时间间隔不能大于 maxretryinterval, 若 maxretryinterval 设置为 10, 则每次间隔只能为 10ms\n\n您也可以自定义重试器\n\n// 自定义重试器\n// 继承 backoffretryer 类\npublic class myretryer extends backoffretryer {\n\n    public myretryer(forestrequest request) {\n        super(request);\n    }\n\n    /**\n     * 重写 nextinterval 方法\n     * 该方法用于指定每次重试的时间间隔\n     * @param currentcount 当前重试次数\n     * @return 时间间隔 (时间单位为毫秒)\n     */\n    @override\n    protected long nextinterval(int currentcount) {\n        // 每次重试时间间隔恒定为 1s (1000ms)\n        return 1000;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n然后，再通过@retryer注解绑定该自定义重试器类\n\npublic interface myclient {\n    // maxretrycount 为最大重试次数，默认为 0 次\n    // maxretryinterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n    // @retryer 注解绑定自定义的 myretryer 重试器类\n    // 将按照自定义的重试策略处理重试间隔时间\n    @get("/")\n    @retry(maxretrycount = "3", maxretryinterval = "10")\n    @retryer(myretryer.class)\n    string senddata();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n@retryer注解同样也可以挂在 interface 类上，这里不再赘述。\n\n\n# 重试条件\n\nforest 请求的重试条件有两种设置模式:\n\n * 将 请求成功/失败条件 作为重试条件\n * 设置 retrywhen 重试条件\n\n这两种模式分别对应于两种不同的重试流程:\n\n\n# 重试流程\n\n 1. 请求失败后的重试流程\n\n请求失败  ✔\n └── 是否未达到请求最大重试次数 (maxretrycount)  ✔\n      ├── 执行 onretry 回调函数\n      ├── 执行拦截器中的 onretry 方法\n      ├── 发送重试请求\n      └── 回到第一步，重试请求是否成功\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 请求成功后的重试流程\n\n请求成功  ✔\n └── 是否满足重试条件 (自定义 retrywhen 接口类条件)  ✔\n      └── 是否未达到请求最大重试次数 (maxretrycount)  ✔\n           ├── 执行 onretry 回调函数\n           ├── 执行拦截器中的 onretry 方法\n           ├── 发送重试请求\n           └── 回到第一步，重试请求是否成功，并且是否满足重试条件\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用@success注解设置重试条件\n\n一般情况只会走第1种重试流程，即直通过请求的成功/失败来判断是否重试，逻辑很简单：请求成功不重试，失败就重试\n\n此时，可以配合@success注解和@retry注解组合使用\n\n\npublic interface myclient {\n    // maxretrycount 为最大重试次数，默认为 0 次\n    // maxretryinterval 为最大重试时间间隔, 单位为毫秒，默认为 0 毫秒\n    // 同时请求成功/失败/重试的判定条件\n    // 设置为自定义的 mysuccesscondition 条件类\n    @get("/")\n    @retry(maxretrycount = "3", maxretryinterval = "10")\n    @success(condition = mysuccesscondition.class)\n    string senddata();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这种方式可以同时设置重试最大次数、间隔时间、以及自定义的成功/失败/重试条件。\n\n\n# 使用 retrywhen 接口实现重试条件\n\n但有些特殊情况，需要在请求成功的情况下也重试，满足一定业务条件后才停止重试，这种情况就需要 retrywhen 重试条件上场了\n\n先定义自定义请求重试实现类\n\n// 自定义重试条件类\n// 需要实现 retrywhen 接口\npublic class myretrycondition implements retrywhen {\n    /**\n     * 请求重试条件\n     * @param req forest请求对象\n     * @param res forest响应对象\n     * @return true 重试，false 不重试\n     */\n    @override\n    public boolean retrywhen(forestrequest req, forestresponse res) {\n        // 响应状态码为 203 就重试\n        return res.statusis(203);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n然后，通过@retry注解的condition属性指定该类\n\npublic interface myclient {\n    // maxretrycount 为最大重试次数\n    // maxretryinterval 为最大重试时间间隔, 单位为毫秒\n    @get("/")\n    @retry(maxretrycount = "3", maxretryinterval = "10", condition = myretrycondition.class)\n    string senddata();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n若发送请求后，服务端返回203状态码，就不断触发重试，直到服务端不返回203，或达到最大重试次数，停止重试。 若最后一次重试服务端发送的还是203，则认为请求成功，执行onsuccess。\n\n\n# 拦截器onretry方法\n\n拦截器的onretry方法会在触发重试时，发送重试请求前被调用\n\npublic class myretryinterceptor implements interceptor<object> {\n\n    /**\n     * 在请重试前调用 onretry 回调函数\n     *\n     * @param req forest请求对象\n     * @param res forest响应对象\n     */\n    @override\n    public void onretry(forestrequest req, forestresponse res) {\n        // req.getcurrentretrycount() 获取请求当前重试次数\n        system.out.println("要重试了！当前重试次数：" + req.getcurrentretrycount());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n文档导航\n\n关于如何使用拦截器，请参见《拦截器》',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🥂 重定向",frontmatter:{id:"redirection",title:"🥂 重定向",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/redirection/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/013.redirection.html",relativePath:"001.v1.5.x文档/040.声明式接口/013.redirection.md",key:"v-3995ef50",path:"/pages/1.5.x/redirection/",headers:[{level:2,title:"自动重定向",slug:"自动重定向",normalizedTitle:"自动重定向",charIndex:80},{level:2,title:"处理和获取重定向信息",slug:"处理和获取重定向信息",normalizedTitle:"处理和获取重定向信息",charIndex:789},{level:3,title:"使用拦截器处理重定向",slug:"使用拦截器处理重定向",normalizedTitle:"使用拦截器处理重定向",charIndex:804},{level:3,title:"使用 ForestResponse 处理重定向",slug:"使用-forestresponse-处理重定向",normalizedTitle:"使用 forestresponse 处理重定向",charIndex:1499},{level:2,title:"重定向日志",slug:"重定向日志",normalizedTitle:"重定向日志",charIndex:2172}],headersStr:"自动重定向 处理和获取重定向信息 使用拦截器处理重定向 使用 ForestResponse 处理重定向 重定向日志",content:'HTTP 请求在接收到301、302、307等响应状态码时，就默认为重定向请求，浏览器和一些客户端会自动触发重定向，即发起一个新的请求跳转到新的URL\n\n\n# 自动重定向\n\n打开/关闭全局自动重定向配置\n\nforest:\n  # 全局自动重定向开关，默认为开启\n  auto-redirection: true # true 为开启，false 为关闭\n\n\n1\n2\n3\n\n\n除了全局开关，还可以使用 @Redirection 注解，它能控制到具体的接口和方法\n\n// 打开整个接口的自动重定向\n@Redirection\npublic interface MyTestClient1 {\n\n    // 默认接口配置的重定向开关，即打开自动重定向\n    @Get("/")\n    String getData1();\n\n\n    // 关闭某个方法的重定向\n    @Redirection(false)\n    @Get("/")\n    String getData2();\n    \n    ... ...\n}\n\n// 关闭整个接口方法的自动重定向\n@Redirection(false)\npublic interface MyTestClient2 {\n\n    // 默认接口配置的重定向开关，即关闭自动重定向\n    @Get("/")\n    String getData1();\n\n    // 打开某个方法的重定向\n    @Redirection\n    @Get("/")\n    String getData2();\n    \n    ... ...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 处理和获取重定向信息\n\n\n# 使用拦截器处理重定向\n\n对于自动重定向的请求来说，无法通过请求方法返回得到跳转前的请求/响应信息，所以得通过拦截器来处理\n\n拦截器的 onRedirection 方法会在重定向跳转请求发送前触发，以此获得以一次的Request和Response对象， 即返回 301、302 等状态码的响应对象\n\n同时，还能对地址转移请求做修改\n\n/**\n * 在拦截器中可以重写 onRedirection 方法\n * 该方法可以获取和处理重定向请求相关信息\n */\npublic class RedirectInterceptor implements Interceptor<Object> {\n\n    @Override\n    public void onRedirection(ForestRequest<?> redirectReq, ForestRequest<?> prevReq, ForestResponse<?> prevRes) {\n        // 获取跳转前的请求信息\n        String prevUrl = prevReq.getUrl();\n        // 获取跳转前的响应信息\n        String location = prevRes.getHeader("Location");\n        // 如有需要，可以对即将跳转的新请求做修改\n        redirectReq.addBody("foo", "bar");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用 ForestResponse 处理重定向\n\n对于已经关闭自动重定向的请求来说，可以直接通过方法返回的跳转前的响应对象（即获得301、302等状态码的响应对象）\n\n/**\n * 关闭了自动重定向\n * 需要将方法返回值设为 ForestResponse 类型\n */\n@Redirection(false)\n@Get("/")\nForestResponse<String> getData();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过ForestReposne.isRedirection()判断是否需要重定向跳转，再通过ForestResponse.redirectionRequest()获取重定向Url转移请求对象\n\n// 调用接口获得转移前的响应对象\nForestResponse<String> response = client.getData();\n// 判断是否需要重定向跳转\nif (response.isRedirection()) {\n    // 获得即将跳转的请求对象\n    ForestRequest redirectReq = response.redirectionRequest();\n    // 如有需要，可以对添加请求进行修改\n    redirectReq.addBody("foo", "bar");\n    // 执行跳转\n    String result = redirectReq.executeAsString();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 重定向日志\n\n在开启自动重定向的情况下，重定向的请求日志形式如下\n\n[Forest] Request (okhttp3):\n\t[Redirect]: From POST http://localhost:59006/ -> 301\n\tPOST http://localhost:59006/b HTTP\n\n\n1\n2\n3\n\n\n[Forest] Request (httpclient):\n\t[Redirect]: From POST http://localhost:59006/c -> 301\n\tPOST http://localhost:59006/d HTTP\n\n\n1\n2\n3\n',normalizedContent:'http 请求在接收到301、302、307等响应状态码时，就默认为重定向请求，浏览器和一些客户端会自动触发重定向，即发起一个新的请求跳转到新的url\n\n\n# 自动重定向\n\n打开/关闭全局自动重定向配置\n\nforest:\n  # 全局自动重定向开关，默认为开启\n  auto-redirection: true # true 为开启，false 为关闭\n\n\n1\n2\n3\n\n\n除了全局开关，还可以使用 @redirection 注解，它能控制到具体的接口和方法\n\n// 打开整个接口的自动重定向\n@redirection\npublic interface mytestclient1 {\n\n    // 默认接口配置的重定向开关，即打开自动重定向\n    @get("/")\n    string getdata1();\n\n\n    // 关闭某个方法的重定向\n    @redirection(false)\n    @get("/")\n    string getdata2();\n    \n    ... ...\n}\n\n// 关闭整个接口方法的自动重定向\n@redirection(false)\npublic interface mytestclient2 {\n\n    // 默认接口配置的重定向开关，即关闭自动重定向\n    @get("/")\n    string getdata1();\n\n    // 打开某个方法的重定向\n    @redirection\n    @get("/")\n    string getdata2();\n    \n    ... ...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 处理和获取重定向信息\n\n\n# 使用拦截器处理重定向\n\n对于自动重定向的请求来说，无法通过请求方法返回得到跳转前的请求/响应信息，所以得通过拦截器来处理\n\n拦截器的 onredirection 方法会在重定向跳转请求发送前触发，以此获得以一次的request和response对象， 即返回 301、302 等状态码的响应对象\n\n同时，还能对地址转移请求做修改\n\n/**\n * 在拦截器中可以重写 onredirection 方法\n * 该方法可以获取和处理重定向请求相关信息\n */\npublic class redirectinterceptor implements interceptor<object> {\n\n    @override\n    public void onredirection(forestrequest<?> redirectreq, forestrequest<?> prevreq, forestresponse<?> prevres) {\n        // 获取跳转前的请求信息\n        string prevurl = prevreq.geturl();\n        // 获取跳转前的响应信息\n        string location = prevres.getheader("location");\n        // 如有需要，可以对即将跳转的新请求做修改\n        redirectreq.addbody("foo", "bar");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用 forestresponse 处理重定向\n\n对于已经关闭自动重定向的请求来说，可以直接通过方法返回的跳转前的响应对象（即获得301、302等状态码的响应对象）\n\n/**\n * 关闭了自动重定向\n * 需要将方法返回值设为 forestresponse 类型\n */\n@redirection(false)\n@get("/")\nforestresponse<string> getdata();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过forestreposne.isredirection()判断是否需要重定向跳转，再通过forestresponse.redirectionrequest()获取重定向url转移请求对象\n\n// 调用接口获得转移前的响应对象\nforestresponse<string> response = client.getdata();\n// 判断是否需要重定向跳转\nif (response.isredirection()) {\n    // 获得即将跳转的请求对象\n    forestrequest redirectreq = response.redirectionrequest();\n    // 如有需要，可以对添加请求进行修改\n    redirectreq.addbody("foo", "bar");\n    // 执行跳转\n    string result = redirectreq.executeasstring();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 重定向日志\n\n在开启自动重定向的情况下，重定向的请求日志形式如下\n\n[forest] request (okhttp3):\n\t[redirect]: from post http://localhost:59006/ -> 301\n\tpost http://localhost:59006/b http\n\n\n1\n2\n3\n\n\n[forest] request (httpclient):\n\t[redirect]: from post http://localhost:59006/c -> 301\n\tpost http://localhost:59006/d http\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍔 Gzip解压",frontmatter:{id:"decompress",title:"🍔 Gzip解压",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/decompress/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/014.decompress.html",relativePath:"001.v1.5.x文档/040.声明式接口/014.decompress.md",key:"v-1eee5f6c",path:"/pages/1.5.x/decompress/",headers:[{level:2,title:"@DecompressGzip 注解",slug:"decompressgzip-注解",normalizedTitle:"@decompressgzip 注解",charIndex:165}],headersStr:"@DecompressGzip 注解",content:'Gzip是现在一种流行的文件压缩算法，有相当广泛的应用范围。尤其是当Gzip用来压缩存文本文件的时候效果尤为明显，大概能减少70%以上的文件大小（具体多少取决于文件中的内容）。\n\n现有的很多HTTP服务器系统都支持Gzip，如Apache、PHP等，经过这些服务压缩过的数据可以降低网络传输的流量，提高客户端的响应速度。\n\n\n# @DecompressGzip 注解\n\nForest从1.5.2-BETA版本开始支持Gzip的解压，其解压的方式也很简单，在方法或接口类上加上 @DecompressGzip 注解即可。\n\n/**\n * 为请求方法添加Gzip解压能力\n */\n@Get("/transaction")\n@DecompressGzip\nString transaction(String infno);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n或者在接口上\n\n/**\n * 在接口类上添加 DecompressGzip 注解\n * 就是为该接口的所有方法增加Gzip解压的能力\n */\n@BaseRequest(baseURL = "${baseUrl}")\n@DecompressGzip\npublic interface GzipClient2 {\n\n    /**\n     * 进行Gzip解压\n     */\n    @Get("/transaction1")\n    String transaction1(String infno);\n\n    /**\n     * 进行Gzip解压\n     */\n    @Get("/transaction2")\n    String transaction2(String infno);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果在一个Gzip解压的接口中，有一两个请求方法不需要Gzip，也一样可以通过 @DecompressGzip(false) 注解方式进行屏蔽，其中注解的value参数代表Gzip解压的开关，true 为打开，false为关闭。\n\n/**\n * 在接口类上添加 DecompressGzip 注解，\n * 就是为该接口的所有方法增加Gzip解压的能力\n */\n@BaseRequest(baseURL = "${baseUrl}")\n@DecompressGzip\npublic interface GzipClient2 {\n\n    /**\n     * 进行Gzip解压\n     */\n    @Get("/transaction1")\n    String transaction1(String infno);\n\n    /**\n     * 进行Gzip解压\n     */\n    @Get("/transaction2")\n    String transaction2(String infno);\n\n    /**\n     * 该方法的@DecompressGzip(false)注解表示此请求不用进行Gzip解压\n     */\n    @Get("/none-gzip")\n    @DecompressGzip(false)\n    String noneGzip();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',normalizedContent:'gzip是现在一种流行的文件压缩算法，有相当广泛的应用范围。尤其是当gzip用来压缩存文本文件的时候效果尤为明显，大概能减少70%以上的文件大小（具体多少取决于文件中的内容）。\n\n现有的很多http服务器系统都支持gzip，如apache、php等，经过这些服务压缩过的数据可以降低网络传输的流量，提高客户端的响应速度。\n\n\n# @decompressgzip 注解\n\nforest从1.5.2-beta版本开始支持gzip的解压，其解压的方式也很简单，在方法或接口类上加上 @decompressgzip 注解即可。\n\n/**\n * 为请求方法添加gzip解压能力\n */\n@get("/transaction")\n@decompressgzip\nstring transaction(string infno);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n或者在接口上\n\n/**\n * 在接口类上添加 decompressgzip 注解\n * 就是为该接口的所有方法增加gzip解压的能力\n */\n@baserequest(baseurl = "${baseurl}")\n@decompressgzip\npublic interface gzipclient2 {\n\n    /**\n     * 进行gzip解压\n     */\n    @get("/transaction1")\n    string transaction1(string infno);\n\n    /**\n     * 进行gzip解压\n     */\n    @get("/transaction2")\n    string transaction2(string infno);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果在一个gzip解压的接口中，有一两个请求方法不需要gzip，也一样可以通过 @decompressgzip(false) 注解方式进行屏蔽，其中注解的value参数代表gzip解压的开关，true 为打开，false为关闭。\n\n/**\n * 在接口类上添加 decompressgzip 注解，\n * 就是为该接口的所有方法增加gzip解压的能力\n */\n@baserequest(baseurl = "${baseurl}")\n@decompressgzip\npublic interface gzipclient2 {\n\n    /**\n     * 进行gzip解压\n     */\n    @get("/transaction1")\n    string transaction1(string infno);\n\n    /**\n     * 进行gzip解压\n     */\n    @get("/transaction2")\n    string transaction2(string infno);\n\n    /**\n     * 该方法的@decompressgzip(false)注解表示此请求不用进行gzip解压\n     */\n    @get("/none-gzip")\n    @decompressgzip(false)\n    string nonegzip();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🎂 日志管理",frontmatter:{id:"logs",title:"🎂 日志管理",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/logs/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/015.logs.html",relativePath:"001.v1.5.x文档/040.声明式接口/015.logs.md",key:"v-7f8efa68",path:"/pages/1.5.x/logs/",headers:[{level:3,title:"请求日志",slug:"请求日志",normalizedTitle:"请求日志",charIndex:44},{level:3,title:"响应状态日志",slug:"响应状态日志",normalizedTitle:"响应状态日志",charIndex:49},{level:3,title:"响应内容日志",slug:"响应内容日志",normalizedTitle:"响应内容日志",charIndex:56},{level:3,title:"日志总开关",slug:"日志总开关",normalizedTitle:"日志总开关",charIndex:677},{level:3,title:"单个请求的日志开关",slug:"单个请求的日志开关",normalizedTitle:"单个请求的日志开关",charIndex:1069},{level:3,title:"自定义日志处理器",slug:"自定义日志处理器",normalizedTitle:"自定义日志处理器",charIndex:2248},{level:3,title:"配置全局日志处理器",slug:"配置全局日志处理器",normalizedTitle:"配置全局日志处理器",charIndex:4791},{level:3,title:"配置单个请求的日志处理器",slug:"配置单个请求的日志处理器",normalizedTitle:"配置单个请求的日志处理器",charIndex:4984}],headersStr:"请求日志 响应状态日志 响应内容日志 日志总开关 单个请求的日志开关 自定义日志处理器 配置全局日志处理器 配置单个请求的日志处理器",content:'Forest在发送请求时和接受响应数据时都会自动打印出HTTP请求相关的日志，其中包括：请求日志、响应状态日志、响应内容日志。\n\n\n# 请求日志\n\n请求日志会打印出所有请求发送的内容，其中包括请求行、请求头、请求体三部分\n\n[Forest] Request: \n\tPOST http://localhost:8080/test HTTP\n\tHeaders: \n\t\taccessToken: abcdefg123456\n\tBody: username=foo&password=bar\n\n\n1\n2\n3\n4\n5\n\n\n这段内容就是请求日志，包含的发送HTTP请求的所有几乎所有信息，也很容易看懂。如若看不懂，还请参见《HTTP请求报文》，这里不再赘述。\n\n\n# 响应状态日志\n\n响应状态日志包含了HTTP请求响应后接受到的状态码，以及响应时间\n\n[Forest] Response: Status = 200, Time = 11ms\n\n\n1\n\n\nStatus为状态码：标准的HTTP协议定义的请求响应状态码，如若不清楚，可以参见《HTTP状态码》\n\nTime为请求响应时间：从客户端请求发送到接受到响应数据的总时间\n\n\n# 响应内容日志\n\n响应内容日志则会打印出请求发送的目标服务器响应后，返回给请求接受方的实际数据内容\n\n[Forest] Response: Content={"flag":"success","message":"成功"}\n\n\n1\n\n\nContent=后面的内容便是请求响应接受到的数据\n\n友情提示\n\n响应内容日志默认是关闭的\n\n\n# 日志总开关\n\n很多时候，我们只在调试的时候打印日志，上了生产环境后为了节省性能便不打印了（并不是所有公司都不在生产打印日志，毕竟万一出了问题也是要有据可循的，这里只是举个栗子( •⌄• )）， 便需要通过配置的方式打开和关闭HTTP请求的日志。\n\nforest:\n  ## 日志总开关，打开/关闭Forest请求/响应日志（默认为 true）\n  log-enabled: true\n  ## 打开/关闭Forest请求日志（默认为 true）\n  log-request: true\n  ## 打开/关闭Forest响应状态日志（默认为 true）\n  log-response-status: true\n  ## 打开/关闭Forest响应内容日志（默认为 false）\n  log-response-content: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 单个请求的日志开关\n\n日志的总开关控制粒度太过粗放，如果想要只关闭和打开某一个请求的日志有办法吗？有的~\n\nForest自1.50-BETA1版本后提供了@LogEnabled注解来专门干这个事。\n\n@LogEnabled注解的各属性如下所示：\n\n属性                   作用            默认值\nvalue                是否打印请求/响应日志   true\nlogRequest           是否打印请求日志      true\nlogResponseStatus    是否打印响应状态日志    true\nlogResponseContent   是否打印响应内容日志    false\n\n具体如何使用看下面例子：\n\n\n/** 默认开关：允许打印请求日志、响应状态日志，但不打印响应内容日志 */\n@Get("http://localhost:8080/send")\n@LogEnabled\nString send(@Query("msg") String message);\n\n/** 同上 */\n@Get("http://localhost:8080/send")\n@LogEnabled(true)\nString send(@Query("msg") String message);\n\n/** 关闭该请求的所有日志 */\n@Get("http://localhost:8080/send")\n@LogEnabled(false)\nString send(@Query("msg") String message);\n\n/** 不打印请求日志 */\n@Get("http://localhost:8080/send")\n@LogEnabled(logRequest = false)\nString send(@Query("msg") String message);\n\n/** 不打印响应状态日志 */\n@Get("http://localhost:8080/send")\n@LogEnabled(logResponseStatus = false)\nString send(@Query("msg") String message);\n\n/** 打印响应内容日志 */\n@Get("http://localhost:8080/send")\n@LogEnabled(logResponseContent = true)\nString send(@Query("msg") String message);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 自定义日志处理器\n\n如果有小伙伴觉得Forest默认的日志打印格式太丑，领导都看不下去了怎么办？\n\n好消息是自1.5.0-BETA1版本后可以通过自定义扩展日志处理器来按自己喜欢的格式打印日志。\n\n实现过程也不复杂：实现com.dtflys.forest.logging.ForestLogHandler接口，或者继承com.dtflys.forest.logging.DefaultLogHandler类。\n\n这里的例子使用继承DefaultLogHandler类的方式，因为可以少些很多代码\n\n/**\n * 我自定义的日志处理器\n */\npublic class TestLogHandler extends DefaultLogHandler {\n  \n    /**\n     * 所有的请求最终会调用这个方法打印日志\n     */\n    @Override\n    public void logContent(String content) {\n        super.logContent("[哈哈，这是我自己的日志]: " + content);\n    }\n\n    /**\n     * 该方法生成Forest请求的日志内容字符串\n     * @param requestLogMessage 请求日志字符串\n     * @return 日志内容字符串\n     */\n    @Override\n    protected String requestLoggingContent(RequestLogMessage requestLogMessage) {\n        StringBuilder builder = new StringBuilder();\n        builder.append("请求: \\n\\t");\n        // 插入重试信息\n        builder.append(retryContent(requestLogMessage));\n        // 插入代理信息\n        builder.append(proxyContent(requestLogMessage));\n        // 插入请求类型变更历史信息\n        builder.append(requestTypeChangeHistory(requestLogMessage));\n        // 插入请求行信息\n        builder.append(requestLogMessage.getRequestLine());\n        // 获取并插入所有请求头内容\n        String headers = requestLoggingHeaders(requestLogMessage);\n        if (StringUtils.isNotEmpty(headers)) {\n            builder.append("\\n\\t请求头: \\n");\n            builder.append(headers);\n        }\n        // 获取并插入所有请求体内容\n        String body = requestLoggingBody(requestLogMessage);\n        if (StringUtils.isNotEmpty(body)) {\n            builder.append("\\n\\t请求体: \\n");\n            builder.append(body);\n        }\n        return builder.toString();\n    }\n\n    /**\n     * 该方法生成Forest请求响应结果的日志内容字符串\n     * @param responseLogMessage 请求响应日志字符串\n     * @return 日志内容字符串\n     */\n    @Override\n    protected String responseLoggingContent(ResponseLogMessage responseLogMessage) {\n        ForestResponse response = responseLogMessage.getResponse();\n        if (response != null && response.getException() != null) {\n            return "[网络错误]: " + response.getException().getMessage();\n        }\n        // 获取请求响应状态码\n        int status = responseLogMessage.getStatus();\n        // 获取请求响应时间\n        long time = responseLogMessage.getTime();\n        if (status >= 0) {\n            return "请求响应: 状态码: " + status + ", 耗时: " + time + "ms";\n        } else {\n            return "[网络错误]: 未知的网络错误!";\n        }\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 配置全局日志处理器\n\n定义完自己的日志处理器后并不会马上就生效，还需要在配置中指定您定义的日志处理器类。\n\n日志处理器的配置也分两种：全局级别和接口/方法级别。\n\n我们先看全局日志处理器怎么配置：\n\n\nforest:\n  ## 全局日志处理器类\n  log-handler: com.your.site.logging.TestLogHandler\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配置单个请求的日志处理器\n\n和日志的开关一样，我只想对某个或某几个请求用自定义的日志处理器，也一样有办法。\n\nForest提供了@LogHandler注解来解决这个问题\n\n@Get(url = "http://localhost:8080/send")\n@LogHandler(com.your.site.logging.TestLogHandler.class)\nString send(@Query("msg") String message);\n\n\n1\n2\n3\n',normalizedContent:'forest在发送请求时和接受响应数据时都会自动打印出http请求相关的日志，其中包括：请求日志、响应状态日志、响应内容日志。\n\n\n# 请求日志\n\n请求日志会打印出所有请求发送的内容，其中包括请求行、请求头、请求体三部分\n\n[forest] request: \n\tpost http://localhost:8080/test http\n\theaders: \n\t\taccesstoken: abcdefg123456\n\tbody: username=foo&password=bar\n\n\n1\n2\n3\n4\n5\n\n\n这段内容就是请求日志，包含的发送http请求的所有几乎所有信息，也很容易看懂。如若看不懂，还请参见《http请求报文》，这里不再赘述。\n\n\n# 响应状态日志\n\n响应状态日志包含了http请求响应后接受到的状态码，以及响应时间\n\n[forest] response: status = 200, time = 11ms\n\n\n1\n\n\nstatus为状态码：标准的http协议定义的请求响应状态码，如若不清楚，可以参见《http状态码》\n\ntime为请求响应时间：从客户端请求发送到接受到响应数据的总时间\n\n\n# 响应内容日志\n\n响应内容日志则会打印出请求发送的目标服务器响应后，返回给请求接受方的实际数据内容\n\n[forest] response: content={"flag":"success","message":"成功"}\n\n\n1\n\n\ncontent=后面的内容便是请求响应接受到的数据\n\n友情提示\n\n响应内容日志默认是关闭的\n\n\n# 日志总开关\n\n很多时候，我们只在调试的时候打印日志，上了生产环境后为了节省性能便不打印了（并不是所有公司都不在生产打印日志，毕竟万一出了问题也是要有据可循的，这里只是举个栗子( •⌄• )）， 便需要通过配置的方式打开和关闭http请求的日志。\n\nforest:\n  ## 日志总开关，打开/关闭forest请求/响应日志（默认为 true）\n  log-enabled: true\n  ## 打开/关闭forest请求日志（默认为 true）\n  log-request: true\n  ## 打开/关闭forest响应状态日志（默认为 true）\n  log-response-status: true\n  ## 打开/关闭forest响应内容日志（默认为 false）\n  log-response-content: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 单个请求的日志开关\n\n日志的总开关控制粒度太过粗放，如果想要只关闭和打开某一个请求的日志有办法吗？有的~\n\nforest自1.50-beta1版本后提供了@logenabled注解来专门干这个事。\n\n@logenabled注解的各属性如下所示：\n\n属性                   作用            默认值\nvalue                是否打印请求/响应日志   true\nlogrequest           是否打印请求日志      true\nlogresponsestatus    是否打印响应状态日志    true\nlogresponsecontent   是否打印响应内容日志    false\n\n具体如何使用看下面例子：\n\n\n/** 默认开关：允许打印请求日志、响应状态日志，但不打印响应内容日志 */\n@get("http://localhost:8080/send")\n@logenabled\nstring send(@query("msg") string message);\n\n/** 同上 */\n@get("http://localhost:8080/send")\n@logenabled(true)\nstring send(@query("msg") string message);\n\n/** 关闭该请求的所有日志 */\n@get("http://localhost:8080/send")\n@logenabled(false)\nstring send(@query("msg") string message);\n\n/** 不打印请求日志 */\n@get("http://localhost:8080/send")\n@logenabled(logrequest = false)\nstring send(@query("msg") string message);\n\n/** 不打印响应状态日志 */\n@get("http://localhost:8080/send")\n@logenabled(logresponsestatus = false)\nstring send(@query("msg") string message);\n\n/** 打印响应内容日志 */\n@get("http://localhost:8080/send")\n@logenabled(logresponsecontent = true)\nstring send(@query("msg") string message);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 自定义日志处理器\n\n如果有小伙伴觉得forest默认的日志打印格式太丑，领导都看不下去了怎么办？\n\n好消息是自1.5.0-beta1版本后可以通过自定义扩展日志处理器来按自己喜欢的格式打印日志。\n\n实现过程也不复杂：实现com.dtflys.forest.logging.forestloghandler接口，或者继承com.dtflys.forest.logging.defaultloghandler类。\n\n这里的例子使用继承defaultloghandler类的方式，因为可以少些很多代码\n\n/**\n * 我自定义的日志处理器\n */\npublic class testloghandler extends defaultloghandler {\n  \n    /**\n     * 所有的请求最终会调用这个方法打印日志\n     */\n    @override\n    public void logcontent(string content) {\n        super.logcontent("[哈哈，这是我自己的日志]: " + content);\n    }\n\n    /**\n     * 该方法生成forest请求的日志内容字符串\n     * @param requestlogmessage 请求日志字符串\n     * @return 日志内容字符串\n     */\n    @override\n    protected string requestloggingcontent(requestlogmessage requestlogmessage) {\n        stringbuilder builder = new stringbuilder();\n        builder.append("请求: \\n\\t");\n        // 插入重试信息\n        builder.append(retrycontent(requestlogmessage));\n        // 插入代理信息\n        builder.append(proxycontent(requestlogmessage));\n        // 插入请求类型变更历史信息\n        builder.append(requesttypechangehistory(requestlogmessage));\n        // 插入请求行信息\n        builder.append(requestlogmessage.getrequestline());\n        // 获取并插入所有请求头内容\n        string headers = requestloggingheaders(requestlogmessage);\n        if (stringutils.isnotempty(headers)) {\n            builder.append("\\n\\t请求头: \\n");\n            builder.append(headers);\n        }\n        // 获取并插入所有请求体内容\n        string body = requestloggingbody(requestlogmessage);\n        if (stringutils.isnotempty(body)) {\n            builder.append("\\n\\t请求体: \\n");\n            builder.append(body);\n        }\n        return builder.tostring();\n    }\n\n    /**\n     * 该方法生成forest请求响应结果的日志内容字符串\n     * @param responselogmessage 请求响应日志字符串\n     * @return 日志内容字符串\n     */\n    @override\n    protected string responseloggingcontent(responselogmessage responselogmessage) {\n        forestresponse response = responselogmessage.getresponse();\n        if (response != null && response.getexception() != null) {\n            return "[网络错误]: " + response.getexception().getmessage();\n        }\n        // 获取请求响应状态码\n        int status = responselogmessage.getstatus();\n        // 获取请求响应时间\n        long time = responselogmessage.gettime();\n        if (status >= 0) {\n            return "请求响应: 状态码: " + status + ", 耗时: " + time + "ms";\n        } else {\n            return "[网络错误]: 未知的网络错误!";\n        }\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 配置全局日志处理器\n\n定义完自己的日志处理器后并不会马上就生效，还需要在配置中指定您定义的日志处理器类。\n\n日志处理器的配置也分两种：全局级别和接口/方法级别。\n\n我们先看全局日志处理器怎么配置：\n\n\nforest:\n  ## 全局日志处理器类\n  log-handler: com.your.site.logging.testloghandler\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配置单个请求的日志处理器\n\n和日志的开关一样，我只想对某个或某几个请求用自定义的日志处理器，也一样有办法。\n\nforest提供了@loghandler注解来解决这个问题\n\n@get(url = "http://localhost:8080/send")\n@loghandler(com.your.site.logging.testloghandler.class)\nstring send(@query("msg") string message);\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"⚽ 回调函数",frontmatter:{id:"callback",title:"⚽ 回调函数",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/callback/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/016.callback.html",relativePath:"001.v1.5.x文档/040.声明式接口/016.callback.md",key:"v-3bb81cec",path:"/pages/1.5.x/callback/",headers:[{level:2,title:"成功/失败回调函数",slug:"成功-失败回调函数",normalizedTitle:"成功/失败回调函数",charIndex:72},{level:2,title:"下载进度回调函数",slug:"下载进度回调函数",normalizedTitle:"下载进度回调函数",charIndex:967},{level:2,title:"重定向回调函数",slug:"重定向回调函数",normalizedTitle:"重定向回调函数",charIndex:1801}],headersStr:"成功/失败回调函数 下载进度回调函数 重定向回调函数",content:'在Forest中的回调函数使用单方法的接口定义，这样可以使您在 Java 8 或 Kotlin 语言中方便使用 Lambda 表达式。\n\n\n# 成功/失败回调函数\n\n在接口方法加入OnSuccess<T>类型或OnError类型的参数\n\n@Request(\n        url = "http://localhost:8080/hello/user",\n        headers = {"Accept:text/plain"},\n        data = "username=${username}"\n)\nString send(@Var("username") String username, OnSuccess<String> onSuccess, OnError onError);\n\n\n1\n2\n3\n4\n5\n6\n\n\n如这两个回调函数的类名所示的含义一样，OnSuccess<T>在请求成功调用响应时会被调用，而OnError在失败或出现错误的时候被调用。\n\n其中OnSuccess<T>的泛型参数T定义为请求响应返回结果的数据类型。\n\nmyClient.send("foo", (String resText, ForestRequest request, ForestResponse response) -> {\n        // 成功响应回调\n        System.out.println(resText);    \n    },\n    (ForestRuntimeException ex, ForestRequest request, ForestResponse response) -> {\n        // 异常回调\n        System.out.println(ex.getMessage());\n    });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n * 在异步请求中只能通过OnSuccess<T>回调函数接或Future返回值接受数据。\n * 而在同步请求中，OnSuccess<T>回调函数和任何类型的返回值都能接受到请求响应的数据。\n * OnError回调函数可以用于异常处理，一般在同步请求中使用try-catch也能达到同样的效果。\n\n\n# 下载进度回调函数\n\n在接口方法加入OnProgress类型的参数\n\n/**\n * OnProgress 回调函数可以用于下载文件类请求方法的参数中\n */\n@Get("/xxx-img.jpg")\nbyte[] downloadFile(OnProgress onProgress);\n\n\n1\n2\n3\n4\n5\n\n\n如果请求成功访问到URL指定的文件资源，且开始进行下载，则会反复调用参数中传入的 OnProgress 回调函数\n\n// 每传输一定的字节数，便会调用一次 OnProgress 回调函数\nbyte[] bytes = downloadClient.downloadFile(progress -> {\n    System.out.println("------------------------------------------");\n    System.out.println("total bytes: " + progress.getTotalBytes()); // 文件总字节数\n    System.out.println("current bytes: " + progress.getCurrentBytes()); // 当前已传输字节数\n    System.out.println("progress: " + Math.round(progress.getRate() * 100) + "%"); // 传输百分百\n    if (progress.isDone()) {\n        // 若已传输完毕\n        System.out.println("--------   Download Completed!   --------");\n        atomicProgress.set(progress);\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 重定向回调函数\n\n当前请求响应接受到的是 302、304 等状态码时，Forest 会触发自动重定向，即会立刻发送一个新的请求\n\n若要拦截或修改新的跳转请求可以使用 OnRedirection 回调函数\n\n/**\n * OnRedirection 回调函数可以用自动重定向请求方法的参数中\n */\n@Post("/")\nString testRedirect(OnRedirection onRedirection);\n\n\n1\n2\n3\n4\n5\n\n\n当触发重定向时，在发送新的跳转请求前，会调用参数中传入的 OnRedirection 回调函数\n\nString result = redirectClient.testNotAutoRedirect(((redirectReq, prevReq, prevRes) -> {\n    // prevReq 为跳转前的请求对象\n    // prevRes 为跳转前接受到的响应对象\n    // redirectReq 为新的即将跳转的请求对象\n}));\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'在forest中的回调函数使用单方法的接口定义，这样可以使您在 java 8 或 kotlin 语言中方便使用 lambda 表达式。\n\n\n# 成功/失败回调函数\n\n在接口方法加入onsuccess<t>类型或onerror类型的参数\n\n@request(\n        url = "http://localhost:8080/hello/user",\n        headers = {"accept:text/plain"},\n        data = "username=${username}"\n)\nstring send(@var("username") string username, onsuccess<string> onsuccess, onerror onerror);\n\n\n1\n2\n3\n4\n5\n6\n\n\n如这两个回调函数的类名所示的含义一样，onsuccess<t>在请求成功调用响应时会被调用，而onerror在失败或出现错误的时候被调用。\n\n其中onsuccess<t>的泛型参数t定义为请求响应返回结果的数据类型。\n\nmyclient.send("foo", (string restext, forestrequest request, forestresponse response) -> {\n        // 成功响应回调\n        system.out.println(restext);    \n    },\n    (forestruntimeexception ex, forestrequest request, forestresponse response) -> {\n        // 异常回调\n        system.out.println(ex.getmessage());\n    });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n * 在异步请求中只能通过onsuccess<t>回调函数接或future返回值接受数据。\n * 而在同步请求中，onsuccess<t>回调函数和任何类型的返回值都能接受到请求响应的数据。\n * onerror回调函数可以用于异常处理，一般在同步请求中使用try-catch也能达到同样的效果。\n\n\n# 下载进度回调函数\n\n在接口方法加入onprogress类型的参数\n\n/**\n * onprogress 回调函数可以用于下载文件类请求方法的参数中\n */\n@get("/xxx-img.jpg")\nbyte[] downloadfile(onprogress onprogress);\n\n\n1\n2\n3\n4\n5\n\n\n如果请求成功访问到url指定的文件资源，且开始进行下载，则会反复调用参数中传入的 onprogress 回调函数\n\n// 每传输一定的字节数，便会调用一次 onprogress 回调函数\nbyte[] bytes = downloadclient.downloadfile(progress -> {\n    system.out.println("------------------------------------------");\n    system.out.println("total bytes: " + progress.gettotalbytes()); // 文件总字节数\n    system.out.println("current bytes: " + progress.getcurrentbytes()); // 当前已传输字节数\n    system.out.println("progress: " + math.round(progress.getrate() * 100) + "%"); // 传输百分百\n    if (progress.isdone()) {\n        // 若已传输完毕\n        system.out.println("--------   download completed!   --------");\n        atomicprogress.set(progress);\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 重定向回调函数\n\n当前请求响应接受到的是 302、304 等状态码时，forest 会触发自动重定向，即会立刻发送一个新的请求\n\n若要拦截或修改新的跳转请求可以使用 onredirection 回调函数\n\n/**\n * onredirection 回调函数可以用自动重定向请求方法的参数中\n */\n@post("/")\nstring testredirect(onredirection onredirection);\n\n\n1\n2\n3\n4\n5\n\n\n当触发重定向时，在发送新的跳转请求前，会调用参数中传入的 onredirection 回调函数\n\nstring result = redirectclient.testnotautoredirect(((redirectreq, prevreq, prevres) -> {\n    // prevreq 为跳转前的请求对象\n    // prevres 为跳转前接受到的响应对象\n    // redirectreq 为新的即将跳转的请求对象\n}));\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍟 异步请求",frontmatter:{id:"async",title:"🍟 异步请求",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/async/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/017.async.html",relativePath:"001.v1.5.x文档/040.声明式接口/017.async.md",key:"v-6885eba8",path:"/pages/1.5.x/async/",headers:[{level:2,title:"设置异步/同步",slug:"设置异步-同步",normalizedTitle:"设置异步/同步",charIndex:2},{level:2,title:"使用回调函数",slug:"使用回调函数",normalizedTitle:"使用回调函数",charIndex:298},{level:2,title:"使用 Future 接受异步数据",slug:"使用-future-接受异步数据",normalizedTitle:"使用 future 接受异步数据",charIndex:937}],headersStr:"设置异步/同步 使用回调函数 使用 Future 接受异步数据",content:'# 设置异步/同步\n\n在Forest使用异步请求，可以通过设置@Request注解的async属性为true实现，不设置或设置为false即为同步请求\n\n/**\n * async 属性为 true 即为异步请求，为 false 则为同步请求\n * 不设置该属性时，默认为 false\n */\n@Get(\n        url = "http://localhost:8080/hello/user?username=${0}",\n        async = true\n)\nString asyncGet(String username);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 使用回调函数\n\n异步请求的方法无法直接通过返回值接受服务端响应的结果，因为在网络还在没完成连接和响应的过程中，方法已经返回了\n\n此时需要成功/失败回调函数来响应网络请求的结果\n\n@Get(\n        url = "http://localhost:8080/hello/user?username=${0}",\n        async = true,\n        headers = {"Accept:text/plain"}\n)\nvoid asyncGet(String username， OnSuccess<String> onSuccess, OnError onError);\n\n\n1\n2\n3\n4\n5\n6\n\n\n一般情况下，异步请求都通过OnSuccess<T>回调函数来接受响应返回的数据，而不是通过接口方法的返回值，所以这里的返回值类型一般会定义为void。\n\n文档导航\n\n关于回调函数的使用请参见 《回调函数》\n\n// 异步执行\nmyClient.asyncGet("foo", (result, req, res) -> {\n    // 请求成功，处理响应结果\n    System.out.println(result);\n}, (ex, req, res) -> {\n    // 请求失败，处理失败信息\n    System.out.println(ex.getMessage());\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 使用 Future 接受异步数据\n\n此外，若有些小伙伴不习惯这种函数式的编程方式，也可以用Future<T>类型定义方法返回值的方式来接受响应数据。\n\n@Request(\n        url = "http://localhost:8080/hello/user?username=foo",\n        async = true,\n        headers = {"Accept:text/plain"}\n)\nFuture<String> asyncFuture();\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里Future<T>类就是JDK自带的java.util.concurrent.Future类, 其泛型参数T代表您想接受的响应数据的类型。\n\n关于如何使用Future类，这里不再赘述。\n\n// 异步执行\nFuture<String> future = myClient.asyncFuture();\n\n// 做一些其它事情\n\n// 等待数据\nString result = future.get();\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# 设置异步/同步\n\n在forest使用异步请求，可以通过设置@request注解的async属性为true实现，不设置或设置为false即为同步请求\n\n/**\n * async 属性为 true 即为异步请求，为 false 则为同步请求\n * 不设置该属性时，默认为 false\n */\n@get(\n        url = "http://localhost:8080/hello/user?username=${0}",\n        async = true\n)\nstring asyncget(string username);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 使用回调函数\n\n异步请求的方法无法直接通过返回值接受服务端响应的结果，因为在网络还在没完成连接和响应的过程中，方法已经返回了\n\n此时需要成功/失败回调函数来响应网络请求的结果\n\n@get(\n        url = "http://localhost:8080/hello/user?username=${0}",\n        async = true,\n        headers = {"accept:text/plain"}\n)\nvoid asyncget(string username， onsuccess<string> onsuccess, onerror onerror);\n\n\n1\n2\n3\n4\n5\n6\n\n\n一般情况下，异步请求都通过onsuccess<t>回调函数来接受响应返回的数据，而不是通过接口方法的返回值，所以这里的返回值类型一般会定义为void。\n\n文档导航\n\n关于回调函数的使用请参见 《回调函数》\n\n// 异步执行\nmyclient.asyncget("foo", (result, req, res) -> {\n    // 请求成功，处理响应结果\n    system.out.println(result);\n}, (ex, req, res) -> {\n    // 请求失败，处理失败信息\n    system.out.println(ex.getmessage());\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 使用 future 接受异步数据\n\n此外，若有些小伙伴不习惯这种函数式的编程方式，也可以用future<t>类型定义方法返回值的方式来接受响应数据。\n\n@request(\n        url = "http://localhost:8080/hello/user?username=foo",\n        async = true,\n        headers = {"accept:text/plain"}\n)\nfuture<string> asyncfuture();\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里future<t>类就是jdk自带的java.util.concurrent.future类, 其泛型参数t代表您想接受的响应数据的类型。\n\n关于如何使用future类，这里不再赘述。\n\n// 异步执行\nfuture<string> future = myclient.asyncfuture();\n\n// 做一些其它事情\n\n// 等待数据\nstring result = future.get();\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🛡️ HTTPS",frontmatter:{id:"https",title:"🛡️ HTTPS",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/https/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/018.https.html",relativePath:"001.v1.5.x文档/040.声明式接口/018.https.md",key:"v-42e16c48",path:"/pages/1.5.x/https/",headers:[{level:2,title:"单向认证",slug:"单向认证",normalizedTitle:"单向认证",charIndex:68},{level:2,title:"简单双向认证",slug:"简单双向认证",normalizedTitle:"简单双向认证",charIndex:885},{level:2,title:"更复杂的SSL验证",slug:"更复杂的ssl验证",normalizedTitle:"更复杂的ssl验证",charIndex:2364},{level:3,title:"自定义SSLSocketFactory",slug:"自定义sslsocketfactory",normalizedTitle:"自定义sslsocketfactory",charIndex:2417},{level:3,title:"自定义HostnameVerifier",slug:"自定义hostnameverifier",normalizedTitle:"自定义hostnameverifier",charIndex:3320}],headersStr:"单向认证 简单双向认证 更复杂的SSL验证 自定义SSLSocketFactory 自定义HostnameVerifier",content:'为保证网络访问安全，现在大多数企业都会选择使用SSL验证来提高网站的安全性。\n\n所以Forest自然也加入了对HTTPS的处理，现在支持单向认证和双向认证的HTTPS请求。\n\n\n# 单向认证\n\n如果访问的目标站点的SSL证书由信任的Root CA发布的，那么您无需做任何事情便可以自动信任\n\n\npublic interface Gitee {\n    @Request(url = "https://gitee.com")\n    String index();\n}\n\n\n1\n2\n3\n4\n5\n\n\nForest的单向验证的默认协议为TLS，如果一些站点的API不支持该协议，您可以在全局配置中将ssl-protocol属性修改为其它协议，如：SSL, TLS, TLSv1.1, TLSv1.2,TLSv1.3, SSLv3等等。\n\nforest:\n  ...\n  ssl-protocol: TLS\n\n\n1\n2\n3\n\n\n全局配置可以配置一个全局统一的SSL协议，但现实情况是有很多不同服务（尤其是第三方）的API会使用不同的SSL协议，这种情况需要针对不同的接口设置不同的SSL协议。\n\n/**\n * 在某个请求接口上通过 sslProtocol 属性设置单向SSL协议\n */\n@Get(\n    url = "https://localhost:5555/hello/user",\n    sslProtocol = "TLS"\n)\nForestResponse<String> truestSSLGet();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在一个个方法上设置太麻烦，也可以在 @BaseRequest 注解中设置一整个接口类的SSL协议\n\n@BaseRequest(sslProtocol = "TLS")\npublic interface SSLClient {\n\n    @Get("https://localhost:5555/hello/user")\n    String testSend();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 简单双向认证\n\n若是需要在Forest中进行双向验证的HTTPS请求，也很简单。\n\n在全局配置中添加keystore配置：\n\nforest:\n ...\n ssl-key-stores:\n   - id: keystore1           # id为该keystore的名称，必填\n     file: test.keystore     # 公钥文件地址\n     keystore-pass: 123456   # keystore秘钥\n     cert-pass: 123456       # cert秘钥\n     protocols: TLS          # SSL协议\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<forest:configuration>\n    <forest:ssl-keystore\n            id="keystore1"\n            file="test.keystore"\n            keystorePass="123456"\n            certPass="123456"\n            protocols="TLS"/>\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// 获取Forest全局配置对象\nconfiguration = Forest.config();\n// 实例化 SSLKeyStore 对象，并输入参数\nSSLKeyStore sslKeyStore = new SSLKeyStore(\n    "keystore1",\n    "ssl_client.keystore",\n    "client",\n    "456789",\n    null,\n    null);\n// 注册 SSLKeyStore 对象\nconfiguration.registerKeyStore(sslKeyStore);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n接着，在@Request中引入该keystore的id即可\n\n@Get(url = "/user_info", keyStore = "keystore1")\nForestResponse<String> getUserInfo();\n\n\n1\n2\n\n\n另外，您也可以在全局配置中配多个keystore：\n\nforest:\n  ...\n  ssl-key-stores:\n    - id: keystore1          # 第一个keystore\n      file: test1.keystore    \n      keystore-pass: 123456  \n      cert-pass: 123456      \n      protocols: SSL       \n\n    - id: keystore2          # 第二个keystore\n      file: test2.keystore    \n      keystore-pass: abcdef  \n      cert-pass: abcdef      \n      protocols: TLS       \n      ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n随后在某个具体@Request中配置其中任意一个keystore的id都可以\n\n\n# 更复杂的SSL验证\n\n对于一些更复杂的SSL验证，光靠简单的配置无法完全应付，但在Forest中也可以通过自定义SSLSocketFactory和HostnameVerifier的方式提供更灵活的解决方案\n\n\n# 自定义SSLSocketFactory\n\nForest提供了SSLSocketFactoryBuilder接口，通过实现该接口可以自定义SSLSocketFactory\n\n/**\n * 自定义 SSLSocketFactory 构造器\n */\npublic class MySSLSocketFactoryBuilder implements SSLSocketFactoryBuilder {\n\n    /**\n     * 获取SSL Socket Factory\n     */\n    @Override\n    public SSLSocketFactory getSSLSocketFactory(ForestRequest request, String protocol) throws Exception {\n        SSLContext sslContext = SSLContext.getInstance("TLS");\n        sslContext.init(null,\n                new TrustManager[] { new TrustAllManager() },\n                new SecureRandom());\n        return sslContext.getSocketFactory();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后通过@SSLSocketFactoryBuilder注解引入自定义的SSLSocketFactoryBuilder接口实现类\n\n@Get("/user_info")\n@SSLSocketFactoryBuilder(MySSLSocketFactoryBuilder.class)\nForestRequest<String> getUserInfo();\n\n\n1\n2\n3\n\n\n\n# 自定义HostnameVerifier\n\n在Forest中，也可以指定自定义的HostnameVerifier接口实现类\n\n/**\n * 自定义主机名验证器\n */\npublic class MyHostnameVerifier implements HostnameVerifier {\n    @Override\n    public boolean verify(String s, SSLSession sslSession) {\n        System.out.println("do MyHostnameVerifier");\n        if ("localhost".equals(s)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n然后通过@SSLHostnameVerifier注解引入自定义的主机名验证器类\n\n@Get("/user_info")\n@SSLHostnameVerifier(MyHostnameVerifier.class)\nForestRequest<String> getUserInfo();\n\n\n1\n2\n3\n',normalizedContent:'为保证网络访问安全，现在大多数企业都会选择使用ssl验证来提高网站的安全性。\n\n所以forest自然也加入了对https的处理，现在支持单向认证和双向认证的https请求。\n\n\n# 单向认证\n\n如果访问的目标站点的ssl证书由信任的root ca发布的，那么您无需做任何事情便可以自动信任\n\n\npublic interface gitee {\n    @request(url = "https://gitee.com")\n    string index();\n}\n\n\n1\n2\n3\n4\n5\n\n\nforest的单向验证的默认协议为tls，如果一些站点的api不支持该协议，您可以在全局配置中将ssl-protocol属性修改为其它协议，如：ssl, tls, tlsv1.1, tlsv1.2,tlsv1.3, sslv3等等。\n\nforest:\n  ...\n  ssl-protocol: tls\n\n\n1\n2\n3\n\n\n全局配置可以配置一个全局统一的ssl协议，但现实情况是有很多不同服务（尤其是第三方）的api会使用不同的ssl协议，这种情况需要针对不同的接口设置不同的ssl协议。\n\n/**\n * 在某个请求接口上通过 sslprotocol 属性设置单向ssl协议\n */\n@get(\n    url = "https://localhost:5555/hello/user",\n    sslprotocol = "tls"\n)\nforestresponse<string> truestsslget();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在一个个方法上设置太麻烦，也可以在 @baserequest 注解中设置一整个接口类的ssl协议\n\n@baserequest(sslprotocol = "tls")\npublic interface sslclient {\n\n    @get("https://localhost:5555/hello/user")\n    string testsend();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 简单双向认证\n\n若是需要在forest中进行双向验证的https请求，也很简单。\n\n在全局配置中添加keystore配置：\n\nforest:\n ...\n ssl-key-stores:\n   - id: keystore1           # id为该keystore的名称，必填\n     file: test.keystore     # 公钥文件地址\n     keystore-pass: 123456   # keystore秘钥\n     cert-pass: 123456       # cert秘钥\n     protocols: tls          # ssl协议\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<forest:configuration>\n    <forest:ssl-keystore\n            id="keystore1"\n            file="test.keystore"\n            keystorepass="123456"\n            certpass="123456"\n            protocols="tls"/>\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// 获取forest全局配置对象\nconfiguration = forest.config();\n// 实例化 sslkeystore 对象，并输入参数\nsslkeystore sslkeystore = new sslkeystore(\n    "keystore1",\n    "ssl_client.keystore",\n    "client",\n    "456789",\n    null,\n    null);\n// 注册 sslkeystore 对象\nconfiguration.registerkeystore(sslkeystore);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n接着，在@request中引入该keystore的id即可\n\n@get(url = "/user_info", keystore = "keystore1")\nforestresponse<string> getuserinfo();\n\n\n1\n2\n\n\n另外，您也可以在全局配置中配多个keystore：\n\nforest:\n  ...\n  ssl-key-stores:\n    - id: keystore1          # 第一个keystore\n      file: test1.keystore    \n      keystore-pass: 123456  \n      cert-pass: 123456      \n      protocols: ssl       \n\n    - id: keystore2          # 第二个keystore\n      file: test2.keystore    \n      keystore-pass: abcdef  \n      cert-pass: abcdef      \n      protocols: tls       \n      ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n随后在某个具体@request中配置其中任意一个keystore的id都可以\n\n\n# 更复杂的ssl验证\n\n对于一些更复杂的ssl验证，光靠简单的配置无法完全应付，但在forest中也可以通过自定义sslsocketfactory和hostnameverifier的方式提供更灵活的解决方案\n\n\n# 自定义sslsocketfactory\n\nforest提供了sslsocketfactorybuilder接口，通过实现该接口可以自定义sslsocketfactory\n\n/**\n * 自定义 sslsocketfactory 构造器\n */\npublic class mysslsocketfactorybuilder implements sslsocketfactorybuilder {\n\n    /**\n     * 获取ssl socket factory\n     */\n    @override\n    public sslsocketfactory getsslsocketfactory(forestrequest request, string protocol) throws exception {\n        sslcontext sslcontext = sslcontext.getinstance("tls");\n        sslcontext.init(null,\n                new trustmanager[] { new trustallmanager() },\n                new securerandom());\n        return sslcontext.getsocketfactory();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后通过@sslsocketfactorybuilder注解引入自定义的sslsocketfactorybuilder接口实现类\n\n@get("/user_info")\n@sslsocketfactorybuilder(mysslsocketfactorybuilder.class)\nforestrequest<string> getuserinfo();\n\n\n1\n2\n3\n\n\n\n# 自定义hostnameverifier\n\n在forest中，也可以指定自定义的hostnameverifier接口实现类\n\n/**\n * 自定义主机名验证器\n */\npublic class myhostnameverifier implements hostnameverifier {\n    @override\n    public boolean verify(string s, sslsession sslsession) {\n        system.out.println("do myhostnameverifier");\n        if ("localhost".equals(s)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n然后通过@sslhostnameverifier注解引入自定义的主机名验证器类\n\n@get("/user_info")\n@sslhostnameverifier(myhostnameverifier.class)\nforestrequest<string> getuserinfo();\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:42:44",lastUpdatedTimestamp:1658328164e3},{title:"🛸 使用代理",frontmatter:{id:"proxy",title:"🛸 使用代理",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/proxy/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.proxy.html",relativePath:"001.v1.5.x文档/040.声明式接口/020.proxy.md",key:"v-66f72f14",path:"/pages/1.5.x/proxy/",headers:[{level:3,title:"正向代理",slug:"正向代理",normalizedTitle:"正向代理",charIndex:115},{level:3,title:"设置正向代理",slug:"设置正向代理",normalizedTitle:"设置正向代理",charIndex:392},{level:3,title:"设置用户名密码",slug:"设置用户名密码",normalizedTitle:"设置用户名密码",charIndex:1114}],headersStr:"正向代理 设置正向代理 设置用户名密码",content:'众所周知，我们平时访问HTTP，就是直接输入URL外加Query参数或Body参数就开始直接发送请求，随后等待服务端响应便可。请求通过内网或公网一般都可以正常工作（如果客户端和服务端设备正常联通网络的话），就如下图所示：\n\n\n# 正向代理\n\n但也有很多服务由于网络限制等诸多原因，无法直接访问到。这时候就需要先连接代理服务器，然后再由代理服务器转发请求到您原本要访问的原始服务器。 这种方式，便称为正向代理，过程如下图所示：\n\n当然，正向代理除了能访问原本访问不到的资源这一功能外，还有其它用处：\n\n * 访问原来无法访问的资源，如: Google、油管、企业私有网络服务等\n * 做缓存，加速访问速度\n * 对客户端访问授权和认证\n * 记录用户访问记录（上网行为管理）\n\n除了有正向代理外，自然也有反向代理，但这个概念不在本文档讨论范围，有兴趣可以自行搜索查询相关资料。\n\n\n# 设置正向代理\n\nForest从1.5.0-RC1版本开始支持HTTP网络代理，而作为一个HTTP客户端框架，自然提供的是对正向代理的支持。\n\n通过@HTTPProxy注解便可以非常简单地为某一个请求方法设置代理，该注解有两个属性：\n\n * host: 代理服务器主机地址\n\n * port: 代理服务器端口号\n\n/**\n * 使用 @HTTPProxy 注解设置代理服务器\n * host属性为代理服务器主机地址\n * port属性为代理服务器端口号\n */\n@Post(\n    url = "http://localhost:8080/hello",\n    data = "username=foo&password=123456"\n)\n@HTTPProxy(host = "127.0.0.1", port = "10801")\nString simplePostWithProxy(@Header("Accept") String accept);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n@HTTPProxy注解也可以设置在接口类上，批量给接口中所有方法设置相同的代理服务器\n\n/**\n * 为 PostClient 接口中所有的请发方法设置代理服务器\n */\n@BaseRequest(baseURL = "http://localhost:8080")\n@HTTPProxy(host = "127.0.0.1", port = "10801")\npublic interface PostClient {\n    \n    ... ...\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 设置用户名密码\n\n如果您访问的代理服务器需要进行身份校验，则在 @HTTProxy 注解中设置用户名和密码\n\n/**\n * 在 @HTTPProxy 注解中有 username 和 password 属性\n * 分别用于设置代理服务的用户名和密码进行身份验证\n */\n@Post(\n    url = "http://localhost:8080/hello",\n    data = "username=foo&password=123456"\n)\n@HTTPProxy(\n        host = "127.0.0.1",\n        port = "10801",\n        username = "foo",\n        password = "bar"\n)\nString simplePostWithProxy(@Header("Accept") String accept);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'众所周知，我们平时访问http，就是直接输入url外加query参数或body参数就开始直接发送请求，随后等待服务端响应便可。请求通过内网或公网一般都可以正常工作（如果客户端和服务端设备正常联通网络的话），就如下图所示：\n\n\n# 正向代理\n\n但也有很多服务由于网络限制等诸多原因，无法直接访问到。这时候就需要先连接代理服务器，然后再由代理服务器转发请求到您原本要访问的原始服务器。 这种方式，便称为正向代理，过程如下图所示：\n\n当然，正向代理除了能访问原本访问不到的资源这一功能外，还有其它用处：\n\n * 访问原来无法访问的资源，如: google、油管、企业私有网络服务等\n * 做缓存，加速访问速度\n * 对客户端访问授权和认证\n * 记录用户访问记录（上网行为管理）\n\n除了有正向代理外，自然也有反向代理，但这个概念不在本文档讨论范围，有兴趣可以自行搜索查询相关资料。\n\n\n# 设置正向代理\n\nforest从1.5.0-rc1版本开始支持http网络代理，而作为一个http客户端框架，自然提供的是对正向代理的支持。\n\n通过@httpproxy注解便可以非常简单地为某一个请求方法设置代理，该注解有两个属性：\n\n * host: 代理服务器主机地址\n\n * port: 代理服务器端口号\n\n/**\n * 使用 @httpproxy 注解设置代理服务器\n * host属性为代理服务器主机地址\n * port属性为代理服务器端口号\n */\n@post(\n    url = "http://localhost:8080/hello",\n    data = "username=foo&password=123456"\n)\n@httpproxy(host = "127.0.0.1", port = "10801")\nstring simplepostwithproxy(@header("accept") string accept);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n@httpproxy注解也可以设置在接口类上，批量给接口中所有方法设置相同的代理服务器\n\n/**\n * 为 postclient 接口中所有的请发方法设置代理服务器\n */\n@baserequest(baseurl = "http://localhost:8080")\n@httpproxy(host = "127.0.0.1", port = "10801")\npublic interface postclient {\n    \n    ... ...\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 设置用户名密码\n\n如果您访问的代理服务器需要进行身份校验，则在 @httproxy 注解中设置用户名和密码\n\n/**\n * 在 @httpproxy 注解中有 username 和 password 属性\n * 分别用于设置代理服务的用户名和密码进行身份验证\n */\n@post(\n    url = "http://localhost:8080/hello",\n    data = "username=foo&password=123456"\n)\n@httpproxy(\n        host = "127.0.0.1",\n        port = "10801",\n        username = "foo",\n        password = "bar"\n)\nstring simplepostwithproxy(@header("accept") string accept);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍮 后端框架",frontmatter:{id:"backend",title:"🍮 后端框架",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/backend/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/007.backend.html",relativePath:"001.v1.5.x文档/040.声明式接口/007.backend.md",key:"v-8652de94",path:"/pages/1.5.x/backend/",headers:[{level:2,title:"为何需要不同的后端框架",slug:"为何需要不同的后端框架",normalizedTitle:"为何需要不同的后端框架",charIndex:74},{level:2,title:"全局后端框架",slug:"全局后端框架",normalizedTitle:"全局后端框架",charIndex:540},{level:2,title:"接口/请求后端框架",slug:"接口-请求后端框架",normalizedTitle:"接口/请求后端框架",charIndex:2418},{level:3,title:"后端快捷注解",slug:"后端快捷注解",normalizedTitle:"后端快捷注解",charIndex:2546},{level:3,title:"@Backend 注解",slug:"backend-注解",normalizedTitle:"@backend 注解",charIndex:3232},{level:2,title:"自定义后端 Client 对象",slug:"自定义后端-client-对象",normalizedTitle:"自定义后端 client 对象",charIndex:3837},{level:3,title:"OkHttpClient",slug:"okhttpclient",normalizedTitle:"okhttpclient",charIndex:3935},{level:3,title:"HttpClient",slug:"httpclient",normalizedTitle:"httpclient",charIndex:2565},{level:2,title:"后端 Client 缓存",slug:"后端-client-缓存",normalizedTitle:"后端 client 缓存",charIndex:5726}],headersStr:"为何需要不同的后端框架 全局后端框架 接口/请求后端框架 后端快捷注解 @Backend 注解 自定义后端 Client 对象 OkHttpClient HttpClient 后端 Client 缓存",content:'在之前的章节中我们已经介绍过，Forest分为前端和后端两部分，而后端是由okhttp3和httpclient这样的后端HTTP框架构成的\n\n\n# 为何需要不同的后端框架\n\n可能有些小伙伴会有疑问，既然某一种HTTP包（比如okhttp3）可以作为后端的底层HTTP框架，已提供了日常所有的HTTP请求访问功能，为何还再支持另一种不同的HTTP框架作为后端呢？\n\n这是因为没有一种框架都是完美的，都有各自的优缺点以及差异，比如okhttp3接入相对简单、同步异步容易切换，但很难支持带请求体的GET请求这种非标准的畸形请求（但往往业务中需要这种类型请求）; 而httpclient(5.0版本以下)性能较好，支持各种标准和非标准请求，但接入较为麻烦，还需要依赖很多的jar包，且不支持HTTP/2协议\n\nForest在某种程度上可以被理解为是一个屏蔽层，尽可能地屏蔽不同后端底层HTTP框架之间的差异，比如有统一的接口调用方式、统一的配置等等，但还是有些底层的特性差异是Forest无能为力的，比如让okhttp3的GET请求携带Body这件事就难以做到\n\n对于这样的问题，Forest给出的解决方案就是组合使用不同的后端框架，换句话说就是在需要的地方使用相应的后端框架\n\n\n# 全局后端框架\n\nForest有一个全局唯一的后端，并以此为HTTP请求的默认后端，默认情况下为okhttp3\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\nforest:\n    backend: httpclient # 设置全局后端为 httpclient\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\nforest:\n    backend: okhttp3 # 设置全局后端为 okhttp3\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\n# 设置全局后端为 httpclient\nforest.backend=httpclient\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\n# 设置全局后端为 okhttp3\nforest.backend=okhttp3\n\n\n1\n2\n3\n4\n5\n6\n\n\n\x3c!-- backend 后端HTTP API： httpclient --\x3e\n<forest:configuration\n    ... ...\n    backend="httpclient">\n... ...\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\x3c!-- backend 后端HTTP API： okhttp3 --\x3e\n<forest:configuration\n    ... ...\n    backend="okhttp3">\n... ...\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 目前版本有两种选择：okhttp3 和 httpclient\n// 不填的默认请求为 okhttp3\n\n// 获取全局默认配置对象\nForestConfiguration configuration = Forest.config();\n// 设置全局后端为 httpclient\nconfiguration.setBackend(new HttpclientBackend());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 目前版本有两种选择：okhttp3 和 httpclient\n// 不填的默认请求为 okhttp3\n\n// 获取Forest全局配置对象\nForestConfiguration configuration = Forest.config();\n// 设置全局后端框架为 okhttp3\nconfiguration.setBackend(new OkHttp3Backend());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果要通过代码方式设置后端框架，建议将后端对象作为静态常量常驻于内存，而不是经常重复实例化同样的后端对象\n\npublic class MyBackend {\n    // httpclient 后端对象\n    public final static HttpclientBackend HTTPCLIENT = new HttpclientBackend();\n    // okhttp3 后端对象\n    public final static OkHttp3Backend OKHTTP3 = new OkHttp3Backend();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 获取Forest全局配置对象\nForestConfiguration configuration = Forest.config();\n// 设置全局后端框架为 httpclient\nconfiguration.setBackend(MyBackend.HTTPCLIENT);\n\n\n1\n2\n3\n4\n\n\n// 获取Forest全局配置对象\nForestConfiguration configuration = Forest.config();\n// 设置全局后端框架为 okhttp3\nconfiguration.setBackend(MyBackend.OKHTTP3);\n\n\n1\n2\n3\n4\n\n\n\n# 接口/请求后端框架\n\n全局后端框架可以配置和切换，甚至可以进行动态切换，但很多时候需要同时使用不同的后端框架，比如两个不同的接口分别使用不同的后端\n\n自1.5.5版本后，Forest支持了接口/请求级别的后端框架配置，方便HTTP请求灵活设置后端\n\n\n# 后端快捷注解\n\nForest提供了 @HttpClient 注解和 OkHttp3 注解，分别用于绑定请求的后端为 httpclient 和 okhttp3\n\n\n\n \n\n\n\n\n \n\n\n\n\n// 绑定请求的后端为 httpclient\n@HttpClient\n@Post("/data1")\nString send1(@Body MyUser user);\n\n// 绑定请求的后端为 okhttp3\n@OkHttp3\n@Post("/data2")\nString send2(@Body MyUser user);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果此类注解也绑定到接口上，那么该接口下的所有方法的请求默认为该接口注解指定的后端框架\n\n\n\n \n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n// 设置该请求接口的后端框架默认为 httpclient\n@HttpClient\npublic interface BackendClient2 {\n\n    // 未设置请求的后端，则默认为接口指定的后端框架，即 httpclient\n    @Post("/data1")\n    String send1(@Body MyUser user);\n\n    // 绑定某一方法请求的后端为 okhttp3\n    // 会覆盖掉接口上绑定的后端\n    @OkHttp3\n    @Post("/data2")\n    String send2(@Body MyUser user);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# @Backend 注解\n\n还有一种更为灵活和通用的注解 @Backend, 可以通过传入的字符串参数来确定具体要绑定的后端框架\n\n\n\n \n\n\n\n\n\n\n\n \n\n\n\n\n\n\n// 设置该请求接口的后端框架默认为 httpclient\n@Backend("httpclient")\npublic interface BackendClient2 {\n\n    // 未设置请求的后端，则默认为接口指定的后端框架，即 httpclient\n    @Post("/data1")\n    String send1(@Body MyUser user);\n\n    // 绑定请求的后端为 okhttp3\n    @Backend("okhttp3")\n    @Post("/data2")\n    String send2(@Body MyUser user);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n该注解的参数也支持字符串模板，即可以通过全局变量和参数来动态传入\n\n@Backend("{0}")\n@Post("/data")\nString send(String backend, @Body MyUser user);\n\n\n1\n2\n3\n\n\n提示\n\n对于如何在非 spring/springboot 项目中通过代码设置后端框架，请参见《请求对象 - 后端框架》\n\n\n# 自定义后端 Client 对象\n\nForest 在默认情况下会自动生成后端 Client 对象实例，并进行缓存。但如果您想进行更细致的操作时也可以自行生成和配置后端 Client 对象。\n\n\n# OkHttpClient\n\n自定义 OkHttp3 框架的 OkHttpClient 对象，只需实现OkHttpClientProvider接口\n\npublic class MyOkHttpClientProvider implements OkHttpClientProvider {\n\n    @Override\n    public OkHttpClient getClient(ForestRequest request, LifeCycleHandler lifeCycleHandler) {\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .connectTimeout(700, TimeUnit.SECONDS)\n                .readTimeout(700, TimeUnit.SECONDS)\n                .writeTimeout(700, TimeUnit.SECONDS)\n                .callTimeout(700, TimeUnit.SECONDS)\n                .followSslRedirects(false)\n                .retryOnConnectionFailure(false)\n                .followRedirects(false)\n                .build();\n        return okHttpClient;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n绑定该自定义的 OkHttpClient 对象提供者\n\n\n\n \n\n\n\n@Get("/")\n@OkHttp3(client = MyOkHttpClientProvider.class)\nForestResponse<String> sendData();\n\n\n1\n2\n3\n\n\n\n# HttpClient\n\n同理，自定义 Apache Httpclient 框架的 HttpClient 对象，也只需实现HttpClientProvider接口\n\npublic class MyHttpClientProvider implements HttpClientProvider {\n\n    @Override\n    public HttpClient getClient(ForestRequest request, LifeCycleHandler lifeCycleHandler) {\n        RequestConfig config = RequestConfig.custom()\n                .setConnectTimeout(700 * 1000)\n                .setSocketTimeout(700 * 1000)\n                .setConnectionRequestTimeout(700 * 1000)\n                .setRedirectsEnabled(false)\n                .build();\n        CloseableHttpClient httpClient = HttpClients.custom()\n                .setDefaultRequestConfig(config)\n                .build();\n        return httpClient;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n绑定该自定义的 HttpClient 对象提供者\n\n\n\n \n\n\n\n@Get("/")\n@HttpClient(client = MyHttpClientProvider.class)\nForestResponse<String> sendData();\n\n\n1\n2\n3\n\n\n\n# 后端 Client 缓存\n\n为提高 Forest 请求的执行性能，默认情况下，每个请求所对应的后端客户端对象都会被缓存\n\n请求前，会先去缓存中寻找所需的后端 Client 对象实例，如若没有，则新创建一个并放入该请求所对应的缓存中\n\n接口的缓存开关设定如下:\n\n\n\n\n \n\n\n\n// 关闭后端 Client 缓存\n@Get("/")\n@BackendClient(cache = false)\nForestRequest<String> sendData();\n\n\n1\n2\n3\n4\n',normalizedContent:'在之前的章节中我们已经介绍过，forest分为前端和后端两部分，而后端是由okhttp3和httpclient这样的后端http框架构成的\n\n\n# 为何需要不同的后端框架\n\n可能有些小伙伴会有疑问，既然某一种http包（比如okhttp3）可以作为后端的底层http框架，已提供了日常所有的http请求访问功能，为何还再支持另一种不同的http框架作为后端呢？\n\n这是因为没有一种框架都是完美的，都有各自的优缺点以及差异，比如okhttp3接入相对简单、同步异步容易切换，但很难支持带请求体的get请求这种非标准的畸形请求（但往往业务中需要这种类型请求）; 而httpclient(5.0版本以下)性能较好，支持各种标准和非标准请求，但接入较为麻烦，还需要依赖很多的jar包，且不支持http/2协议\n\nforest在某种程度上可以被理解为是一个屏蔽层，尽可能地屏蔽不同后端底层http框架之间的差异，比如有统一的接口调用方式、统一的配置等等，但还是有些底层的特性差异是forest无能为力的，比如让okhttp3的get请求携带body这件事就难以做到\n\n对于这样的问题，forest给出的解决方案就是组合使用不同的后端框架，换句话说就是在需要的地方使用相应的后端框架\n\n\n# 全局后端框架\n\nforest有一个全局唯一的后端，并以此为http请求的默认后端，默认情况下为okhttp3\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\nforest:\n    backend: httpclient # 设置全局后端为 httpclient\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\nforest:\n    backend: okhttp3 # 设置全局后端为 okhttp3\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\n# 设置全局后端为 httpclient\nforest.backend=httpclient\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 设置全局后端框架\n# 目前版本有两种选择：okhttp3 和 httpclient\n# 不填的默认请求为 okhttp3\n\n# 设置全局后端为 okhttp3\nforest.backend=okhttp3\n\n\n1\n2\n3\n4\n5\n6\n\n\n\x3c!-- backend 后端http api： httpclient --\x3e\n<forest:configuration\n    ... ...\n    backend="httpclient">\n... ...\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\x3c!-- backend 后端http api： okhttp3 --\x3e\n<forest:configuration\n    ... ...\n    backend="okhttp3">\n... ...\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 目前版本有两种选择：okhttp3 和 httpclient\n// 不填的默认请求为 okhttp3\n\n// 获取全局默认配置对象\nforestconfiguration configuration = forest.config();\n// 设置全局后端为 httpclient\nconfiguration.setbackend(new httpclientbackend());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 目前版本有两种选择：okhttp3 和 httpclient\n// 不填的默认请求为 okhttp3\n\n// 获取forest全局配置对象\nforestconfiguration configuration = forest.config();\n// 设置全局后端框架为 okhttp3\nconfiguration.setbackend(new okhttp3backend());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果要通过代码方式设置后端框架，建议将后端对象作为静态常量常驻于内存，而不是经常重复实例化同样的后端对象\n\npublic class mybackend {\n    // httpclient 后端对象\n    public final static httpclientbackend httpclient = new httpclientbackend();\n    // okhttp3 后端对象\n    public final static okhttp3backend okhttp3 = new okhttp3backend();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 获取forest全局配置对象\nforestconfiguration configuration = forest.config();\n// 设置全局后端框架为 httpclient\nconfiguration.setbackend(mybackend.httpclient);\n\n\n1\n2\n3\n4\n\n\n// 获取forest全局配置对象\nforestconfiguration configuration = forest.config();\n// 设置全局后端框架为 okhttp3\nconfiguration.setbackend(mybackend.okhttp3);\n\n\n1\n2\n3\n4\n\n\n\n# 接口/请求后端框架\n\n全局后端框架可以配置和切换，甚至可以进行动态切换，但很多时候需要同时使用不同的后端框架，比如两个不同的接口分别使用不同的后端\n\n自1.5.5版本后，forest支持了接口/请求级别的后端框架配置，方便http请求灵活设置后端\n\n\n# 后端快捷注解\n\nforest提供了 @httpclient 注解和 okhttp3 注解，分别用于绑定请求的后端为 httpclient 和 okhttp3\n\n\n\n \n\n\n\n\n \n\n\n\n\n// 绑定请求的后端为 httpclient\n@httpclient\n@post("/data1")\nstring send1(@body myuser user);\n\n// 绑定请求的后端为 okhttp3\n@okhttp3\n@post("/data2")\nstring send2(@body myuser user);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果此类注解也绑定到接口上，那么该接口下的所有方法的请求默认为该接口注解指定的后端框架\n\n\n\n \n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n// 设置该请求接口的后端框架默认为 httpclient\n@httpclient\npublic interface backendclient2 {\n\n    // 未设置请求的后端，则默认为接口指定的后端框架，即 httpclient\n    @post("/data1")\n    string send1(@body myuser user);\n\n    // 绑定某一方法请求的后端为 okhttp3\n    // 会覆盖掉接口上绑定的后端\n    @okhttp3\n    @post("/data2")\n    string send2(@body myuser user);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# @backend 注解\n\n还有一种更为灵活和通用的注解 @backend, 可以通过传入的字符串参数来确定具体要绑定的后端框架\n\n\n\n \n\n\n\n\n\n\n\n \n\n\n\n\n\n\n// 设置该请求接口的后端框架默认为 httpclient\n@backend("httpclient")\npublic interface backendclient2 {\n\n    // 未设置请求的后端，则默认为接口指定的后端框架，即 httpclient\n    @post("/data1")\n    string send1(@body myuser user);\n\n    // 绑定请求的后端为 okhttp3\n    @backend("okhttp3")\n    @post("/data2")\n    string send2(@body myuser user);\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n该注解的参数也支持字符串模板，即可以通过全局变量和参数来动态传入\n\n@backend("{0}")\n@post("/data")\nstring send(string backend, @body myuser user);\n\n\n1\n2\n3\n\n\n提示\n\n对于如何在非 spring/springboot 项目中通过代码设置后端框架，请参见《请求对象 - 后端框架》\n\n\n# 自定义后端 client 对象\n\nforest 在默认情况下会自动生成后端 client 对象实例，并进行缓存。但如果您想进行更细致的操作时也可以自行生成和配置后端 client 对象。\n\n\n# okhttpclient\n\n自定义 okhttp3 框架的 okhttpclient 对象，只需实现okhttpclientprovider接口\n\npublic class myokhttpclientprovider implements okhttpclientprovider {\n\n    @override\n    public okhttpclient getclient(forestrequest request, lifecyclehandler lifecyclehandler) {\n        okhttpclient okhttpclient = new okhttpclient.builder()\n                .connecttimeout(700, timeunit.seconds)\n                .readtimeout(700, timeunit.seconds)\n                .writetimeout(700, timeunit.seconds)\n                .calltimeout(700, timeunit.seconds)\n                .followsslredirects(false)\n                .retryonconnectionfailure(false)\n                .followredirects(false)\n                .build();\n        return okhttpclient;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n绑定该自定义的 okhttpclient 对象提供者\n\n\n\n \n\n\n\n@get("/")\n@okhttp3(client = myokhttpclientprovider.class)\nforestresponse<string> senddata();\n\n\n1\n2\n3\n\n\n\n# httpclient\n\n同理，自定义 apache httpclient 框架的 httpclient 对象，也只需实现httpclientprovider接口\n\npublic class myhttpclientprovider implements httpclientprovider {\n\n    @override\n    public httpclient getclient(forestrequest request, lifecyclehandler lifecyclehandler) {\n        requestconfig config = requestconfig.custom()\n                .setconnecttimeout(700 * 1000)\n                .setsockettimeout(700 * 1000)\n                .setconnectionrequesttimeout(700 * 1000)\n                .setredirectsenabled(false)\n                .build();\n        closeablehttpclient httpclient = httpclients.custom()\n                .setdefaultrequestconfig(config)\n                .build();\n        return httpclient;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n绑定该自定义的 httpclient 对象提供者\n\n\n\n \n\n\n\n@get("/")\n@httpclient(client = myhttpclientprovider.class)\nforestresponse<string> senddata();\n\n\n1\n2\n3\n\n\n\n# 后端 client 缓存\n\n为提高 forest 请求的执行性能，默认情况下，每个请求所对应的后端客户端对象都会被缓存\n\n请求前，会先去缓存中寻找所需的后端 client 对象实例，如若没有，则新创建一个并放入该请求所对应的缓存中\n\n接口的缓存开关设定如下:\n\n\n\n\n \n\n\n\n// 关闭后端 client 缓存\n@get("/")\n@backendclient(cache = false)\nforestrequest<string> senddata();\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/08/03, 10:45:07",lastUpdatedTimestamp:1659494707e3},{title:"🍪 使用Cookie",frontmatter:{id:"cookie",title:"🍪 使用Cookie",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/cookie/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/019.cookie.html",relativePath:"001.v1.5.x文档/040.声明式接口/019.cookie.md",key:"v-4d0b84ec",path:"/pages/1.5.x/cookie/",headers:[{level:2,title:"回调函数方式",slug:"回调函数方式",normalizedTitle:"回调函数方式",charIndex:153},{level:2,title:"拦截器方式",slug:"拦截器方式",normalizedTitle:"拦截器方式",charIndex:1174},{level:2,title:"严格匹配模式 (v1.5.25)",slug:"严格匹配模式-v1-5-25",normalizedTitle:"严格匹配模式 (v1.5.25)",charIndex:2925}],headersStr:"回调函数方式 拦截器方式 严格匹配模式 (v1.5.25)",content:'Cookie是由服务器端生成，发送给客户端（一般为浏览器），并以key-value形式处理和保存在客户端的一组数据。在下次请求同一域名网站时，会将该Cookie数据再次发送到服务端。\n\nForest从1.5.0-RC1版本开始支持Cookie，可以通过回调函数和拦截器两种方式来处理Cookie。\n\n\n# 回调函数方式\n\n在请求接口的参数列表中加入OnSaveCookie 和 OnLoadCookie 回调函数\n\nOnSaveCookie： 在请求响应成功后，需要保存Cookie时调用该回调函数\n\nOnLoadCookie: 在发送请求前，需要加载Cookie时调用该回调函数\n\n\n/**\n * 登入接口(需要接受Cookie)\n */\n@Post("http://localhost:8080/login?username=foo")\nForestResponse testLogin(@Body UserLoginDTO userLogin, OnSaveCookie onSaveCookie);\n\n/**\n * 登入后测试接口(需要传入Cookie)\n */\n@Post("http://localhost:8080/test")\nForestResponse testAfterLogin(OnLoadCookie onLoadCookie);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nForest不会自动处理或持久化服务端传来的Cookie数据，需要自己在回调函数中接到Cookie后自行处理。\n\n\nAtomicReference<ForestCookie> cookieAtomic = new AtomicReference<>(null);\n\n// 调用登入接口\ntestClient.testLogin(userLogin, (request, cookies) -> {\n    // 将服务端传来的Cookie放入cookieAtomic\n    cookieAtomic.set(cookies.allCookies().get(0));\n});\n\n// 获取Cookie\nForestCookie cookie = cookieAtomic.get();\n\n// 调用登入后的测试接口\nForestResponse response = testClient.testAfterLogin((request, cookies) -> {\n    // 将之前调用登入接口获得的Cookie传入请求发送到服务端\n    cookies.addCookie(cookie);\n});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 拦截器方式\n\n拦截器方式原理上和回调函数方式一样，只不过OnSaveCookie 和 OnLoadCookie 回调函数接口变成了拦截器中的 onSaveCookie(ForestRequest, ForestCookies) 方法和 onLoadCookie(ForestRequest, ForestCookies) 方法。\n\n/**\n * 处理Cookie的拦截器\n */\npublic class CookieInterceptor implements Interceptor {\n    \n    // Cookie在本地存储的缓存\n    private Map<String, List<ForestCookie>> cookieCache = new ConcurrentHashMap<>();\n\n    /**\n     * 在请求响应成功后，需要保存Cookie时调用该方法\n     *\n     * @param request Forest请求对象\n     * @param cookies Cookie集合，通过响应返回的Cookie都从该集合获取\n     */\n    @Override\n    public void onSaveCookie(ForestRequest request, ForestCookies cookies) {\n        // 获取请求URI的主机名\n        String host = request.getURI().getHost();\n        // 将从服务端获得的Cookie列表放入缓存，主机名作为Key\n        cookieCache.put(host, cookies.allCookies());\n    }\n\n    /**\n     * 在发送请求前，需要加载Cookie时调用该方法\n     *\n     * @param request Forest请求对象\n     * @param cookies Cookie集合, 需要通过请求发送的Cookie都添加到该集合\n     */\n    @Override\n    public void onLoadCookie(ForestRequest request, ForestCookies cookies) {\n        // 获取请求URI的主机名\n        String host = request.getURI().getHost();\n        // 从缓存中获取之前获得的Cookie列表，主机名作为Key\n        List<ForestCookie> cookieList = cookieCache.get(host);\n        // 将缓存中的Cookie列表添加到请求Cookie列表中，准备发送到服务端\n        // 默认情况下，只有符合条件 (和请求同域名、同URL路径、未过期) 的 Cookie 才能被添加到请求中\n        cookies.addAllCookies(cookieList);\n    }\n\n    @Override\n    public void onError(ForestRuntimeException ex, ForestRequest request, ForestResponse response) {\n        // ... ...\n    }\n\n    @Override\n    public void onSuccess(Object data, ForestRequest request, ForestResponse response) {\n        // ... ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 严格匹配模式 (v1.5.25)\n\n默认情况下，只有符合条件 (和请求同域名、同URL路径、未过期) 的 Cookie 才能被添加到请求中\n\n这是因为 Forest 的 Cookie 集合默认为严格匹配模式，如果想添加符合匹配要求的 Cookie，只需修改严格匹配为false即可\n\n@Override\npublic void onLoadCookie(ForestRequest request, ForestCookies cookies) {\n    cookies.strict(false) // 设置为非严格匹配模式\n        .addCookie(new ForestCookie("attr1", "foo")) // 不设域名，默认情况下也能添加\n        .addCookie(new ForestCookie("attr2", "bar")) // 不设域名，默认情况下也能添加\n        // 不设域名，只有在非严格匹配模式下可以添加到请求中\n        .addCookie(new ForestCookie("attr3", "foobar").setDomain("xxx.com"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'cookie是由服务器端生成，发送给客户端（一般为浏览器），并以key-value形式处理和保存在客户端的一组数据。在下次请求同一域名网站时，会将该cookie数据再次发送到服务端。\n\nforest从1.5.0-rc1版本开始支持cookie，可以通过回调函数和拦截器两种方式来处理cookie。\n\n\n# 回调函数方式\n\n在请求接口的参数列表中加入onsavecookie 和 onloadcookie 回调函数\n\nonsavecookie： 在请求响应成功后，需要保存cookie时调用该回调函数\n\nonloadcookie: 在发送请求前，需要加载cookie时调用该回调函数\n\n\n/**\n * 登入接口(需要接受cookie)\n */\n@post("http://localhost:8080/login?username=foo")\nforestresponse testlogin(@body userlogindto userlogin, onsavecookie onsavecookie);\n\n/**\n * 登入后测试接口(需要传入cookie)\n */\n@post("http://localhost:8080/test")\nforestresponse testafterlogin(onloadcookie onloadcookie);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nforest不会自动处理或持久化服务端传来的cookie数据，需要自己在回调函数中接到cookie后自行处理。\n\n\natomicreference<forestcookie> cookieatomic = new atomicreference<>(null);\n\n// 调用登入接口\ntestclient.testlogin(userlogin, (request, cookies) -> {\n    // 将服务端传来的cookie放入cookieatomic\n    cookieatomic.set(cookies.allcookies().get(0));\n});\n\n// 获取cookie\nforestcookie cookie = cookieatomic.get();\n\n// 调用登入后的测试接口\nforestresponse response = testclient.testafterlogin((request, cookies) -> {\n    // 将之前调用登入接口获得的cookie传入请求发送到服务端\n    cookies.addcookie(cookie);\n});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 拦截器方式\n\n拦截器方式原理上和回调函数方式一样，只不过onsavecookie 和 onloadcookie 回调函数接口变成了拦截器中的 onsavecookie(forestrequest, forestcookies) 方法和 onloadcookie(forestrequest, forestcookies) 方法。\n\n/**\n * 处理cookie的拦截器\n */\npublic class cookieinterceptor implements interceptor {\n    \n    // cookie在本地存储的缓存\n    private map<string, list<forestcookie>> cookiecache = new concurrenthashmap<>();\n\n    /**\n     * 在请求响应成功后，需要保存cookie时调用该方法\n     *\n     * @param request forest请求对象\n     * @param cookies cookie集合，通过响应返回的cookie都从该集合获取\n     */\n    @override\n    public void onsavecookie(forestrequest request, forestcookies cookies) {\n        // 获取请求uri的主机名\n        string host = request.geturi().gethost();\n        // 将从服务端获得的cookie列表放入缓存，主机名作为key\n        cookiecache.put(host, cookies.allcookies());\n    }\n\n    /**\n     * 在发送请求前，需要加载cookie时调用该方法\n     *\n     * @param request forest请求对象\n     * @param cookies cookie集合, 需要通过请求发送的cookie都添加到该集合\n     */\n    @override\n    public void onloadcookie(forestrequest request, forestcookies cookies) {\n        // 获取请求uri的主机名\n        string host = request.geturi().gethost();\n        // 从缓存中获取之前获得的cookie列表，主机名作为key\n        list<forestcookie> cookielist = cookiecache.get(host);\n        // 将缓存中的cookie列表添加到请求cookie列表中，准备发送到服务端\n        // 默认情况下，只有符合条件 (和请求同域名、同url路径、未过期) 的 cookie 才能被添加到请求中\n        cookies.addallcookies(cookielist);\n    }\n\n    @override\n    public void onerror(forestruntimeexception ex, forestrequest request, forestresponse response) {\n        // ... ...\n    }\n\n    @override\n    public void onsuccess(object data, forestrequest request, forestresponse response) {\n        // ... ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 严格匹配模式 (v1.5.25)\n\n默认情况下，只有符合条件 (和请求同域名、同url路径、未过期) 的 cookie 才能被添加到请求中\n\n这是因为 forest 的 cookie 集合默认为严格匹配模式，如果想添加符合匹配要求的 cookie，只需修改严格匹配为false即可\n\n@override\npublic void onloadcookie(forestrequest request, forestcookies cookies) {\n    cookies.strict(false) // 设置为非严格匹配模式\n        .addcookie(new forestcookie("attr1", "foo")) // 不设域名，默认情况下也能添加\n        .addcookie(new forestcookie("attr2", "bar")) // 不设域名，默认情况下也能添加\n        // 不设域名，只有在非严格匹配模式下可以添加到请求中\n        .addcookie(new forestcookie("attr3", "foobar").setdomain("xxx.com"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/07/21, 00:46:54",lastUpdatedTimestamp:1658335614e3},{title:"🍉 上传下载",frontmatter:{id:"upload_download",title:"🍉 上传下载",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/upload_download/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/021.upload_download.html",relativePath:"001.v1.5.x文档/040.声明式接口/021.upload_download.md",key:"v-934bcb3c",path:"/pages/1.5.x/upload_download/",headers:[{level:3,title:"上传",slug:"上传",normalizedTitle:"上传",charIndex:27},{level:3,title:"多文件批量上传",slug:"多文件批量上传",normalizedTitle:"多文件批量上传",charIndex:1591},{level:3,title:"二进制上传",slug:"二进制上传",normalizedTitle:"二进制上传",charIndex:2319},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:32}],headersStr:"上传 多文件批量上传 二进制上传 下载",content:'Forest从 1.4.0 版本开始支持多种形式的文件上传和文件下载功能\n\n\n# 上传\n\n/**\n * 用@DataFile注解修饰要上传的参数对象\n * OnProgress参数为监听上传进度的回调函数\n */\n@Post(url = "/upload")\nMap upload(@DataFile("file") String filePath, OnProgress onProgress);\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用上传接口以及监听上传进度的代码如下：\n\nMap result = myClient.upload("D:\\\\TestUpload\\\\xxx.jpg", progress -> {\n    System.out.println("total bytes: " + progress.getTotalBytes());   // 文件大小\n    System.out.println("current bytes: " + progress.getCurrentBytes());   // 已上传字节数\n    System.out.println("progress: " + Math.round(progress.getRate() * 100) + "%");  // 已上传百分比\n    if (progress.isDone()) {   // 是否上传完成\n        System.out.println("--------   Upload Completed!   --------");\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在文件上传的接口定义中，除了可以使用字符串表示文件路径外，还可以用以下几种类型的对象表示要上传的文件:\n\n/**\n * File类型对象\n */\n@Post(url = "/upload")\nMap upload(@DataFile("file") File file, OnProgress onProgress);\n\n/**\n * byte数组\n * 使用byte数组和Inputstream对象时一定要定义fileName属性\n */\n@Post(url = "/upload")\nMap upload(@DataFile(value = "file", fileName = "${1}") byte[] bytes, String filename);\n\n/**\n * Inputstream 对象\n * 使用byte数组和Inputstream对象时一定要定义fileName属性\n */\n@Post(url = "/upload")\nMap upload(@DataFile(value = "file", fileName = "${1}") InputStream in, String filename);\n\n/**\n * Spring Web MVC 中的 MultipartFile 对象\n */\n@PostRequest(url = "/upload")\nMap upload(@DataFile(value = "file") MultipartFile multipartFile, OnProgress onProgress);\n\n/**\n * Spring 的 Resource 对象\n */\n@Post(url = "/upload")\nMap upload(@DataFile(value = "file") Resource resource);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 多文件批量上传\n\n\n/**\n * 上传Map包装的文件列表\n * 其中 ${_key} 代表Map中每一次迭代中的键值\n */\n@PostRequest(url = "/upload")\nForestRequest<Map> uploadByteArrayMap(@DataFile(value = "file", fileName = "${_key}") Map<String, byte[]> byteArrayMap);\n\n/**\n * 上传List包装的文件列表\n * 其中 ${_index} 代表每次迭代List的循环计数（从零开始计）\n */\n@PostRequest(url = "/upload")\nForestRequest<Map> uploadByteArrayList(@DataFile(value = "file", fileName = "test-img-${_index}.jpg") List<byte[]> byteArrayList);\n\n/**\n * 上传数组包装的文件列表\n * 其中 ${_index} 代表每次迭代List的循环计数（从零开始计）\n */\n@PostRequest(url = "/upload")\nForestRequest<Map> uploadByteArrayArray(@DataFile(value = "file", fileName = "test-img-${_index}.jpg") byte[][] byteArrayArray);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 二进制上传\n\n对于 application/octect-stream 等非form-data的Content-Type类型，直接用@Body修饰要上传的数据参数\n\n/**\n * 上传Byte数组类型数据\n */\n@Post(\n        url = "/upload/${filename}",\n        contentType = "application/octet-stream"\n)\nString uploadByteArryr(@Body byte[] body, @Var("filename") String filename);\n\n/**\n * 上传File类型数据\n */\n@Post(\n    url = "/upload/${filename}",\n    contentType = "application/octet-stream"\n)\nString uploadFile(@Body File file, @Var("filename") String filename);\n\n/**\n * 上传输入流类型数据\n */\n@Post(\n    url = "/upload/${filename}",\n    contentType = "application/octet-stream"\n)\nString uploadInputStream(@Body InputStream inputStream, @Var("filename") String filename);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 下载\n\n/**\n * 在方法上加上@DownloadFile注解\n * dir属性表示文件下载到哪个目录\n * filename属性表示文件下载成功后以什么名字保存，如果不填，这默认从URL中取得文件名\n * OnProgress参数为监听上传进度的回调函数\n */\n@Get(url = "http://localhost:8080/images/xxx.jpg")\n@DownloadFile(dir = "${0}", filename = "${1}")\nFile downloadFile(String dir, String filename, OnProgress onProgress);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用下载接口以及监听上传进度的代码如下：\n\nFile file = myClient.downloadFile("D:\\\\TestDownload", progress -> {\n    System.out.println("total bytes: " + progress.getTotalBytes());   // 文件大小\n    System.out.println("current bytes: " + progress.getCurrentBytes());   // 已下载字节数\n    System.out.println("progress: " + Math.round(progress.getRate() * 100) + "%");  // 已下载百分比\n    if (progress.isDone()) {   // 是否下载完成\n        System.out.println("--------   Download Completed!   --------");\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果您不想将文件下载到硬盘上，而是直接在内存中读取，可以去掉@DownloadFile注解，并且用以下几种方式定义接口:\n\n\n/**\n * 返回类型用byte[]，可将下载的文件转换成字节数组\n */\n@GetRequest(url = "http://localhost:8080/images/test-img.jpg")\nbyte[] downloadImageToByteArray();\n\n/**\n * 返回类型用InputStream，用流的方式读取文件内容\n */\n@GetRequest(url = "http://localhost:8080/images/test-img.jpg")\nInputStream downloadImageToInputStream();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以InputStream类型接受的数据在读取后一定别忘了关闭流\n\n// 使用 try-with-resource 机制自动关闭流\ntry (InputStream in = downloadImageToInputStream()) {\n    String content = IOUtils.toString(object, StandardCharsets.UTF_8);\n    ... ...\n} catch(Exception ex) {\n    ex.printStackTrace();\n}\n\n// 或者自行关闭流        \nInputStream in = null;\ntry {\n    in = downloadImageToInputStream();\n    String content = IOUtils.toString(object, StandardCharsets.UTF_8);\n    ... ...\n} catch(Exception ex) {\n    ex.printStackTrace();\n} finally {\n    if (in != null){\n        in.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意\n\n用File类型定义的文件下载接口方法，一定要加上@DownloadFile注解',normalizedContent:'forest从 1.4.0 版本开始支持多种形式的文件上传和文件下载功能\n\n\n# 上传\n\n/**\n * 用@datafile注解修饰要上传的参数对象\n * onprogress参数为监听上传进度的回调函数\n */\n@post(url = "/upload")\nmap upload(@datafile("file") string filepath, onprogress onprogress);\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用上传接口以及监听上传进度的代码如下：\n\nmap result = myclient.upload("d:\\\\testupload\\\\xxx.jpg", progress -> {\n    system.out.println("total bytes: " + progress.gettotalbytes());   // 文件大小\n    system.out.println("current bytes: " + progress.getcurrentbytes());   // 已上传字节数\n    system.out.println("progress: " + math.round(progress.getrate() * 100) + "%");  // 已上传百分比\n    if (progress.isdone()) {   // 是否上传完成\n        system.out.println("--------   upload completed!   --------");\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在文件上传的接口定义中，除了可以使用字符串表示文件路径外，还可以用以下几种类型的对象表示要上传的文件:\n\n/**\n * file类型对象\n */\n@post(url = "/upload")\nmap upload(@datafile("file") file file, onprogress onprogress);\n\n/**\n * byte数组\n * 使用byte数组和inputstream对象时一定要定义filename属性\n */\n@post(url = "/upload")\nmap upload(@datafile(value = "file", filename = "${1}") byte[] bytes, string filename);\n\n/**\n * inputstream 对象\n * 使用byte数组和inputstream对象时一定要定义filename属性\n */\n@post(url = "/upload")\nmap upload(@datafile(value = "file", filename = "${1}") inputstream in, string filename);\n\n/**\n * spring web mvc 中的 multipartfile 对象\n */\n@postrequest(url = "/upload")\nmap upload(@datafile(value = "file") multipartfile multipartfile, onprogress onprogress);\n\n/**\n * spring 的 resource 对象\n */\n@post(url = "/upload")\nmap upload(@datafile(value = "file") resource resource);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 多文件批量上传\n\n\n/**\n * 上传map包装的文件列表\n * 其中 ${_key} 代表map中每一次迭代中的键值\n */\n@postrequest(url = "/upload")\nforestrequest<map> uploadbytearraymap(@datafile(value = "file", filename = "${_key}") map<string, byte[]> bytearraymap);\n\n/**\n * 上传list包装的文件列表\n * 其中 ${_index} 代表每次迭代list的循环计数（从零开始计）\n */\n@postrequest(url = "/upload")\nforestrequest<map> uploadbytearraylist(@datafile(value = "file", filename = "test-img-${_index}.jpg") list<byte[]> bytearraylist);\n\n/**\n * 上传数组包装的文件列表\n * 其中 ${_index} 代表每次迭代list的循环计数（从零开始计）\n */\n@postrequest(url = "/upload")\nforestrequest<map> uploadbytearrayarray(@datafile(value = "file", filename = "test-img-${_index}.jpg") byte[][] bytearrayarray);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 二进制上传\n\n对于 application/octect-stream 等非form-data的content-type类型，直接用@body修饰要上传的数据参数\n\n/**\n * 上传byte数组类型数据\n */\n@post(\n        url = "/upload/${filename}",\n        contenttype = "application/octet-stream"\n)\nstring uploadbytearryr(@body byte[] body, @var("filename") string filename);\n\n/**\n * 上传file类型数据\n */\n@post(\n    url = "/upload/${filename}",\n    contenttype = "application/octet-stream"\n)\nstring uploadfile(@body file file, @var("filename") string filename);\n\n/**\n * 上传输入流类型数据\n */\n@post(\n    url = "/upload/${filename}",\n    contenttype = "application/octet-stream"\n)\nstring uploadinputstream(@body inputstream inputstream, @var("filename") string filename);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 下载\n\n/**\n * 在方法上加上@downloadfile注解\n * dir属性表示文件下载到哪个目录\n * filename属性表示文件下载成功后以什么名字保存，如果不填，这默认从url中取得文件名\n * onprogress参数为监听上传进度的回调函数\n */\n@get(url = "http://localhost:8080/images/xxx.jpg")\n@downloadfile(dir = "${0}", filename = "${1}")\nfile downloadfile(string dir, string filename, onprogress onprogress);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用下载接口以及监听上传进度的代码如下：\n\nfile file = myclient.downloadfile("d:\\\\testdownload", progress -> {\n    system.out.println("total bytes: " + progress.gettotalbytes());   // 文件大小\n    system.out.println("current bytes: " + progress.getcurrentbytes());   // 已下载字节数\n    system.out.println("progress: " + math.round(progress.getrate() * 100) + "%");  // 已下载百分比\n    if (progress.isdone()) {   // 是否下载完成\n        system.out.println("--------   download completed!   --------");\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果您不想将文件下载到硬盘上，而是直接在内存中读取，可以去掉@downloadfile注解，并且用以下几种方式定义接口:\n\n\n/**\n * 返回类型用byte[]，可将下载的文件转换成字节数组\n */\n@getrequest(url = "http://localhost:8080/images/test-img.jpg")\nbyte[] downloadimagetobytearray();\n\n/**\n * 返回类型用inputstream，用流的方式读取文件内容\n */\n@getrequest(url = "http://localhost:8080/images/test-img.jpg")\ninputstream downloadimagetoinputstream();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以inputstream类型接受的数据在读取后一定别忘了关闭流\n\n// 使用 try-with-resource 机制自动关闭流\ntry (inputstream in = downloadimagetoinputstream()) {\n    string content = ioutils.tostring(object, standardcharsets.utf_8);\n    ... ...\n} catch(exception ex) {\n    ex.printstacktrace();\n}\n\n// 或者自行关闭流        \ninputstream in = null;\ntry {\n    in = downloadimagetoinputstream();\n    string content = ioutils.tostring(object, standardcharsets.utf_8);\n    ... ...\n} catch(exception ex) {\n    ex.printstacktrace();\n} finally {\n    if (in != null){\n        in.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意\n\n用file类型定义的文件下载接口方法，一定要加上@downloadfile注解',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🚀 请求对象",frontmatter:{title:"🚀 请求对象",date:"2022-07-14T12:21:46.000Z",permalink:"/pages/1.5.x/api_forest_request/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/001.api_forest_request.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/001.api_forest_request.md",key:"v-d3a37f44",path:"/pages/1.5.x/api_forest_request/",headers:[{level:2,title:"请求对象",slug:"请求对象",normalizedTitle:"请求对象",charIndex:2},{level:2,title:"构建请求对象",slug:"构建请求对象",normalizedTitle:"构建请求对象",charIndex:110},{level:2,title:"获取请求对象",slug:"获取请求对象",normalizedTitle:"获取请求对象",charIndex:205}],headersStr:"请求对象 构建请求对象 获取请求对象",content:'# 请求对象\n\n请求对象是Forest中最核心的组件，其类名为ForestRequest\n\n主要承担的作用是，将用户发送的请求中的所有属性和数据都封装在这个对象中，并提供直观的API接口方法对其进行修改和操作。\n\n\n# 构建请求对象\n\n在Forest中有两种创建 ForestRequest 对象的方法：接口方法返回请求对象和编程式接口创建请求对象。\n\n我们先来说第一种方法，即通过自定义的Forest请求接口获取请求对象。\n\n先在请求接口定义的方法中，使用 ForestRequest 作为方法返回类型。再调用该方法后会直接返回 ForestRequest 对象，而不会执行发送请求的过程。\n\npublic interface MyForestClient {\n\n    /**\n     * Get类型请求，url路径为 /test\n     * <p>ForestRequest是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return Forest请求对象\n     */\n    @Get("/test")\n    ForestRequest<?> getForestRequest();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n调用 getForestRequest() 方法后即可获取该方法所对应的 Forest 请求对象。\n\n@Resouce\nMyForestClient myForestClient;\n\n... ...\n        \n// 如果请求方法以 ForestRequest 作为返回值类型\n// 不会直接发送请求\n// 而是直接返回 Forest 请求对象        \nForestRequest<?> request = myForestClient.getForestRequest();\nString path = request.path(); // 得到字符串 /test\n// 手动执行发送请求，并以字符串形式接受响应数据\nString ret = request.execute(String.class);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n友情提示\n\n若请求接口的方法以 ForestRequest 类作为返回值类型，调用该方法时不会直接执行发送请求的过程，而是返回 ForestRequest 类型的对象实例，以便做进一步的操作。 得到 Forest 请求对象后需要手动调用执行方法进行请求发送的过程。 关于如何手动发送请求，请求参见《执行请求》\n\n第二种办法更为简单，即直接通过Forest编程式接口创建请求对象\n\n// 通过ID为 ForestConfiguration Id 的Forest配置来创建一个新的 Forest 请求对象\nForestRequest<?> request1 = Forest.config("ForestConfiguration Id").request();\n// 通过默认全局配置来创建一个新的 Forest 请求对象\nForestRequest<?> request2 = Forest.config().request();\n// 同上，即通过默认全局配置来创建一个新的 Forest 请求对象 (推荐使用)\nForestRequest<?> request3 = Forest.request();\n\n\n1\n2\n3\n4\n5\n6\n\n\nForest.request() 会创建一个包含默认请求属性的ForestRequest对象\n\nForest的编程式接口还提供了其它快速创建请求对象的方法，可以在创建时就指定请求类型和url地址路径\n\n// 创建 GET 请求对象\nForest.get("/");\n// 创建 POST 请求对象\nForest.post("/");\n// 创建 PUT 请求对象\nForest.put("/");\n// 创建 DELETE 请求对象\nForest.delete("/");\n// 创建 HEAD 请求对象\nForest.head("/");\n// 创建 PATCH 请求对象\nForest.patch("/");\n// 创建 OPTIONS 请求对象\nForest.options("/");\n// 创建 TRACE 请求对象\nForest.trace("/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上示例代码中的方法名即为请求类型，参数为url地址，如: get("/") 就会返回 GET 类型请求，同时url地址为 http://localhost/。\n\n此类方法的参数可以接受一个简短的不包含域名/端口号部分的路径字符串作为参数，也可以接受完整的url地址\n\n// 参数只传 path 部分\n// 请求地址为 http://localhost/test\nForest.get("/test")\n\n// 参数传如完整的 URL 地址\n// 请求地址同上，也为 http://localhost/test\nForest.get("http://localhost/test")\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 获取请求对象\n\n在拦截器或 OnError、OnSuccess 等回调函数的参数中可以直接获取 Forest 请求对象，相关内容请参见《拦截器》\n\n下面将接受 ForestRequest 对象各个属性的获取和修改的方法，以及如何执行发送请求的过程。\n\n文档提示\n\n在后面的示例代码中，ForestRequest 对象都将以 request 这一变量名表示。',normalizedContent:'# 请求对象\n\n请求对象是forest中最核心的组件，其类名为forestrequest\n\n主要承担的作用是，将用户发送的请求中的所有属性和数据都封装在这个对象中，并提供直观的api接口方法对其进行修改和操作。\n\n\n# 构建请求对象\n\n在forest中有两种创建 forestrequest 对象的方法：接口方法返回请求对象和编程式接口创建请求对象。\n\n我们先来说第一种方法，即通过自定义的forest请求接口获取请求对象。\n\n先在请求接口定义的方法中，使用 forestrequest 作为方法返回类型。再调用该方法后会直接返回 forestrequest 对象，而不会执行发送请求的过程。\n\npublic interface myforestclient {\n\n    /**\n     * get类型请求，url路径为 /test\n     * <p>forestrequest是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return forest请求对象\n     */\n    @get("/test")\n    forestrequest<?> getforestrequest();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n调用 getforestrequest() 方法后即可获取该方法所对应的 forest 请求对象。\n\n@resouce\nmyforestclient myforestclient;\n\n... ...\n        \n// 如果请求方法以 forestrequest 作为返回值类型\n// 不会直接发送请求\n// 而是直接返回 forest 请求对象        \nforestrequest<?> request = myforestclient.getforestrequest();\nstring path = request.path(); // 得到字符串 /test\n// 手动执行发送请求，并以字符串形式接受响应数据\nstring ret = request.execute(string.class);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n友情提示\n\n若请求接口的方法以 forestrequest 类作为返回值类型，调用该方法时不会直接执行发送请求的过程，而是返回 forestrequest 类型的对象实例，以便做进一步的操作。 得到 forest 请求对象后需要手动调用执行方法进行请求发送的过程。 关于如何手动发送请求，请求参见《执行请求》\n\n第二种办法更为简单，即直接通过forest编程式接口创建请求对象\n\n// 通过id为 forestconfiguration id 的forest配置来创建一个新的 forest 请求对象\nforestrequest<?> request1 = forest.config("forestconfiguration id").request();\n// 通过默认全局配置来创建一个新的 forest 请求对象\nforestrequest<?> request2 = forest.config().request();\n// 同上，即通过默认全局配置来创建一个新的 forest 请求对象 (推荐使用)\nforestrequest<?> request3 = forest.request();\n\n\n1\n2\n3\n4\n5\n6\n\n\nforest.request() 会创建一个包含默认请求属性的forestrequest对象\n\nforest的编程式接口还提供了其它快速创建请求对象的方法，可以在创建时就指定请求类型和url地址路径\n\n// 创建 get 请求对象\nforest.get("/");\n// 创建 post 请求对象\nforest.post("/");\n// 创建 put 请求对象\nforest.put("/");\n// 创建 delete 请求对象\nforest.delete("/");\n// 创建 head 请求对象\nforest.head("/");\n// 创建 patch 请求对象\nforest.patch("/");\n// 创建 options 请求对象\nforest.options("/");\n// 创建 trace 请求对象\nforest.trace("/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上示例代码中的方法名即为请求类型，参数为url地址，如: get("/") 就会返回 get 类型请求，同时url地址为 http://localhost/。\n\n此类方法的参数可以接受一个简短的不包含域名/端口号部分的路径字符串作为参数，也可以接受完整的url地址\n\n// 参数只传 path 部分\n// 请求地址为 http://localhost/test\nforest.get("/test")\n\n// 参数传如完整的 url 地址\n// 请求地址同上，也为 http://localhost/test\nforest.get("http://localhost/test")\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 获取请求对象\n\n在拦截器或 onerror、onsuccess 等回调函数的参数中可以直接获取 forest 请求对象，相关内容请参见《拦截器》\n\n下面将接受 forestrequest 对象各个属性的获取和修改的方法，以及如何执行发送请求的过程。\n\n文档提示\n\n在后面的示例代码中，forestrequest 对象都将以 request 这一变量名表示。',charsets:{cjk:!0},lastUpdated:"2022/07/20, 16:59:33",lastUpdatedTimestamp:1658307573e3},{title:"🚑 异常处理",frontmatter:{id:"exception",title:"🚑 异常处理",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/exception/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/040.%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3/022.exception.html",relativePath:"001.v1.5.x文档/040.声明式接口/022.exception.md",key:"v-587b290e",path:"/pages/1.5.x/exception/",headers:[{level:3,title:"try-catch方式",slug:"try-catch方式",normalizedTitle:"try-catch方式",charIndex:58},{level:3,title:"回调函数方式",slug:"回调函数方式",normalizedTitle:"回调函数方式",charIndex:572},{level:3,title:"ForestResponse",slug:"forestresponse",normalizedTitle:"forestresponse",charIndex:356},{level:3,title:"拦截器方式",slug:"拦截器方式",normalizedTitle:"拦截器方式",charIndex:1956}],headersStr:"try-catch方式 回调函数方式 ForestResponse 拦截器方式",content:'发送HTTP请求不会总是成功的，总会有失败的情况。Forest提供多种异常处理的方法来处理请求失败的过程。\n\n\n# try-catch方式\n\n最常用的是直接用try-catch。Forest请求失败的时候通常会以抛异常的方式报告错误， 获取错误信息只需捕获ForestNetworkException异常类的对象，如示例代码所示：\n\n/**\n * try-catch方式：捕获ForestNetworkException异常类的对象\n */\ntry {\n    String result = myClient.send();\n} catch (ForestNetworkException ex) {\n    int status = ex.getStatusCode(); // 获取请求响应状态码\n    ForestResponse response = ex.getResponse(); // 获取Response对象\n    String content = response.getContent(); // 获取请求的响应内容\n    String resResult = response.getResult(); // 获取方法返回类型对应的最终数据结果\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 回调函数方式\n\n第二种方式是使用OnError回调函数，如示例代码所示：\n\n/**\n * 在请求接口中定义OnError回调函数类型参数\n */\n@Request(\n        url = "http://localhost:8080/hello/user",\n        headers = {"Accept:text/plain"},\n        data = "username=${username}"\n)\nString send(@Var("username") String username, OnError onError);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用的代码如下：\n\n// 在调用接口时，在Lambda中处理错误结果\nmyClient.send("foo",  (ex, request, response) -> {\n    int status = response.getStatusCode(); // 获取请求响应状态码\n    String content = response.getContent(); // 获取请求的响应内容\n    String result = response.getResult(); // 获取方法返回类型对应的最终数据结果\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意\n\n加上OnError回调函数后便不会再向上抛出异常，所有错误信息均通过OnError回调函数的参数获得。\n\n\n# ForestResponse\n\n第三种，用ForestResponse类作为请求方法的返回值类型，示例代码如下：\n\n/**\n * 用`ForestResponse`类作为请求方法的返回值类型, 其泛型参数代表实际返回数据的类型\n */\n@Request(\n        url = "http://localhost:8080/hello/user",\n        headers = {"Accept:text/plain"},\n        data = "username=${username}"\n)\nForestResponse<String> send(@Var("username") String username);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用和处理的过程如下：\n\nForestResponse<String> response = myClient.send("foo");\n// 用isError方法判断请求是否失败, 比如404, 500等情况\nif (response.isError()) {\n    int status = response.getStatusCode(); // 获取请求响应状态码\n    String content = response.getContent(); // 获取请求的响应内容\n    String result = response.getResult(); // 获取方法返回类型对应的最终数据结果\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n以ForestResponse类为返回值类型的方法也不会向上抛出异常，错误信息均通过ForestResponse对象获得。\n\n\n# 拦截器方式\n\n若要批量处理各种不同请求的异常情况，可以定义一个拦截器, 并在拦截器的onError方法中处理异常，示例代码如下：\n\npublic class ErrorInterceptor implements Interceptor<String> {\n\n    // ... ...\n\n    @Override\n    public void onError(ForestRuntimeException ex, ForestRequest request, ForestResponse response) {\n        int status = response.getStatusCode(); // 获取请求响应状态码\n        String content = response.getContent(); // 获取请求的响应内容\n        Object result = response.getResult(); // 获取方法返回类型对应的返回数据结果\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n关于具体如何使用拦截器请参见 《拦截器》',normalizedContent:'发送http请求不会总是成功的，总会有失败的情况。forest提供多种异常处理的方法来处理请求失败的过程。\n\n\n# try-catch方式\n\n最常用的是直接用try-catch。forest请求失败的时候通常会以抛异常的方式报告错误， 获取错误信息只需捕获forestnetworkexception异常类的对象，如示例代码所示：\n\n/**\n * try-catch方式：捕获forestnetworkexception异常类的对象\n */\ntry {\n    string result = myclient.send();\n} catch (forestnetworkexception ex) {\n    int status = ex.getstatuscode(); // 获取请求响应状态码\n    forestresponse response = ex.getresponse(); // 获取response对象\n    string content = response.getcontent(); // 获取请求的响应内容\n    string resresult = response.getresult(); // 获取方法返回类型对应的最终数据结果\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 回调函数方式\n\n第二种方式是使用onerror回调函数，如示例代码所示：\n\n/**\n * 在请求接口中定义onerror回调函数类型参数\n */\n@request(\n        url = "http://localhost:8080/hello/user",\n        headers = {"accept:text/plain"},\n        data = "username=${username}"\n)\nstring send(@var("username") string username, onerror onerror);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用的代码如下：\n\n// 在调用接口时，在lambda中处理错误结果\nmyclient.send("foo",  (ex, request, response) -> {\n    int status = response.getstatuscode(); // 获取请求响应状态码\n    string content = response.getcontent(); // 获取请求的响应内容\n    string result = response.getresult(); // 获取方法返回类型对应的最终数据结果\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意\n\n加上onerror回调函数后便不会再向上抛出异常，所有错误信息均通过onerror回调函数的参数获得。\n\n\n# forestresponse\n\n第三种，用forestresponse类作为请求方法的返回值类型，示例代码如下：\n\n/**\n * 用`forestresponse`类作为请求方法的返回值类型, 其泛型参数代表实际返回数据的类型\n */\n@request(\n        url = "http://localhost:8080/hello/user",\n        headers = {"accept:text/plain"},\n        data = "username=${username}"\n)\nforestresponse<string> send(@var("username") string username);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用和处理的过程如下：\n\nforestresponse<string> response = myclient.send("foo");\n// 用iserror方法判断请求是否失败, 比如404, 500等情况\nif (response.iserror()) {\n    int status = response.getstatuscode(); // 获取请求响应状态码\n    string content = response.getcontent(); // 获取请求的响应内容\n    string result = response.getresult(); // 获取方法返回类型对应的最终数据结果\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n以forestresponse类为返回值类型的方法也不会向上抛出异常，错误信息均通过forestresponse对象获得。\n\n\n# 拦截器方式\n\n若要批量处理各种不同请求的异常情况，可以定义一个拦截器, 并在拦截器的onerror方法中处理异常，示例代码如下：\n\npublic class errorinterceptor implements interceptor<string> {\n\n    // ... ...\n\n    @override\n    public void onerror(forestruntimeexception ex, forestrequest request, forestresponse response) {\n        int status = response.getstatuscode(); // 获取请求响应状态码\n        string content = response.getcontent(); // 获取请求的响应内容\n        object result = response.getresult(); // 获取方法返回类型对应的返回数据结果\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提示\n\n关于具体如何使用拦截器请参见 《拦截器》',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🚢 请求属性",frontmatter:{title:"🚢 请求属性",date:"2022-07-14T12:29:31.000Z",permalink:"/pages/1.5.x/api_request_prop/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/002.api_request_properties.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/002.api_request_properties.md",key:"v-1f0c5104",path:"/pages/1.5.x/api_request_prop/",headersStr:null,content:"Forest请求对象的基本属性和默认值如下表:\n\n属性名                             描述               默认值\ntype                            请求类型             GET\nscheme                          HTTP协议           http\npath                            请求地址路径           /\nhost                            请求主机地址           localhost\nport                            请求地址端口           -1 (代表没有端口号)\nurl                             URL地址            http://localhost/\ncharset                         请求参数的编码字符集       UTF-8\nasync                           是否异步             false\nautoRedirection                 是否自动重定向          true\ntimeout                         请求超时时间           3000 (毫秒)\ndecompressResponseGzipEnabled   是否开启解压GZIP响应内容   false\nmaxRetryCount                   最大请求重试次数         0\nmaxRetryInterval                最大请重试的时间间隔       0 (毫秒)\nretryer                         请求重试器            BackOffRetryer (基于退避算法的重试器)",normalizedContent:"forest请求对象的基本属性和默认值如下表:\n\n属性名                             描述               默认值\ntype                            请求类型             get\nscheme                          http协议           http\npath                            请求地址路径           /\nhost                            请求主机地址           localhost\nport                            请求地址端口           -1 (代表没有端口号)\nurl                             url地址            http://localhost/\ncharset                         请求参数的编码字符集       utf-8\nasync                           是否异步             false\nautoredirection                 是否自动重定向          true\ntimeout                         请求超时时间           3000 (毫秒)\ndecompressresponsegzipenabled   是否开启解压gzip响应内容   false\nmaxretrycount                   最大请求重试次数         0\nmaxretryinterval                最大请重试的时间间隔       0 (毫秒)\nretryer                         请求重试器            backoffretryer (基于退避算法的重试器)",charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"✨ 执行请求",frontmatter:{title:"✨ 执行请求",date:"2022-07-14T12:32:59.000Z",permalink:"/pages/1.5.x/api_execute/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/003.api_execute.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/003.api_execute.md",key:"v-6c0b53bc",path:"/pages/1.5.x/api_execute/",headers:[{level:3,title:"自定义类型",slug:"自定义类型",normalizedTitle:"自定义类型",charIndex:233},{level:3,title:"Type类型",slug:"type类型",normalizedTitle:"type类型",charIndex:460},{level:3,title:"泛型类型",slug:"泛型类型",normalizedTitle:"泛型类型",charIndex:552},{level:3,title:"字符串类型",slug:"字符串类型",normalizedTitle:"字符串类型",charIndex:1214},{level:3,title:"列表类型",slug:"列表类型",normalizedTitle:"列表类型",charIndex:1358},{level:3,title:"Map类型",slug:"map类型",normalizedTitle:"map类型",charIndex:1500},{level:3,title:"响应类型",slug:"响应类型",normalizedTitle:"响应类型",charIndex:1647}],headersStr:"自定义类型 Type类型 泛型类型 字符串类型 列表类型 Map类型 响应类型",content:'ForestRequest 对象可以直接调用 execute() 方法执行请求，即发送请求到远端服务器\n\n// 发送 Get 请求, url: http://localhost/\nForest.get("/").execute();\n// execute 方法会返回服务端响应的数据\nObject ret = Forest.post("/").execute();\n\n\n1\n2\n3\n4\n\n\nForest请求对象也提供多个方法，以满足用不同类型接受数据的需要\n\n\n# 自定义类型\n\nexecute(Class<R> clazz) 执行请求发送过程\n\n * 参数clazz: 结果返回类型, Class 对象\n\n// 以字符串方式接受数据\nString str = Forest.get("/").execute(String.class);\n// 以自定义类型方式接受数据\nMyResult result = Forest.get("/").execute(MyResult.class);\n\n\n1\n2\n3\n4\n\n\n\n# Type类型\n\nexecute(Type type) 执行请求发送过程\n\n * 参数type: 结果返回类型, Type 接口实例\n\n// 使用 TypeReference 工具类包裹泛型类型\nTypeReference<List<String>> typeRef = new TypeReference<List<String>>() {};\n// 获取 Type 对象\nType type = typeRef.getType();\n// 以自定义Type类型形式接受数据\nList<String> strList = Forest.get("/").execute(type);\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意\n\nnew TypeReference实例化的时候一定要带上泛型参数，否则无效\n\n\n# 泛型类型\n\nexecute(TypeReference typeReference) 执行请求发送过程\n\n * 参数typeReference: 结果返回类型的引用, Type 接口实例\n\n// 使用 TypeReference 工具类包裹泛型类型\nTypeReference<List<String>> typeRef = new TypeReference<List<String>>() {};\n// 以带复杂泛型参数的类型形式接受数据\nList<String> strList = Forest.get("/").execute(typeRef);\n\n\n1\n2\n3\n4\n\n\n注意\n\n * new TypeReference实例化的时候一定要带上泛型参数，否则无效\n * TypeReference是com.dtflys.forest.utils包下的类，不要引用到其它库中的同名类型\n\n\n# 字符串类型\n\nexecuteAsString() 执行请求发送过程，并获取字符串类型结果\n\n * 返回值 : 字符串类型数据\n\n// 直接以 String 类型接受数据\nString str = Forest.get("/").executeAsString();\n\n\n1\n2\n\n\n\n# 列表类型\n\nexecuteAsList() 执行请求发送过程，并获取List类型结果\n\n * 返回值 : 列表对象\n\n// 直接以 List 类型接受数据\nList<String> list = Forest.get("/").executeAsList();\n\n\n1\n2\n\n\n\n# Map类型\n\nexecuteAsMap() 执行请求发送过程，并获取Map类型结果\n\n * 返回值 : Map 对象\n\n// 直接以 Map 类型接受数据\nMap<String, String> map = Forest.get("/").executeAsMap();\n\n\n1\n2\n\n\n\n# 响应类型\n\n获取不带泛型的 Forest 响应对象\n\n// 直接以响应类型接受数据\nForestResponse response = Forest.get("/").execute(ForestResponse.class);\n\n\n1\n2\n\n\n获取带泛型的 Forest 响应对象\n\n// 直接以响应类型接受数据, 并带有泛型参数类型\nForestResponse<List<MyUser>> resposne = Forest.get("/").execute(\n        new TypeReference<ForestResponse<List<MyUser>>>() {});\n\n\n1\n2\n3\n',normalizedContent:'forestrequest 对象可以直接调用 execute() 方法执行请求，即发送请求到远端服务器\n\n// 发送 get 请求, url: http://localhost/\nforest.get("/").execute();\n// execute 方法会返回服务端响应的数据\nobject ret = forest.post("/").execute();\n\n\n1\n2\n3\n4\n\n\nforest请求对象也提供多个方法，以满足用不同类型接受数据的需要\n\n\n# 自定义类型\n\nexecute(class<r> clazz) 执行请求发送过程\n\n * 参数clazz: 结果返回类型, class 对象\n\n// 以字符串方式接受数据\nstring str = forest.get("/").execute(string.class);\n// 以自定义类型方式接受数据\nmyresult result = forest.get("/").execute(myresult.class);\n\n\n1\n2\n3\n4\n\n\n\n# type类型\n\nexecute(type type) 执行请求发送过程\n\n * 参数type: 结果返回类型, type 接口实例\n\n// 使用 typereference 工具类包裹泛型类型\ntypereference<list<string>> typeref = new typereference<list<string>>() {};\n// 获取 type 对象\ntype type = typeref.gettype();\n// 以自定义type类型形式接受数据\nlist<string> strlist = forest.get("/").execute(type);\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意\n\nnew typereference实例化的时候一定要带上泛型参数，否则无效\n\n\n# 泛型类型\n\nexecute(typereference typereference) 执行请求发送过程\n\n * 参数typereference: 结果返回类型的引用, type 接口实例\n\n// 使用 typereference 工具类包裹泛型类型\ntypereference<list<string>> typeref = new typereference<list<string>>() {};\n// 以带复杂泛型参数的类型形式接受数据\nlist<string> strlist = forest.get("/").execute(typeref);\n\n\n1\n2\n3\n4\n\n\n注意\n\n * new typereference实例化的时候一定要带上泛型参数，否则无效\n * typereference是com.dtflys.forest.utils包下的类，不要引用到其它库中的同名类型\n\n\n# 字符串类型\n\nexecuteasstring() 执行请求发送过程，并获取字符串类型结果\n\n * 返回值 : 字符串类型数据\n\n// 直接以 string 类型接受数据\nstring str = forest.get("/").executeasstring();\n\n\n1\n2\n\n\n\n# 列表类型\n\nexecuteaslist() 执行请求发送过程，并获取list类型结果\n\n * 返回值 : 列表对象\n\n// 直接以 list 类型接受数据\nlist<string> list = forest.get("/").executeaslist();\n\n\n1\n2\n\n\n\n# map类型\n\nexecuteasmap() 执行请求发送过程，并获取map类型结果\n\n * 返回值 : map 对象\n\n// 直接以 map 类型接受数据\nmap<string, string> map = forest.get("/").executeasmap();\n\n\n1\n2\n\n\n\n# 响应类型\n\n获取不带泛型的 forest 响应对象\n\n// 直接以响应类型接受数据\nforestresponse response = forest.get("/").execute(forestresponse.class);\n\n\n1\n2\n\n\n获取带泛型的 forest 响应对象\n\n// 直接以响应类型接受数据, 并带有泛型参数类型\nforestresponse<list<myuser>> resposne = forest.get("/").execute(\n        new typereference<forestresponse<list<myuser>>>() {});\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎪 请求类型",frontmatter:{title:"🎪 请求类型",date:"2022-07-14T12:34:52.000Z",permalink:"/pages/1.5.x/api_request_type/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/005.api_request_type.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/005.api_request_type.md",key:"v-3002147e",path:"/pages/1.5.x/api_request_type/",headersStr:null,content:'ForestRequest 对象提供了设置/获取请求类型的方法\n\n// 设置请求类型为 GET, 参数为 ForestRequestType 枚举类型\nrequest.setType(ForestRequestType.GET);\n// 获取当前的请求类型，返回 ForestRequestType 枚举\nrequest.getType();\n\n\n1\n2\n3\n4\n\n\n从第二次开始后修改请求类型，就会记录上一次的请求类型的变更历史\n\n// 创建新的 Forest 请求对象\nForestRequest<?> request = Forest.request("/");\n// 第一次设置为 GET 请求\nrequest.setType(ForestRequestType.GET);\n// 第二次设置为 POST 请求\nrequest.setType(ForestRequestType.POST);\n\n\n1\n2\n3\n4\n5\n6\n\n\n在发送请求时会在日志中打印出请求类型的变更历史\n\n[Forest] Request : \n\t[Type Change]: GET -> POST\n\tPOST http://localhost/ HTTP\n\n\n1\n2\n3\n',normalizedContent:'forestrequest 对象提供了设置/获取请求类型的方法\n\n// 设置请求类型为 get, 参数为 forestrequesttype 枚举类型\nrequest.settype(forestrequesttype.get);\n// 获取当前的请求类型，返回 forestrequesttype 枚举\nrequest.gettype();\n\n\n1\n2\n3\n4\n\n\n从第二次开始后修改请求类型，就会记录上一次的请求类型的变更历史\n\n// 创建新的 forest 请求对象\nforestrequest<?> request = forest.request("/");\n// 第一次设置为 get 请求\nrequest.settype(forestrequesttype.get);\n// 第二次设置为 post 请求\nrequest.settype(forestrequesttype.post);\n\n\n1\n2\n3\n4\n5\n6\n\n\n在发送请求时会在日志中打印出请求类型的变更历史\n\n[forest] request : \n\t[type change]: get -> post\n\tpost http://localhost/ http\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎊 后端框架",frontmatter:{title:"🎊 后端框架",date:"2022-07-14T12:33:59.000Z",permalink:"/pages/1.5.x/api_backend/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/004.api_backend.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/004.api_backend.md",key:"v-3ba4607c",path:"/pages/1.5.x/api_backend/",headersStr:null,content:'ForestRequest 对象可以设置/获取该请求所对应的后端框架\n\n// 将后端HTTP框架设置为 httpclient\nrequest.backend("httpclient");\n// 将后端HTTP框架设置为 okhttp3\nrequest.backend("okhttp3");\n// 获取当前请求所对应的后端HTTP框架\nrequet.backend();\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'forestrequest 对象可以设置/获取该请求所对应的后端框架\n\n// 将后端http框架设置为 httpclient\nrequest.backend("httpclient");\n// 将后端http框架设置为 okhttp3\nrequest.backend("okhttp3");\n// 获取当前请求所对应的后端http框架\nrequet.backend();\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🔮 请求地址",frontmatter:{title:"🔮 请求地址",date:"2022-07-14T12:36:38.000Z",permalink:"/pages/1.5.x/api_request_address/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/006.api_request_address.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/006.api_request_address.md",key:"v-56909398",path:"/pages/1.5.x/api_request_address/",headers:[{level:2,title:"URL地址",slug:"url地址",normalizedTitle:"url地址",charIndex:2},{level:2,title:"获取URL地址",slug:"获取url地址",normalizedTitle:"获取url地址",charIndex:30},{level:2,title:"主机地址",slug:"主机地址",normalizedTitle:"主机地址",charIndex:247}],headersStr:"URL地址 获取URL地址 主机地址",content:'# URL地址\n\nForestRequest 对象提供设置/获取URL地址的接口方法\n\nurl(String url) 设置请求URL\n\n * 参数 url : URL字符串\n\nurl(ForestURL url) 设置请求URL\n\n * 参数 url : ForestURL 类实例\n\n// 设置请求URL地址，url: http://127.0.0.1:8080/test\nrequest.url("http://127.0.0.1:8080/test");\n// 设置路径为 /abc, 主机地址和端口部分保留，url: http://127.0.0.1:8080/abc\nrequest.url("/abc");\n// 覆盖掉整个URL地址，url: http://forest.dtflyx.com/111\nrequest.url("http://forest.dtflyx.com/111");\n// 使用 ForestURL 类型对象作为参数，url: http://localhost:8080/222\nrequest.url(new ForestURL(new URL("http://localhost:8080/222")));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhost(String host) 设置URL的主机名/域名/IP地址部分\n\n * 参数 host : 主机名/域名/IP地址\n\n// 修改请求地址中的主机名/IP地址/域名部分，url: http://127.0.0.1:8080/222\nrequest.host("127.0.0.1");\n// 同上，修改请求地址中的主机名/IP地址/域名部分\n        request.url().setHost("127.0.0.1");\n\n\n1\n2\n3\n4\n\n\nport(int port) 设置URL中的端口\n\n * 参数 port : 端口号\n\n// 修改请求地址中的端口号，url: http://127.0.0.1:8888/222\nrequest.port(8888);\n// 同上，修改请求地址中的端口号\n        request.url().setPort(8888);\n\n\n1\n2\n3\n4\n\n\nscheme(String scheme) 设置URL中的HTTP协议头\n\n * 参数 scheme : HTTP协议头\n\n// 修改请求地址中的HTTP协议头，url: https://127.0.0.1:8888/222\nrequest.scheme("https");\n// 同上，修改请求地址中的HTTP协议头\nrequest.url().setScheme("https");\n\n\n1\n2\n3\n4\n\n\npath(String path) 设置URL路径\n\n * 参数 path : URL路径\n\n// 修改请求地址中的路径部分，和url方法类似，但path方法不接受完整url地址作为参数，url: https://127.0.0.1:8888/333\nrequest.path("/333");\n// 同上，修改请求地址中的路径部分\n        request.url().setPath("/333");\n\n\n1\n2\n3\n4\n\n\nref(String ref) 设置Reference, 即URL井号后面的字符串\n\n * 参数 ref: URL井号后面的字符串\n\n// 设置Reference，即URL井号后面的字符串，url: https://127.0.0.1:8888/333#hello\nrequest.ref("hello");\n\n\n1\n2\n\n\n\n# 获取URL地址\n\nurlString() 获取请求URL字符串\n\n * 返回值 : URL字符串\n\nurl() 获取请求URL\n\n * 返回值 : ForestURL 类实例\n\n// 获取URL地址字符串\n// 如：http://localhost:8080/test\nString urlStr = request.urlString();\n// 获取ForestURL类对象\nForestURL url = request.url();\n\n\n1\n2\n3\n4\n5\n\n\nschema() 获取请求地址的HTTP协议头\n\n * 返回值 : HTTP协议头\n\n// 获取URL地址的HTTP协议头\nString schema = request.scheme();\n\n\n1\n2\n\n\nhost() 获取URL中的主机名/域名/IP地址部分\n\n * 返回值 : 主机名/域名/IP地址部分字符串\n\n// 获取请求地址中的主机名/IP地址/域名部分\nString host = request.host();\n// 同上，获取请求地址中的主机名/IP地址/域名部分\nhost = request.url().getHost();\n\n\n1\n2\n3\n4\n\n\nport() 获取URL中的端口号\n\n * 返回值 : int 整数, URL中的端口号\n\n// 获取请求地址中的端口号\n// 如：8080\n// 默认为 -1, 即没有端口号\n// 没有端口号也可以理解为 http 下的 80 和 https 下的 443\nint port = request.port();\n// 同上，获取请求地址中的端口号\nport = request.url().getPort();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npath() 获取URL路径\n\n * 返回值: URL路径\n\n// 获取请求地址中的路径部分，如：/test\nString path = request.path();\n// 同上，获取请求地址中的路径部分\npath = request.url().getPath();\n\n\n1\n2\n3\n4\n\n\n> ref() 获取Reference, 即URL井号后面的字符串\n> \n>  * 返回值: URL井号后面的字符串\n\n// 获取Reference，即URL井号后面的字符串\n// 如：http://localhost/test#hello 中的 hello 那部分字符串\nrequest.ref(); \n\n\n1\n2\n3\n\n\n\n# 主机地址\n\n主机地址包含: 主机名/IP地址/域名 + 端口号\n\n使用 address 方法的好处是，只会修改主机名或端口，不会影响URL的其它部分（比如 Query 参数，HTTP协议头，路径部分等等）\n\n> address(String host, int port) 设置请求的主机地址(主机名/域名/IP地址 + 端口号)\n> \n>  * 参数 host: 主机名/域名/IP地址\n>  * 参数 port: 端口号\n\n// 创建新的请求对象\n// url: http://localhost/test\nForest.get("/test")\n     // 设置请求主机地址，不会改变URL地址的其它部分\n     // 参数1：主机名/IP地址/域名\n     // 参数2：端口号\n     // url: http://192.168.0.1:8881/test\n    .address("192.168.0.1", 8881)\n     // 同上，设置请求主机地址\n     // 参数为 ForestAddress 对象\n     // url: http://192.168.0.2:8882/test\n    .address(new ForestAddress("192.168.0.2", 8882));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',normalizedContent:'# url地址\n\nforestrequest 对象提供设置/获取url地址的接口方法\n\nurl(string url) 设置请求url\n\n * 参数 url : url字符串\n\nurl(foresturl url) 设置请求url\n\n * 参数 url : foresturl 类实例\n\n// 设置请求url地址，url: http://127.0.0.1:8080/test\nrequest.url("http://127.0.0.1:8080/test");\n// 设置路径为 /abc, 主机地址和端口部分保留，url: http://127.0.0.1:8080/abc\nrequest.url("/abc");\n// 覆盖掉整个url地址，url: http://forest.dtflyx.com/111\nrequest.url("http://forest.dtflyx.com/111");\n// 使用 foresturl 类型对象作为参数，url: http://localhost:8080/222\nrequest.url(new foresturl(new url("http://localhost:8080/222")));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhost(string host) 设置url的主机名/域名/ip地址部分\n\n * 参数 host : 主机名/域名/ip地址\n\n// 修改请求地址中的主机名/ip地址/域名部分，url: http://127.0.0.1:8080/222\nrequest.host("127.0.0.1");\n// 同上，修改请求地址中的主机名/ip地址/域名部分\n        request.url().sethost("127.0.0.1");\n\n\n1\n2\n3\n4\n\n\nport(int port) 设置url中的端口\n\n * 参数 port : 端口号\n\n// 修改请求地址中的端口号，url: http://127.0.0.1:8888/222\nrequest.port(8888);\n// 同上，修改请求地址中的端口号\n        request.url().setport(8888);\n\n\n1\n2\n3\n4\n\n\nscheme(string scheme) 设置url中的http协议头\n\n * 参数 scheme : http协议头\n\n// 修改请求地址中的http协议头，url: https://127.0.0.1:8888/222\nrequest.scheme("https");\n// 同上，修改请求地址中的http协议头\nrequest.url().setscheme("https");\n\n\n1\n2\n3\n4\n\n\npath(string path) 设置url路径\n\n * 参数 path : url路径\n\n// 修改请求地址中的路径部分，和url方法类似，但path方法不接受完整url地址作为参数，url: https://127.0.0.1:8888/333\nrequest.path("/333");\n// 同上，修改请求地址中的路径部分\n        request.url().setpath("/333");\n\n\n1\n2\n3\n4\n\n\nref(string ref) 设置reference, 即url井号后面的字符串\n\n * 参数 ref: url井号后面的字符串\n\n// 设置reference，即url井号后面的字符串，url: https://127.0.0.1:8888/333#hello\nrequest.ref("hello");\n\n\n1\n2\n\n\n\n# 获取url地址\n\nurlstring() 获取请求url字符串\n\n * 返回值 : url字符串\n\nurl() 获取请求url\n\n * 返回值 : foresturl 类实例\n\n// 获取url地址字符串\n// 如：http://localhost:8080/test\nstring urlstr = request.urlstring();\n// 获取foresturl类对象\nforesturl url = request.url();\n\n\n1\n2\n3\n4\n5\n\n\nschema() 获取请求地址的http协议头\n\n * 返回值 : http协议头\n\n// 获取url地址的http协议头\nstring schema = request.scheme();\n\n\n1\n2\n\n\nhost() 获取url中的主机名/域名/ip地址部分\n\n * 返回值 : 主机名/域名/ip地址部分字符串\n\n// 获取请求地址中的主机名/ip地址/域名部分\nstring host = request.host();\n// 同上，获取请求地址中的主机名/ip地址/域名部分\nhost = request.url().gethost();\n\n\n1\n2\n3\n4\n\n\nport() 获取url中的端口号\n\n * 返回值 : int 整数, url中的端口号\n\n// 获取请求地址中的端口号\n// 如：8080\n// 默认为 -1, 即没有端口号\n// 没有端口号也可以理解为 http 下的 80 和 https 下的 443\nint port = request.port();\n// 同上，获取请求地址中的端口号\nport = request.url().getport();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npath() 获取url路径\n\n * 返回值: url路径\n\n// 获取请求地址中的路径部分，如：/test\nstring path = request.path();\n// 同上，获取请求地址中的路径部分\npath = request.url().getpath();\n\n\n1\n2\n3\n4\n\n\n> ref() 获取reference, 即url井号后面的字符串\n> \n>  * 返回值: url井号后面的字符串\n\n// 获取reference，即url井号后面的字符串\n// 如：http://localhost/test#hello 中的 hello 那部分字符串\nrequest.ref(); \n\n\n1\n2\n3\n\n\n\n# 主机地址\n\n主机地址包含: 主机名/ip地址/域名 + 端口号\n\n使用 address 方法的好处是，只会修改主机名或端口，不会影响url的其它部分（比如 query 参数，http协议头，路径部分等等）\n\n> address(string host, int port) 设置请求的主机地址(主机名/域名/ip地址 + 端口号)\n> \n>  * 参数 host: 主机名/域名/ip地址\n>  * 参数 port: 端口号\n\n// 创建新的请求对象\n// url: http://localhost/test\nforest.get("/test")\n     // 设置请求主机地址，不会改变url地址的其它部分\n     // 参数1：主机名/ip地址/域名\n     // 参数2：端口号\n     // url: http://192.168.0.1:8881/test\n    .address("192.168.0.1", 8881)\n     // 同上，设置请求主机地址\n     // 参数为 forestaddress 对象\n     // url: http://192.168.0.2:8882/test\n    .address(new forestaddress("192.168.0.2", 8882));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🧀 URL 参数",frontmatter:{title:"🧀 URL 参数",date:"2022-07-20T22:09:05.000Z",permalink:"/pages/api_request_query/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/007.api_request_query.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/007.api_request_query.md",key:"v-b1ff77a4",path:"/pages/api_request_query/",headers:[{level:2,title:"添加参数",slug:"添加参数",normalizedTitle:"添加参数",charIndex:117},{level:2,title:"添加Map参数",slug:"添加map参数",normalizedTitle:"添加map参数",charIndex:602},{level:2,title:"添加对象参数",slug:"添加对象参数",normalizedTitle:"添加对象参数",charIndex:838},{level:2,title:"强制编码",slug:"强制编码",normalizedTitle:"强制编码",charIndex:1246},{level:2,title:"修改参数",slug:"修改参数",normalizedTitle:"修改参数",charIndex:1992},{level:2,title:"数组参数",slug:"数组参数",normalizedTitle:"数组参数",charIndex:2973},{level:2,title:"JSON参数",slug:"json参数",normalizedTitle:"json参数",charIndex:3953},{level:2,title:"获取参数",slug:"获取参数",normalizedTitle:"获取参数",charIndex:4314}],headersStr:"添加参数 添加Map参数 添加对象参数 强制编码 修改参数 数组参数 JSON参数 获取参数",content:'URL参数，也称为Query (查询参数)，是跟随在URL地址中 ? 后的字符串，常以 key=value 的键值对形式出现，用于向服务端传递数据。\n\nForestRequest 对象提供了添加和修改 Query 参数的方法\n\n\n# 添加参数\n\naddQuery(String name, Object value) 添加Query参数\n\n * 参数 name: Query参数名\n * 参数 value: Query参数值\n\nForest.get("/")\n        .addQuery("a", 1)  // 添加 Query 参数 a=1\n        .addQuery("b", 2); // 添加 Query 参数 b=2\n// 最后产生 Query 参数 ?a=1&b=2\n\n\n1\n2\n3\n4\n\n\n适用 ForestRequest.addQuery 方法可以重复添加重名 Query 参数。 此功能可用于传递数组\n\n\nrequest.addQuery("a", 1)  // 添加 Query 参数 a=1\n       .addQuery("a", 2)  // 添加 Query 参数 a=2\n       .addQuery("a", 3); // 添加 Query 参数 a=3\n// 最后产生 Query 参数 ?a=1&a=2&a=3\n\n\n1\n2\n3\n4\n5\n\n\n\n# 添加Map参数\n\naddQuery(Map queryMap) 添加Map类型Query参数\n\n * 参数 queryMap: Map对象\n\nMap<String, Object> map = new HashMap();\nmap.put("a", 1);\nmap.put("b", 2);\nrequest.addQuery(map)  // 添加 Map 对象到 Query 参数中\n// 最后产生 Query 参数 ?a=1&b=2\n\n\n1\n2\n3\n4\n5\n\n\n\n# 添加对象参数\n\naddQuery(Object queryParameters) 添加Java对象类型Query参数\n\n * 参数 queryParameters: 任意类型Java对象\n\n// 自定义一个普通的Java数据类\npublic class MyQuery {\n    private int a;\n    private int b;\n    // getter 和 setter 代码（省略）\n}\n\n// 创建自定义的Java对象实例\nMyQuery myQuery = new MyQuery();\nmyQuery.setA(1);\nmyQuery.setB(2);\nrequest.addQuery(myQuery)  // 添加 Java 对象到 Query 参数中\n// 最后产生 Query 参数 ?a=1&b=2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 强制编码\n\n注意\n\n使用 addQuery(String name, String value) 方法时, 绝大部分Query参数值都会被自动UrlEncode编码，但有某些特殊的参数值不会被编码，如: http://www.baidu.com 这样的url地址会被原封不动保留。\n\n这时候需要使用 addQuery(String name, String value, boolean isUrlEncode, String charset) 方法来强制UrlEncode。\n\naddQuery(String name, String value, boolean isUrlEncode, String charset) 添加Query参数\n\n * 参数 name: Query参数名\n * 参数 value: Query参数值\n * 参数 isUrlEncode: 是否强制UrlEncode\n * 参数 charset: 编码字符集\n\nForest.get("http://127.0.0.1:8080/")\n         // 不强制UrlEncode\n        .addQuery("url1", "http://localhost/test");\n         // 强制UrlEncode\n        .addQuery("url2", "http://localhost/test", true, "UTF-8");\n// 最终url为\n// http://127.0.0.1:8080/?url1=http://localhost/test&url2=http%3A%2F%2Flocalhost%2Ftest\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 修改参数\n\n修改已存在的 Query 参数\n\nreplaceQuery(String name, Object value) 替换Query参数值\n\n * 参数 name: Query参数名\n * 参数 value: Query参数值\n\nrequest.addQuery("a", 1)      // 添加 Query 参数 a=1\n       .replaceQuery("a", 2); // 修改 Query 参数 a=2\n// 最后产生 Query 参数 ?a=2\n\n\n1\n2\n3\n\n\nForestRequest.replaceQuery 可以方法修改 Query 参数，但对于还不存在的 Query 参数就无法处理了\n\n// 创建一个新请求对象\n// url: http://localhost/\nForest.get("/")\n       // 这时候还不存在 Query 参数 a\n       // 所以此时调用 replaceQuery 是无效的\n      .replaceQuery("a", "1");\n// 最后地址还是为 http://localhost/\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这时候可以用 ForestRequest.replaceOrAddQuery 方法，它在 Query 参数不存在的情况下添加参数，在已存在的情况下修改参数\n\nreplaceOrAddQuery(String name, String value) 替换或添加Query参数\n\n * 参数 name: Query参数名\n * 参数 value: Query参数值\n\n// 创建一个新请求对象\n// url: http://localhost/\nForest.get("/");\n      .replaceOrAddQuery("a", "1")  // 添加或修改 Query 参数 a=1\n      .addQuery("b", "2")           // 修改 Query 参数 a=2\n      .replaceOrAddQuery("b", "3"); // 添加或修改 Query 参数 b=3\n// 最后地址还是为 http://localhost/?a=1&b=3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数组参数\n\n有些时候，需要通过URL参数传递一个数组或者一个列表\n\n// 添加列表到Query参数\nList<Integer> list = Arrays.asList(1, 2, 3);\nForest.get("/")\n     .addQuery("a", list)\n     .execute();\n// query参数为 a=1&a=2&a=3\n\n// 添加数组到Query参数\nObject[] array = new Object[] {1, 2, 3};\nForest.get("/")\n     .addQuery("a", array)\n     .execute();\n// Query参数为 a=1&a=2&a=3\n\n// 添加数组到Query参数 (可变参数)\nForest.get("/")\n     .addQuery("a", 1, 2, 3)\n     .execute();\n// Query参数为 a=1&a=2&a=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n带方括号[]参数名的样式\n\n// 添加列表到Query参数\nList<Integer> list = Arrays.asList(1, 2, 3);\nForest.get("/")\n     .addArrayQuery("a", list)\n     .execute();\n// query参数为 a[]=1&a[]=2&a[]=3\n\n// 添加数组到Query参数\nObject[] array = new Object[] {1, 2, 3};\nForest.get("/")\n     .addArrayQuery("a", array)\n     .execute();\n// Query参数为 a[]=1&a[]=2&a[]=3\n\n// 添加数组到Query参数 (可变参数)\nForest.get("/")\n     .addArrayQuery("a", 1, 2, 3)\n     .execute();\n// Query参数为 a[]=1&a[]=2&a[]=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# JSON参数\n\n如果不想以URL参数的标准格式传递列表，JSON字符串也是一种选择\n\naddJSONQuery(String name, Object value) 添加 JSON Query 参数\n\n * 参数name: Query参数名\n * 参数value: Query参数值，将被序列化为JSON字符串\n\n// 添加列表到Query数组参数\nForest.get("/")\n     .addJSONQuery("a", Arrays.asList(1, 2, 3))\n     .execute();\n// query参数为 a=[1,2,3]\n// 注意：这里的JSON数据最终会被 URLEncode\n// 所以最终请求的参数为 a=%5B1%2C2%2C3%5D\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 获取参数\n\n获取请求的整个 Query 参数表\n\ngetQuery() 获取请求的Query参数表\n\n * 返回值: Query参数表，ForestQueryMap 类实例\n\n// 构建请求\n// Query 参数为 a=1&b=2&b=3\nForestRequest<?> request = Forest.get("/")\n        .addQuery("a", 1)\n        .addQuery("b", 2)\n        .addQuery("b", 3);\n// 获取 Query 参数表\nForestQueryMap queries = request.getQuery();\n// 返回参数为 a=1 的 ForestQueryParameter 对象\nForestQueryParameter param1 = queries.getQuery("a");\n// 返回包含 b=2和b=3 的 ForestQueryParameter 对象列表\nList<ForestQueryParameter> params = queries.getQueries("b"); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n获取单个 Query 参数\n\ngetQuery(String name) 根据名称获取请求的Query参数值\n\n * 参数name: Query参数名称\n * 返回值: Query参数值\n\n// 构建请求\n// Query 参数为 a=1&b=2&b=3\nForestRequest<?> request = Forest.get("/")\n        .addQuery("a", 1)\n        .addQuery("b", 2);\n\nrequest.getQuery("a"); // 获取 1\nrequest.getQuery("b"); // 获取 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n获取整个请求的 Query 参数字符串\n\ngetQueryString() 获取请求的URL Query参数字符串\n\n * 返回值: Query参数字符串\n\n// 构建请求\n// Query 参数为 a=1&b=2&b=3\nForestRequest<?> request = Forest.get("/")\n        .addQuery("a", 1)\n        .addQuery("b", 2)\n        .addQuery("c", 3);\n\nrequest.getQueryString(); // 获取 a=1&b=2&c=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'url参数，也称为query (查询参数)，是跟随在url地址中 ? 后的字符串，常以 key=value 的键值对形式出现，用于向服务端传递数据。\n\nforestrequest 对象提供了添加和修改 query 参数的方法\n\n\n# 添加参数\n\naddquery(string name, object value) 添加query参数\n\n * 参数 name: query参数名\n * 参数 value: query参数值\n\nforest.get("/")\n        .addquery("a", 1)  // 添加 query 参数 a=1\n        .addquery("b", 2); // 添加 query 参数 b=2\n// 最后产生 query 参数 ?a=1&b=2\n\n\n1\n2\n3\n4\n\n\n适用 forestrequest.addquery 方法可以重复添加重名 query 参数。 此功能可用于传递数组\n\n\nrequest.addquery("a", 1)  // 添加 query 参数 a=1\n       .addquery("a", 2)  // 添加 query 参数 a=2\n       .addquery("a", 3); // 添加 query 参数 a=3\n// 最后产生 query 参数 ?a=1&a=2&a=3\n\n\n1\n2\n3\n4\n5\n\n\n\n# 添加map参数\n\naddquery(map querymap) 添加map类型query参数\n\n * 参数 querymap: map对象\n\nmap<string, object> map = new hashmap();\nmap.put("a", 1);\nmap.put("b", 2);\nrequest.addquery(map)  // 添加 map 对象到 query 参数中\n// 最后产生 query 参数 ?a=1&b=2\n\n\n1\n2\n3\n4\n5\n\n\n\n# 添加对象参数\n\naddquery(object queryparameters) 添加java对象类型query参数\n\n * 参数 queryparameters: 任意类型java对象\n\n// 自定义一个普通的java数据类\npublic class myquery {\n    private int a;\n    private int b;\n    // getter 和 setter 代码（省略）\n}\n\n// 创建自定义的java对象实例\nmyquery myquery = new myquery();\nmyquery.seta(1);\nmyquery.setb(2);\nrequest.addquery(myquery)  // 添加 java 对象到 query 参数中\n// 最后产生 query 参数 ?a=1&b=2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 强制编码\n\n注意\n\n使用 addquery(string name, string value) 方法时, 绝大部分query参数值都会被自动urlencode编码，但有某些特殊的参数值不会被编码，如: http://www.baidu.com 这样的url地址会被原封不动保留。\n\n这时候需要使用 addquery(string name, string value, boolean isurlencode, string charset) 方法来强制urlencode。\n\naddquery(string name, string value, boolean isurlencode, string charset) 添加query参数\n\n * 参数 name: query参数名\n * 参数 value: query参数值\n * 参数 isurlencode: 是否强制urlencode\n * 参数 charset: 编码字符集\n\nforest.get("http://127.0.0.1:8080/")\n         // 不强制urlencode\n        .addquery("url1", "http://localhost/test");\n         // 强制urlencode\n        .addquery("url2", "http://localhost/test", true, "utf-8");\n// 最终url为\n// http://127.0.0.1:8080/?url1=http://localhost/test&url2=http%3a%2f%2flocalhost%2ftest\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 修改参数\n\n修改已存在的 query 参数\n\nreplacequery(string name, object value) 替换query参数值\n\n * 参数 name: query参数名\n * 参数 value: query参数值\n\nrequest.addquery("a", 1)      // 添加 query 参数 a=1\n       .replacequery("a", 2); // 修改 query 参数 a=2\n// 最后产生 query 参数 ?a=2\n\n\n1\n2\n3\n\n\nforestrequest.replacequery 可以方法修改 query 参数，但对于还不存在的 query 参数就无法处理了\n\n// 创建一个新请求对象\n// url: http://localhost/\nforest.get("/")\n       // 这时候还不存在 query 参数 a\n       // 所以此时调用 replacequery 是无效的\n      .replacequery("a", "1");\n// 最后地址还是为 http://localhost/\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这时候可以用 forestrequest.replaceoraddquery 方法，它在 query 参数不存在的情况下添加参数，在已存在的情况下修改参数\n\nreplaceoraddquery(string name, string value) 替换或添加query参数\n\n * 参数 name: query参数名\n * 参数 value: query参数值\n\n// 创建一个新请求对象\n// url: http://localhost/\nforest.get("/");\n      .replaceoraddquery("a", "1")  // 添加或修改 query 参数 a=1\n      .addquery("b", "2")           // 修改 query 参数 a=2\n      .replaceoraddquery("b", "3"); // 添加或修改 query 参数 b=3\n// 最后地址还是为 http://localhost/?a=1&b=3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数组参数\n\n有些时候，需要通过url参数传递一个数组或者一个列表\n\n// 添加列表到query参数\nlist<integer> list = arrays.aslist(1, 2, 3);\nforest.get("/")\n     .addquery("a", list)\n     .execute();\n// query参数为 a=1&a=2&a=3\n\n// 添加数组到query参数\nobject[] array = new object[] {1, 2, 3};\nforest.get("/")\n     .addquery("a", array)\n     .execute();\n// query参数为 a=1&a=2&a=3\n\n// 添加数组到query参数 (可变参数)\nforest.get("/")\n     .addquery("a", 1, 2, 3)\n     .execute();\n// query参数为 a=1&a=2&a=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n带方括号[]参数名的样式\n\n// 添加列表到query参数\nlist<integer> list = arrays.aslist(1, 2, 3);\nforest.get("/")\n     .addarrayquery("a", list)\n     .execute();\n// query参数为 a[]=1&a[]=2&a[]=3\n\n// 添加数组到query参数\nobject[] array = new object[] {1, 2, 3};\nforest.get("/")\n     .addarrayquery("a", array)\n     .execute();\n// query参数为 a[]=1&a[]=2&a[]=3\n\n// 添加数组到query参数 (可变参数)\nforest.get("/")\n     .addarrayquery("a", 1, 2, 3)\n     .execute();\n// query参数为 a[]=1&a[]=2&a[]=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# json参数\n\n如果不想以url参数的标准格式传递列表，json字符串也是一种选择\n\naddjsonquery(string name, object value) 添加 json query 参数\n\n * 参数name: query参数名\n * 参数value: query参数值，将被序列化为json字符串\n\n// 添加列表到query数组参数\nforest.get("/")\n     .addjsonquery("a", arrays.aslist(1, 2, 3))\n     .execute();\n// query参数为 a=[1,2,3]\n// 注意：这里的json数据最终会被 urlencode\n// 所以最终请求的参数为 a=%5b1%2c2%2c3%5d\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 获取参数\n\n获取请求的整个 query 参数表\n\ngetquery() 获取请求的query参数表\n\n * 返回值: query参数表，forestquerymap 类实例\n\n// 构建请求\n// query 参数为 a=1&b=2&b=3\nforestrequest<?> request = forest.get("/")\n        .addquery("a", 1)\n        .addquery("b", 2)\n        .addquery("b", 3);\n// 获取 query 参数表\nforestquerymap queries = request.getquery();\n// 返回参数为 a=1 的 forestqueryparameter 对象\nforestqueryparameter param1 = queries.getquery("a");\n// 返回包含 b=2和b=3 的 forestqueryparameter 对象列表\nlist<forestqueryparameter> params = queries.getqueries("b"); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n获取单个 query 参数\n\ngetquery(string name) 根据名称获取请求的query参数值\n\n * 参数name: query参数名称\n * 返回值: query参数值\n\n// 构建请求\n// query 参数为 a=1&b=2&b=3\nforestrequest<?> request = forest.get("/")\n        .addquery("a", 1)\n        .addquery("b", 2);\n\nrequest.getquery("a"); // 获取 1\nrequest.getquery("b"); // 获取 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n获取整个请求的 query 参数字符串\n\ngetquerystring() 获取请求的url query参数字符串\n\n * 返回值: query参数字符串\n\n// 构建请求\n// query 参数为 a=1&b=2&b=3\nforestrequest<?> request = forest.get("/")\n        .addquery("a", 1)\n        .addquery("b", 2)\n        .addquery("c", 3);\n\nrequest.getquerystring(); // 获取 a=1&b=2&c=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/07/21, 00:37:03",lastUpdatedTimestamp:1658335023e3},{title:"🚅 请求头",frontmatter:{title:"🚅 请求头",date:"2022-07-14T12:39:52.000Z",permalink:"/pages/1.5.x/api_request_header/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/008.api_request_header.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/008.api_request_header.md",key:"v-4be650fe",path:"/pages/1.5.x/api_request_header/",headers:[{level:2,title:"特殊请求头",slug:"特殊请求头",normalizedTitle:"特殊请求头",charIndex:1895}],headersStr:"特殊请求头",content:'一个HTTP请求由请求行、请求头、请求体三部分组成。其中，请求头是HTTP请求的重要组成部分，经常用于传递和服务端通讯的控制参数、数据格式、请求编码等重要信息。\n\n请求头由零到多个头属性构成，而一个头属性通常是一个键值对。\n\nForestRequest 对象提供了添加和修改请求头的方法\n\n> addHeader(String name, Object value) 添加请求头\n> \n>  * 参数 name: 请求头名称\n> \n>  * 参数 value: 请求头的值\n\n// addHeader方法第一个参数为头属性名称，第二个参数为头属性的值\n// 添加头属性 Content-Type，值为 application/json\nrequest.addHeader("Content-Type", "application/json");\n\n\n1\n2\n3\n\n\n一个请求可以添加多个头属性\n\nrequest.addHeader("Accept", "text/plain")              // 添加第一个头属性\n       .addHeader("Content-Type", "application/json")  // 添加第二个头属性\n       .addHeader("AccessToken", "foobar");            // 添加第三个头属性\n\n// 最终请求包含以下头属性：\n// Accept: text/plain\n// Content-Type: application/json\n// AccessToken: foobar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n修改和覆盖一个已存在的头属性\n\nrequest.addHeader("User-Agent", "httpclient") // 添加第一个头属性\n       .addHeader("User-Agent", "forest");    // 覆盖第一个头属性\n// 最终请求包含以下头属性：\n// User-Agent: forest\n\n\n1\n2\n3\n4\n\n\n获取请求头\n\n> header(String name) 根据请求头名称获取请求头\n> \n>  * 参数 name: 请求头名称\n>  * 返回值: 请求头，ForestHeader 类实例\n> \n> headers() 获取所有请求头\n> \n>  * 返回值: 请求头表, ForestHeaderMap 类实例\n\n// 创建新的请求对象\n// url: http://localhost/test\nForestRequest<?> request = Forest.get("/")\n        .addHeader("Accept", "text/plain")              // 添加第一个头属性\n        .addHeader("Content-Type", "application/json")  // 添加第二个头属性\n        \n// 通过 header 方法可以根据头属性名获取请求头对象\n// 并返回 ForestHeader 类的对象        \nForestHeader header1 = request.header("Accept");        // 获取头属性 Accept\nForestHeader header2 = request.header("Content-Type");  // 获取头属性 Content-Type\n// 通过 headers 方法可以获取该请求的所有请求头信息\n// 并返回 ForestHeaderMap 类对象\nForestHeaderMap headerMap = request.headers();          // 获取请求的所有请求头\n// 通过 headerValue 方法可以根据头属性名获取请求头的属性值\n// 并返回属性值字符串\nString headerValue1 = request.headerValue("Accept");          // 获取头属性 Accept 的属性值\nString headerValue2 = request.headerValue("Content-Type");    // 获取头属性 Accept 的属性值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 特殊请求头\n\nForest为一些特殊头属性定义专有的方法，不用在 addHeader 方法中传入头属性名了，比如: Content-Type\n\n> contentType(String contentType) 设置请求头 Content-Type 的值\n> \n>  * 参数 contentType: 请求头 Content-Type 的值\n\n// 设置头属性 Content-Type 的值为 application/json\nrequest.contentType("application/json");\n\n\n1\n2\n\n\nForest也为 Content-Type 常用属性值的设置提供了快捷方法\n\n// 设置头属性 Content-Type: application/x-www-form-urlencoded\nrequest.contentFormUrlEncoded();\n// 设置头属性 Content-Type: application/json\nrequest.contentTypeJson();\n// 设置头属性 Content-Type: application/xml\nrequest.contentTypeXml();\n// 设置头属性 Content-Type: multipart/form-data\nrequest.contentTypeMultipartFormData();\n// 设置头属性 Content-Type: application/octet-stream\nrequest.contentTypeOctetStream();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'一个http请求由请求行、请求头、请求体三部分组成。其中，请求头是http请求的重要组成部分，经常用于传递和服务端通讯的控制参数、数据格式、请求编码等重要信息。\n\n请求头由零到多个头属性构成，而一个头属性通常是一个键值对。\n\nforestrequest 对象提供了添加和修改请求头的方法\n\n> addheader(string name, object value) 添加请求头\n> \n>  * 参数 name: 请求头名称\n> \n>  * 参数 value: 请求头的值\n\n// addheader方法第一个参数为头属性名称，第二个参数为头属性的值\n// 添加头属性 content-type，值为 application/json\nrequest.addheader("content-type", "application/json");\n\n\n1\n2\n3\n\n\n一个请求可以添加多个头属性\n\nrequest.addheader("accept", "text/plain")              // 添加第一个头属性\n       .addheader("content-type", "application/json")  // 添加第二个头属性\n       .addheader("accesstoken", "foobar");            // 添加第三个头属性\n\n// 最终请求包含以下头属性：\n// accept: text/plain\n// content-type: application/json\n// accesstoken: foobar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n修改和覆盖一个已存在的头属性\n\nrequest.addheader("user-agent", "httpclient") // 添加第一个头属性\n       .addheader("user-agent", "forest");    // 覆盖第一个头属性\n// 最终请求包含以下头属性：\n// user-agent: forest\n\n\n1\n2\n3\n4\n\n\n获取请求头\n\n> header(string name) 根据请求头名称获取请求头\n> \n>  * 参数 name: 请求头名称\n>  * 返回值: 请求头，forestheader 类实例\n> \n> headers() 获取所有请求头\n> \n>  * 返回值: 请求头表, forestheadermap 类实例\n\n// 创建新的请求对象\n// url: http://localhost/test\nforestrequest<?> request = forest.get("/")\n        .addheader("accept", "text/plain")              // 添加第一个头属性\n        .addheader("content-type", "application/json")  // 添加第二个头属性\n        \n// 通过 header 方法可以根据头属性名获取请求头对象\n// 并返回 forestheader 类的对象        \nforestheader header1 = request.header("accept");        // 获取头属性 accept\nforestheader header2 = request.header("content-type");  // 获取头属性 content-type\n// 通过 headers 方法可以获取该请求的所有请求头信息\n// 并返回 forestheadermap 类对象\nforestheadermap headermap = request.headers();          // 获取请求的所有请求头\n// 通过 headervalue 方法可以根据头属性名获取请求头的属性值\n// 并返回属性值字符串\nstring headervalue1 = request.headervalue("accept");          // 获取头属性 accept 的属性值\nstring headervalue2 = request.headervalue("content-type");    // 获取头属性 accept 的属性值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 特殊请求头\n\nforest为一些特殊头属性定义专有的方法，不用在 addheader 方法中传入头属性名了，比如: content-type\n\n> contenttype(string contenttype) 设置请求头 content-type 的值\n> \n>  * 参数 contenttype: 请求头 content-type 的值\n\n// 设置头属性 content-type 的值为 application/json\nrequest.contenttype("application/json");\n\n\n1\n2\n\n\nforest也为 content-type 常用属性值的设置提供了快捷方法\n\n// 设置头属性 content-type: application/x-www-form-urlencoded\nrequest.contentformurlencoded();\n// 设置头属性 content-type: application/json\nrequest.contenttypejson();\n// 设置头属性 content-type: application/xml\nrequest.contenttypexml();\n// 设置头属性 content-type: multipart/form-data\nrequest.contenttypemultipartformdata();\n// 设置头属性 content-type: application/octet-stream\nrequest.contenttypeoctetstream();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"⚓ 回调函数",frontmatter:{title:"⚓ 回调函数",date:"2022-07-14T12:42:45.000Z",permalink:"/pages/1.5.x/api_callback/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/011.api_callback.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/011.api_callback.md",key:"v-24a2f37e",path:"/pages/1.5.x/api_callback/",headersStr:null,content:'ForestRequest 提供了众多回调函数设置的方法\n\n请求成功/失败回调函数\n\n> onSuccess(OnSuccess onSuccess) 设置成功回调函数: 请求成功时被调用\n> \n>  * 参数onSuccess: OnSuccess 接口实例\n> \n> onError(OnError onError) 设置失败回调函数: 请求失败时被调用\n> \n>  * 参数onError: OnError 接口实例\n\nForest.post("/")\n     // onSuccess回调函数: 请求成功时被调用\n    .onSuccess(((data, req, res) -> {\n        // data 为响应成功后返回的反序列化过的数据\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // res 为Forest响应对象，即 ForestResponse 类实例\n    }))\n     // onError回调函数: 请求失败时被调用\n    .onError(((ex, req, res) -> {\n        // ex 为请求过程可能抛出的异常对象\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // res 为Forest响应对象，即 ForestResponse 类实例\n    }))\n    // 执行请求，请求成功则执行onSuccess, 失败则执行onError\n    .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n请求重试回调函数\n\n> onRetry(OnRetry onRetry) 设置重试回调函数: 请求重试时被调用\n> \n>  * 参数onRetry: OnRetry 接口实例\n\nForest.post("/")\n     // 设置最大请求重试次数为 3\n    .maxRetryCount(3)\n     // onRetry回调函数: 每次请求重试前被调用\n    .onRetry(((req, res) -> {\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // res 为Forest响应对象，即 ForestResponse 类实例\n    }))\n    // 执行请求，请求失败会触发 onRetry, 然后重发请求\n    .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'forestrequest 提供了众多回调函数设置的方法\n\n请求成功/失败回调函数\n\n> onsuccess(onsuccess onsuccess) 设置成功回调函数: 请求成功时被调用\n> \n>  * 参数onsuccess: onsuccess 接口实例\n> \n> onerror(onerror onerror) 设置失败回调函数: 请求失败时被调用\n> \n>  * 参数onerror: onerror 接口实例\n\nforest.post("/")\n     // onsuccess回调函数: 请求成功时被调用\n    .onsuccess(((data, req, res) -> {\n        // data 为响应成功后返回的反序列化过的数据\n        // req 为forest请求对象，即 forestrequest 类实例\n        // res 为forest响应对象，即 forestresponse 类实例\n    }))\n     // onerror回调函数: 请求失败时被调用\n    .onerror(((ex, req, res) -> {\n        // ex 为请求过程可能抛出的异常对象\n        // req 为forest请求对象，即 forestrequest 类实例\n        // res 为forest响应对象，即 forestresponse 类实例\n    }))\n    // 执行请求，请求成功则执行onsuccess, 失败则执行onerror\n    .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n请求重试回调函数\n\n> onretry(onretry onretry) 设置重试回调函数: 请求重试时被调用\n> \n>  * 参数onretry: onretry 接口实例\n\nforest.post("/")\n     // 设置最大请求重试次数为 3\n    .maxretrycount(3)\n     // onretry回调函数: 每次请求重试前被调用\n    .onretry(((req, res) -> {\n        // req 为forest请求对象，即 forestrequest 类实例\n        // res 为forest响应对象，即 forestresponse 类实例\n    }))\n    // 执行请求，请求失败会触发 onretry, 然后重发请求\n    .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🚋 请求体",frontmatter:{title:"🚋 请求体",date:"2022-07-14T12:40:43.000Z",permalink:"/pages/1.5.x/api_request_body/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/009.api_request_body.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/009.api_request_body.md",key:"v-77bf47fe",path:"/pages/1.5.x/api_request_body/",headers:[{level:2,title:"表单数据",slug:"表单数据",normalizedTitle:"表单数据",charIndex:777},{level:2,title:"JSON数据",slug:"json数据",normalizedTitle:"json数据",charIndex:2356},{level:2,title:"XML数据",slug:"xml数据",normalizedTitle:"xml数据",charIndex:4545},{level:2,title:"文件",slug:"文件",normalizedTitle:"文件",charIndex:5835},{level:2,title:"Multipart",slug:"multipart",normalizedTitle:"multipart",charIndex:6364}],headersStr:"表单数据 JSON数据 XML数据 文件 Multipart",content:'ForestRequest 对象提供的添加/修改请求体数据项的方法\n\n> addBody(String bodyString) 添加字符串Body数据项\n\nrequest.addBody("xxxx")   // 添加字符串请求体 xxxx\n       .addBody("yyyy");  // 添加字符串请求体 yyyy\n// 最终请求体为:\n// xxxxyyyy\n\n\n1\n2\n3\n4\n\n\n> addBody(String name, Object value) 添加键值对形式的Body数据项\n\nrequest.addBody("a", 1)  // 添加请求体数据项，键值对: a, 1\n       .addBody("b", 2); // 添加请求体数据项，键值对: b, 2\n\n\n1\n2\n\n\n现在 ForestRequest 对象中有了两个请求体数据项，风别是键值对<a, 1> 和 <b, 2> 至于它们最终以什么数据格式发送，取决于请求头中的 Content-Type 的值\n\n> addBody(Object obj) 添加对象形式的Body数据项\n> \n>  * 参数 obj: 作为请求体数据的任意类型对象\n\n// 添加自定义类对象\nMyUserInfo userInfo = new MyUserInfo();\nuserInfo.setName("foo");\nrequest.addBody(userInfo);\n\n// 添加Map对象\nMap<String, Object> map = new HashMap<>();\nmap.put("name", "foo");\nmap.put("value", "bar");\nrequest.addBody(map);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 表单数据\n\n在调用 addBody 方法前，需要先指定 Content-Type 为 application/x-www-form-urlencoded\n\n插入键值对形式的表单数据\n\n// 创建表格格式请求体\n// 按键值对形式添加请求体数据项\nForest.post("/")\n    .contentFormUrlEncoded()  // 指定请求体为表单格式\n    .addBody("name", "foo")   // 添加Body键值对: name, foo\n    .addBody("value", "bar"); // 添加Body键值对: value, bar\n// 最终请求体数据为\n// name=foo&value=bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n插入Map形式的表单数据\n\n// 构建Map对象\nMap<String, Object> map = new HashMap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 创建表格格式请求体\n// 按Map形式添加请求体数据项\nForest.post("/")\n    .contentFormUrlEncoded() // 指定请求体为表单格式\n    .addBody(map);           // 添加Map对象到请求体中\n// 最终请求体数据为\n// name=foo&value=bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n插入自定义对象形式的表单数据\n\n// 用自定义的 MyUserInfo 类对象\nMyUserInfo user = new MyUserInfo();\nuser.setUsername("Jack");\nuser.setAge(20);\n// 创建表格格式请求体\n// 按自定义对象形式添加请求体数据项\nForest.post("/")\n    .contentFormUrlEncoded()  // 指定请求体为表单格式\n    .addBody(user);           // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// username=Jack&age=20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n混合使用多种形式\n\n// 构建Map对象\nMap<String, Object> map = new HashMap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 构建自定义类对象\nMyUserInfo user = new MyUserInfo();\nuser.setUsername("Jack");\nuser.setAge(20);\n// 创建表格格式请求体\n// 按自定义对象形式添加请求体数据项\nForest.post("/")\n    .contentFormUrlEncoded() // 指定请求体为表单格式\n    .addBody("a", 1)         // 添加Body键值对: a, 1\n    .addBody("b", 2)         // 添加Body键值对: b, 2\n    .addBody(map)            // 添加Map对象到请求体中\n    .addBody(user);          // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// a=1&b=2&name=foo&value=bar&username=Jack&age=20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# JSON数据\n\n在调用 addBody 方法前，需要先指定 Content-Type 为 application/json 或其他json字符串结尾的 Content-Type 值\n\n插入键值对形式的JSON数据\n\n// 创建JSON格式请求体\n// 按键值对形式添加请求体数据项\nForest.post("/")\n    .contentTypeJson()        // 指定请求体为JSON格式\n    .addBody("name", "foo")   // 添加Body键值对: name, foo\n    .addBody("value", "bar"); // 添加Body键值对: value, bar\n// 最终请求体数据为\n// {"name": "foo", "value": "bar"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n插入Map或List形式的表单数据\n\n// 构建Map对象\nMap<String, Object> map = new HashMap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 创建JSON格式请求体\n// 按Map形式添加请求体数据项\nForest.post("/")\n    .contentTypeJson() // 指定请求体为JSON格式\n    .addBody(map);     // 添加Map对象到请求体中\n// 最终请求体数据为\n// {"name": "foo", "value": "bar"}\n\n// 构建List对象\nList<Integer> list = new ArrayList();\nvalue.add(1);\nvalue.add(2);\nvalue.add(3);\n// 创建JSON格式请求体\n// 按Map形式添加请求体数据项\nForest.post("/")\n    .contentTypeJson() // 指定请求体为JSON格式\n    .addBody(list);    // 添加List对象到请求体中\n// 最终请求体数据为\n// [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n插入自定义对象形式的表单数据\n\n// 构建自定义类对象\nMyUserInfo user = new MyUserInfo();\nuser.setUsername("Jack");\nuser.setAge(20);\n// 创建JSON格式请求体\n// 按自定义对象形式添加请求体数据项\nForest.post("/")\n    .contentTypeJson()  // 指定请求体为JSON格式\n    .addBody(user);     // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// {"username": "Jack", "age", 20}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nJSON数据请求体，同样可以混合多种形式添加\n\n// 构建Map对象\nMap<String, Object> map = new HashMap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 构建自定义类对象\nMyUserInfo user = new MyUserInfo();\nuser.setUsername("Jack");\nuser.setAge(20);\n// 创建JSON格式请求体\n// 按自定义对象形式添加请求体数据项\nForest.post("/")\n    .contentTypeJson()  // 指定请求体为JSON格式\n    .addBody("a", 1)    // 添加Body键值对: a, 1\n    .addBody("b", 2)    // 添加Body键值对: b, 2\n    .addBody(map)       // 添加Map对象到请求体中\n    .addBody(user);     // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// {"a": 1, "b", 2, "name": "foo": "value", "bar": "username": "Jack&age": 20}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n最后，介绍一种最简单直白的添加JSON请求体的办法\n\n// 创建JSON格式请求体\n// 按字符串形式添加请求体数据项\nForest.post("/")\n     // 指定请求体为JSON格式\n    .contentTypeJson()\n     // 插入JSON字符串到请求体中\n    .addBody("{\\"name\\": \\"foo\\", \\"value\\": \\"bar\\"}")\n// 最终请求体数据为\n// {"name": "foo", "value": "bar"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# XML数据\n\n在调用 addBody 方法前，需要先指定 Content-Type 为 application/xml 或其他xml字符串结尾的 Content-Type 值\n\nForest仅支持用JAXB配合自定义类对象的形式添加XML格式请求体\n\n@XmlRootElement(name = "user")\npublic MyUserInfo {\n\n    private String usrname;\n\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在Body中插入 MyUserInfo 对象\n\n// 构建自定义类对象\nMyUserInfo user = new MyUserInfo();\nuser.setUsername("foo");\nuser.setPassword("bar");\n// 创建XML格式请求体\n// 按自定义对象形式添加请求体数据项\nForest.post("/")\n    .contentTypeXml()  // 指定请求体为JSON格式\n    .addBody(user);     // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// <user><username>foo</username><password>bar</password></user>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n同样，XML格式请求体也可以用字符串形式直接插入\n\n// 创建JSON格式请求体\n// 按字符串形式添加请求体数据项\nForest.post("/")\n     // 指定请求体为JSON格式\n    .contentTypeJson()\n     // 插入XML字符串到请求体中\n    .addBody("<user><username>foo</username><password>bar</password></user>")\n// 最终请求体数据为\n// <user><username>foo</username><password>bar</password></user>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 文件\n\n在调用 addBody 方法前，需要先指定 Content-Type 为 multipart/form-data\n\n然后调用 addFile 方法，添加文件数据\n\n添加 File 对象\n\n> addFile(String name, File file, String filename, String contentType) 添加文件 (接受File对象)\n> \n>  * 参数 name: 参数名称\n> \n>  * 参数 file: 文件, File 类型对象\n> \n>  * 参数 filename: 文件名, 期望上传的文件数据在服务端保存的文件名\n> \n>  * 参数 contentType: 文件数据的 Content-Type\n> \n> addFile(String name, File file, String filename) 添加文件 (接受File对象)\n> \n> addFile(String name, File file) 添加文件 (接受File对象)\n\n// 构建File对象\nFile file = new File(path);\nForest.post("/upload")\n      // 指定请求体为Multipart格式\n     .contentTypeMultipartFormData()\n      // 添加File对象\n     .addFile("file", file);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加输入流对象\n\n * addFile(String name, InputStream inputStream, String filename, String contentType) 添加文件 (接受输入流)\n\n> 参数 name: 参数名称\n> \n> 参数 inputStream: 文件输入流对象\n> \n> 参数 filename: 文件名, 期望上传的文件数据在服务端保存的文件名\n> \n> 参数 contentType: 文件数据的 Content-Type\n\n * addFile(String name, InputStream inputStream, String filename) 添加文件 (接受输入流)\n\n// 构建InputStream对象\nFile file = new File(path);\nInputStream in = new FileInputStream(file);\nForest.post("/upload")\n      // 指定请求体为Multipart格式\n     .contentTypeMultipartFormData()\n      // 添加InputStream对象\n     .addFile("file", in, "test.jpg");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n添加字节数组\n\n> addFile(String name, byte[] bytes, String filename, String contentType) 添加文件 (接受字节数组)\n> \n>  * 参数 name: 参数名称\n>  * 参数 bytes: 文件字节数组\n>  * 参数 filename: 文件名, 期望上传的文件数据在服务端保存的文件名\n>  * 参数 contentType: 文件数据的 Content-Type\n> \n> addFile(String name, byte[] bytes, String filename) 添加文件 (接受字节数组)\n\n// 构建字节数组\nbyte[] byteArray = IOUtils.toByteArray(url);\nForest.post("/upload")\n      // 指定请求体为Multipart格式\n     .contentTypeMultipartFormData()\n      // 添加字节数组\n     .addFile("file", byteArray, "test.jpg");\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加多个文件\n\nForest.post("/upload")\n      // 指定请求体为Multipart格式\n     .contentTypeMultipartFormData()\n      // 添加File对象1\n     .addFile("file1", file1);\n      // 添加File对象2\n     .addFile("file2", file2);\n      // 添加File对象3\n     .addFile("file3", file3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Multipart\n\n在文件上传的时候，除了要添加文件外，通常也要传递一些普通参数\n\n只要在调用 addFile 方法后，再调用 addBody 方法即可\n\nForest.post("/upload")\n      // 指定请求体为Multipart格式\n     .contentTypeMultipartFormData()\n      // 添加File对象\n     .addFile("file", file)\n      // 添加 Multipart 参数1\n     .addBody("name", "foo")\n      // 添加 Multipart 参数2\n     .addBody("value", "bar");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n指定Multipart数据项的 Content-Type\n\n> addBody(String name, String contentType, Object value) 添加键值对形式Body数据\n> \n>  * 参数name: 字段名\n>  * 参数contentType: 该请求体数据项的Content-Type\n>  * 参数value: 字段值\n\nForest.post("/upload")\n      // 指定请求体为Multipart格式\n     .contentTypeMultipartFormData()\n      // 添加File对象\n     .addFile("file", file)\n      // 添加 Multipart 参数1，Content-Type 为  text/plian\n     .addBody("name", "text/plian", "foo")\n      // 添加 Multipart 参数2，Content-Type 为  text/plian;charset=utf-8\n     .addBody("value", "text/plian;charset=utf-8", "bar");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'forestrequest 对象提供的添加/修改请求体数据项的方法\n\n> addbody(string bodystring) 添加字符串body数据项\n\nrequest.addbody("xxxx")   // 添加字符串请求体 xxxx\n       .addbody("yyyy");  // 添加字符串请求体 yyyy\n// 最终请求体为:\n// xxxxyyyy\n\n\n1\n2\n3\n4\n\n\n> addbody(string name, object value) 添加键值对形式的body数据项\n\nrequest.addbody("a", 1)  // 添加请求体数据项，键值对: a, 1\n       .addbody("b", 2); // 添加请求体数据项，键值对: b, 2\n\n\n1\n2\n\n\n现在 forestrequest 对象中有了两个请求体数据项，风别是键值对<a, 1> 和 <b, 2> 至于它们最终以什么数据格式发送，取决于请求头中的 content-type 的值\n\n> addbody(object obj) 添加对象形式的body数据项\n> \n>  * 参数 obj: 作为请求体数据的任意类型对象\n\n// 添加自定义类对象\nmyuserinfo userinfo = new myuserinfo();\nuserinfo.setname("foo");\nrequest.addbody(userinfo);\n\n// 添加map对象\nmap<string, object> map = new hashmap<>();\nmap.put("name", "foo");\nmap.put("value", "bar");\nrequest.addbody(map);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 表单数据\n\n在调用 addbody 方法前，需要先指定 content-type 为 application/x-www-form-urlencoded\n\n插入键值对形式的表单数据\n\n// 创建表格格式请求体\n// 按键值对形式添加请求体数据项\nforest.post("/")\n    .contentformurlencoded()  // 指定请求体为表单格式\n    .addbody("name", "foo")   // 添加body键值对: name, foo\n    .addbody("value", "bar"); // 添加body键值对: value, bar\n// 最终请求体数据为\n// name=foo&value=bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n插入map形式的表单数据\n\n// 构建map对象\nmap<string, object> map = new hashmap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 创建表格格式请求体\n// 按map形式添加请求体数据项\nforest.post("/")\n    .contentformurlencoded() // 指定请求体为表单格式\n    .addbody(map);           // 添加map对象到请求体中\n// 最终请求体数据为\n// name=foo&value=bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n插入自定义对象形式的表单数据\n\n// 用自定义的 myuserinfo 类对象\nmyuserinfo user = new myuserinfo();\nuser.setusername("jack");\nuser.setage(20);\n// 创建表格格式请求体\n// 按自定义对象形式添加请求体数据项\nforest.post("/")\n    .contentformurlencoded()  // 指定请求体为表单格式\n    .addbody(user);           // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// username=jack&age=20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n混合使用多种形式\n\n// 构建map对象\nmap<string, object> map = new hashmap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 构建自定义类对象\nmyuserinfo user = new myuserinfo();\nuser.setusername("jack");\nuser.setage(20);\n// 创建表格格式请求体\n// 按自定义对象形式添加请求体数据项\nforest.post("/")\n    .contentformurlencoded() // 指定请求体为表单格式\n    .addbody("a", 1)         // 添加body键值对: a, 1\n    .addbody("b", 2)         // 添加body键值对: b, 2\n    .addbody(map)            // 添加map对象到请求体中\n    .addbody(user);          // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// a=1&b=2&name=foo&value=bar&username=jack&age=20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# json数据\n\n在调用 addbody 方法前，需要先指定 content-type 为 application/json 或其他json字符串结尾的 content-type 值\n\n插入键值对形式的json数据\n\n// 创建json格式请求体\n// 按键值对形式添加请求体数据项\nforest.post("/")\n    .contenttypejson()        // 指定请求体为json格式\n    .addbody("name", "foo")   // 添加body键值对: name, foo\n    .addbody("value", "bar"); // 添加body键值对: value, bar\n// 最终请求体数据为\n// {"name": "foo", "value": "bar"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n插入map或list形式的表单数据\n\n// 构建map对象\nmap<string, object> map = new hashmap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 创建json格式请求体\n// 按map形式添加请求体数据项\nforest.post("/")\n    .contenttypejson() // 指定请求体为json格式\n    .addbody(map);     // 添加map对象到请求体中\n// 最终请求体数据为\n// {"name": "foo", "value": "bar"}\n\n// 构建list对象\nlist<integer> list = new arraylist();\nvalue.add(1);\nvalue.add(2);\nvalue.add(3);\n// 创建json格式请求体\n// 按map形式添加请求体数据项\nforest.post("/")\n    .contenttypejson() // 指定请求体为json格式\n    .addbody(list);    // 添加list对象到请求体中\n// 最终请求体数据为\n// [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n插入自定义对象形式的表单数据\n\n// 构建自定义类对象\nmyuserinfo user = new myuserinfo();\nuser.setusername("jack");\nuser.setage(20);\n// 创建json格式请求体\n// 按自定义对象形式添加请求体数据项\nforest.post("/")\n    .contenttypejson()  // 指定请求体为json格式\n    .addbody(user);     // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// {"username": "jack", "age", 20}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\njson数据请求体，同样可以混合多种形式添加\n\n// 构建map对象\nmap<string, object> map = new hashmap();\nmap.put("name", "foo");\nmap.put("value" "bar");\n// 构建自定义类对象\nmyuserinfo user = new myuserinfo();\nuser.setusername("jack");\nuser.setage(20);\n// 创建json格式请求体\n// 按自定义对象形式添加请求体数据项\nforest.post("/")\n    .contenttypejson()  // 指定请求体为json格式\n    .addbody("a", 1)    // 添加body键值对: a, 1\n    .addbody("b", 2)    // 添加body键值对: b, 2\n    .addbody(map)       // 添加map对象到请求体中\n    .addbody(user);     // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// {"a": 1, "b", 2, "name": "foo": "value", "bar": "username": "jack&age": 20}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n最后，介绍一种最简单直白的添加json请求体的办法\n\n// 创建json格式请求体\n// 按字符串形式添加请求体数据项\nforest.post("/")\n     // 指定请求体为json格式\n    .contenttypejson()\n     // 插入json字符串到请求体中\n    .addbody("{\\"name\\": \\"foo\\", \\"value\\": \\"bar\\"}")\n// 最终请求体数据为\n// {"name": "foo", "value": "bar"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# xml数据\n\n在调用 addbody 方法前，需要先指定 content-type 为 application/xml 或其他xml字符串结尾的 content-type 值\n\nforest仅支持用jaxb配合自定义类对象的形式添加xml格式请求体\n\n@xmlrootelement(name = "user")\npublic myuserinfo {\n\n    private string usrname;\n\n    private string password;\n\n    public string getusername() {\n        return username;\n    }\n\n    public void setusername(string username) {\n        this.username = username;\n    }\n\n    public string getpassword() {\n        return password;\n    }\n\n    public void setpassword(string password) {\n        this.password = password;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在body中插入 myuserinfo 对象\n\n// 构建自定义类对象\nmyuserinfo user = new myuserinfo();\nuser.setusername("foo");\nuser.setpassword("bar");\n// 创建xml格式请求体\n// 按自定义对象形式添加请求体数据项\nforest.post("/")\n    .contenttypexml()  // 指定请求体为json格式\n    .addbody(user);     // 添加自定义类对象到请求体中\n// 最终请求体数据为\n// <user><username>foo</username><password>bar</password></user>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n同样，xml格式请求体也可以用字符串形式直接插入\n\n// 创建json格式请求体\n// 按字符串形式添加请求体数据项\nforest.post("/")\n     // 指定请求体为json格式\n    .contenttypejson()\n     // 插入xml字符串到请求体中\n    .addbody("<user><username>foo</username><password>bar</password></user>")\n// 最终请求体数据为\n// <user><username>foo</username><password>bar</password></user>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 文件\n\n在调用 addbody 方法前，需要先指定 content-type 为 multipart/form-data\n\n然后调用 addfile 方法，添加文件数据\n\n添加 file 对象\n\n> addfile(string name, file file, string filename, string contenttype) 添加文件 (接受file对象)\n> \n>  * 参数 name: 参数名称\n> \n>  * 参数 file: 文件, file 类型对象\n> \n>  * 参数 filename: 文件名, 期望上传的文件数据在服务端保存的文件名\n> \n>  * 参数 contenttype: 文件数据的 content-type\n> \n> addfile(string name, file file, string filename) 添加文件 (接受file对象)\n> \n> addfile(string name, file file) 添加文件 (接受file对象)\n\n// 构建file对象\nfile file = new file(path);\nforest.post("/upload")\n      // 指定请求体为multipart格式\n     .contenttypemultipartformdata()\n      // 添加file对象\n     .addfile("file", file);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加输入流对象\n\n * addfile(string name, inputstream inputstream, string filename, string contenttype) 添加文件 (接受输入流)\n\n> 参数 name: 参数名称\n> \n> 参数 inputstream: 文件输入流对象\n> \n> 参数 filename: 文件名, 期望上传的文件数据在服务端保存的文件名\n> \n> 参数 contenttype: 文件数据的 content-type\n\n * addfile(string name, inputstream inputstream, string filename) 添加文件 (接受输入流)\n\n// 构建inputstream对象\nfile file = new file(path);\ninputstream in = new fileinputstream(file);\nforest.post("/upload")\n      // 指定请求体为multipart格式\n     .contenttypemultipartformdata()\n      // 添加inputstream对象\n     .addfile("file", in, "test.jpg");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n添加字节数组\n\n> addfile(string name, byte[] bytes, string filename, string contenttype) 添加文件 (接受字节数组)\n> \n>  * 参数 name: 参数名称\n>  * 参数 bytes: 文件字节数组\n>  * 参数 filename: 文件名, 期望上传的文件数据在服务端保存的文件名\n>  * 参数 contenttype: 文件数据的 content-type\n> \n> addfile(string name, byte[] bytes, string filename) 添加文件 (接受字节数组)\n\n// 构建字节数组\nbyte[] bytearray = ioutils.tobytearray(url);\nforest.post("/upload")\n      // 指定请求体为multipart格式\n     .contenttypemultipartformdata()\n      // 添加字节数组\n     .addfile("file", bytearray, "test.jpg");\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加多个文件\n\nforest.post("/upload")\n      // 指定请求体为multipart格式\n     .contenttypemultipartformdata()\n      // 添加file对象1\n     .addfile("file1", file1);\n      // 添加file对象2\n     .addfile("file2", file2);\n      // 添加file对象3\n     .addfile("file3", file3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# multipart\n\n在文件上传的时候，除了要添加文件外，通常也要传递一些普通参数\n\n只要在调用 addfile 方法后，再调用 addbody 方法即可\n\nforest.post("/upload")\n      // 指定请求体为multipart格式\n     .contenttypemultipartformdata()\n      // 添加file对象\n     .addfile("file", file)\n      // 添加 multipart 参数1\n     .addbody("name", "foo")\n      // 添加 multipart 参数2\n     .addbody("value", "bar");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n指定multipart数据项的 content-type\n\n> addbody(string name, string contenttype, object value) 添加键值对形式body数据\n> \n>  * 参数name: 字段名\n>  * 参数contenttype: 该请求体数据项的content-type\n>  * 参数value: 字段值\n\nforest.post("/upload")\n      // 指定请求体为multipart格式\n     .contenttypemultipartformdata()\n      // 添加file对象\n     .addfile("file", file)\n      // 添加 multipart 参数1，content-type 为  text/plian\n     .addbody("name", "text/plian", "foo")\n      // 添加 multipart 参数2，content-type 为  text/plian;charset=utf-8\n     .addbody("value", "text/plian;charset=utf-8", "bar");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🍜 成功/失败条件",frontmatter:{title:"🍜 成功/失败条件",date:"2022-07-14T12:43:44.000Z",permalink:"/pages/1.5.x/api_success/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/013.api_success.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/013.api_success.md",key:"v-bc96cdbc",path:"/pages/1.5.x/api_success/",headersStr:null,content:'Forest 请求每次发送后都会判断是否成功 (不成功即失败)\n\n默认的请求成功条件如下\n\n[x] 没有异常: 包括网络连接不通、IO错误、超时等异常\n\n[x] 响应状态码在正常范围内: >= 100 并且 < 400\n\n一般成功的状态码为200, 所以默认成功条件满足绝大多数场景，但也免不了有些API接口不以此为标准，比如400也为正常状态码; 还有状态码为 200, 但返回JSON数据中的状态为失败也为失败。\n\n为适应这种，Forest 提供了可自定义的成功/失败条件\n\n> successWhen(SuccessWhen successWhen) 设置成功条件: 用于判断请求是否成功/失败\n> \n>  * 参数successWhen: SuccessWhen 接口实现类实例\n\nForest.post("/")\n     // 设置成功/失败条件\n     // 返回 true 为成功，false 为失败\n    .successWhen(((req, res) -> {\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // res 为Forest响应对象，即 ForestResponse 类实例\n        return res.noException() &&   // 请求过程没有异常\n                res.statusOk() &&     // 状态码在 100 ~ 399 范围内\n                res.statusIsNot(203); // 但不能是 203\n    }))\n    .onError((ex, req, res) -> {\n        System.out.println("失败!");\n    })\n    .exeute();\n// 若服务端返回的状态码为 203， \n// 即便请求过程都成功，\n// 也会被认为是失败，并执行 onError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用自定义成功/失败条件实现类\n\n> setSuccessWhen(Class<? extends SuccessWhen> conditionClass) 设置成功条件，用于判断请求是否成功/失败\n> \n>  * 参数conditionClass: SuccessWhen 实现类的 Class 对象\n\n先定义成功/失败条件实现类\n\n// 自定义成功/失败条件实现类\n// 需要实现 SuccessWhen 接口\npublic class MySuccessCondition implements SuccessWhen {\n\n    /**\n     * 请求成功条件\n     * @param req Forest请求对象\n     * @param res Forest响应对象\n     * @return true 请求成功，false 请求失败\n     */\n    @Override\n    public boolean successWhen(ForestRequest req, ForestResponse res) {\n        return res.noException() &&   // 请求过程没有异常\n                res.statusOk() &&     // 状态码在 100 ~ 399 范围内\n                res.statusIsNot(203); // 但不能是 203\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n通过 Forest 请求对象的setSuccessWhen(Class<? extends SuccessWhen> conditionClass)方法设置该条件类\n\nForest.post("/")\n     // 设置成功/失败条件实现类\n    .successWhen(MySuccessCondition.class)\n    .onError((ex, req, res) -> {\n        System.out.println("失败!");\n    })\n    .exeute();\n// 若服务端返回的状态码为 203， \n// 即便请求过程都成功，\n// 也会被认为是失败，并执行 onError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'forest 请求每次发送后都会判断是否成功 (不成功即失败)\n\n默认的请求成功条件如下\n\n[x] 没有异常: 包括网络连接不通、io错误、超时等异常\n\n[x] 响应状态码在正常范围内: >= 100 并且 < 400\n\n一般成功的状态码为200, 所以默认成功条件满足绝大多数场景，但也免不了有些api接口不以此为标准，比如400也为正常状态码; 还有状态码为 200, 但返回json数据中的状态为失败也为失败。\n\n为适应这种，forest 提供了可自定义的成功/失败条件\n\n> successwhen(successwhen successwhen) 设置成功条件: 用于判断请求是否成功/失败\n> \n>  * 参数successwhen: successwhen 接口实现类实例\n\nforest.post("/")\n     // 设置成功/失败条件\n     // 返回 true 为成功，false 为失败\n    .successwhen(((req, res) -> {\n        // req 为forest请求对象，即 forestrequest 类实例\n        // res 为forest响应对象，即 forestresponse 类实例\n        return res.noexception() &&   // 请求过程没有异常\n                res.statusok() &&     // 状态码在 100 ~ 399 范围内\n                res.statusisnot(203); // 但不能是 203\n    }))\n    .onerror((ex, req, res) -> {\n        system.out.println("失败!");\n    })\n    .exeute();\n// 若服务端返回的状态码为 203， \n// 即便请求过程都成功，\n// 也会被认为是失败，并执行 onerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用自定义成功/失败条件实现类\n\n> setsuccesswhen(class<? extends successwhen> conditionclass) 设置成功条件，用于判断请求是否成功/失败\n> \n>  * 参数conditionclass: successwhen 实现类的 class 对象\n\n先定义成功/失败条件实现类\n\n// 自定义成功/失败条件实现类\n// 需要实现 successwhen 接口\npublic class mysuccesscondition implements successwhen {\n\n    /**\n     * 请求成功条件\n     * @param req forest请求对象\n     * @param res forest响应对象\n     * @return true 请求成功，false 请求失败\n     */\n    @override\n    public boolean successwhen(forestrequest req, forestresponse res) {\n        return res.noexception() &&   // 请求过程没有异常\n                res.statusok() &&     // 状态码在 100 ~ 399 范围内\n                res.statusisnot(203); // 但不能是 203\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n通过 forest 请求对象的setsuccesswhen(class<? extends successwhen> conditionclass)方法设置该条件类\n\nforest.post("/")\n     // 设置成功/失败条件实现类\n    .successwhen(mysuccesscondition.class)\n    .onerror((ex, req, res) -> {\n        system.out.println("失败!");\n    })\n    .exeute();\n// 若服务端返回的状态码为 203， \n// 即便请求过程都成功，\n// 也会被认为是失败，并执行 onerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🚁 同步/异步",frontmatter:{title:"🚁 同步/异步",date:"2022-07-14T12:42:18.000Z",permalink:"/pages/1.5.x/api_request_async/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/010.api_request_async.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/010.api_request_async.md",key:"v-46b082d4",path:"/pages/1.5.x/api_request_async/",headersStr:null,content:'Forest请求默认为同步的，可以通过async()方法设置为异步请求\n\n> setAsync(boolean async) 设置是否异步\n> \n>  * 参数aysnc: true 异步, false 同步\n> \n> sync() 设置为同步\n> \n> async() 设置为异步\n\n// 构建同步 Get 请求\nForest.get("/");\n// 构建异步 Get 请求\nForest.get("/").async();\n// 构建同步 Get 请求\nForest.get("/").sync();\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'forest请求默认为同步的，可以通过async()方法设置为异步请求\n\n> setasync(boolean async) 设置是否异步\n> \n>  * 参数aysnc: true 异步, false 同步\n> \n> sync() 设置为同步\n> \n> async() 设置为异步\n\n// 构建同步 get 请求\nforest.get("/");\n// 构建异步 get 请求\nforest.get("/").async();\n// 构建同步 get 请求\nforest.get("/").sync();\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"⛵ 重定向",frontmatter:{title:"⛵ 重定向",date:"2022-07-14T12:45:15.000Z",permalink:"/pages/1.5.x/api_redirection/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/015.api_redirection.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/015.api_redirection.md",key:"v-4365e2e8",path:"/pages/1.5.x/api_redirection/",headers:[{level:2,title:"自动重定向开关",slug:"自动重定向开关",normalizedTitle:"自动重定向开关",charIndex:475}],headersStr:"自动重定向开关",content:'Forest 在默认情况下会自动重定向，即服务端返回 301、302、307 等状态码时，会自动跳转到新的转移地址发送请求\n\n回调函数 onRedirection 可以帮助您在重定向地址转移请求发送前触发，以此获得以一次的Request和Response对象\n\n> onRedirection(OnRedirection onRedirection) 设置重定向回调函数: 在请求重定向时触发\n> \n>  * 参数onRedirection: OnRedirection 接口实例\n\nForest.get("/")\n    .onRedirection((redirectReq, prevReq, prevRes) -> {\n        // redirectReq: 重定向转移地址请求对象\n        // prevReq: 重定向转移前的请求对象\n        // prevRes: 重定向转移前获得的响应对象\n    })\n     // 执行请求\n    .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 自动重定向开关\n\n当然您也可以打开/关闭 Forest 请求的自动重定向\n\n> autoRedirects(boolean autoRedirects) 设置是否打开自动重定向\n> \n>  * 参数autoRedirects: true 打开自动重定向, false 禁止自动重定向\n\nForestResponse response = Forest.get("/")\n         // 关闭自动重定向 \n        .autoRedirects(false)\n         // 执行请求   \n        .execute(ForestResponse.class);\n// 最终这里的 response 将获取第一次请求的结果\n// 而不是自动重定向转移后的响应结果\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'forest 在默认情况下会自动重定向，即服务端返回 301、302、307 等状态码时，会自动跳转到新的转移地址发送请求\n\n回调函数 onredirection 可以帮助您在重定向地址转移请求发送前触发，以此获得以一次的request和response对象\n\n> onredirection(onredirection onredirection) 设置重定向回调函数: 在请求重定向时触发\n> \n>  * 参数onredirection: onredirection 接口实例\n\nforest.get("/")\n    .onredirection((redirectreq, prevreq, prevres) -> {\n        // redirectreq: 重定向转移地址请求对象\n        // prevreq: 重定向转移前的请求对象\n        // prevres: 重定向转移前获得的响应对象\n    })\n     // 执行请求\n    .execute();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 自动重定向开关\n\n当然您也可以打开/关闭 forest 请求的自动重定向\n\n> autoredirects(boolean autoredirects) 设置是否打开自动重定向\n> \n>  * 参数autoredirects: true 打开自动重定向, false 禁止自动重定向\n\nforestresponse response = forest.get("/")\n         // 关闭自动重定向 \n        .autoredirects(false)\n         // 执行请求   \n        .execute(forestresponse.class);\n// 最终这里的 response 将获取第一次请求的结果\n// 而不是自动重定向转移后的响应结果\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🌶️ 重试机制",frontmatter:{title:"🌶️ 重试机制",date:"2022-07-14T12:44:11.000Z",permalink:"/pages/1.5.x/api_retry/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/014.api_retry.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/014.api_retry.md",key:"v-52dfbad6",path:"/pages/1.5.x/api_retry/",headers:[{level:2,title:"重试器",slug:"重试器",normalizedTitle:"重试器",charIndex:610},{level:2,title:"重试条件",slug:"重试条件",normalizedTitle:"重试条件",charIndex:1589}],headersStr:"重试器 重试条件",content:'ForestRequest 对象提供了设置重试相关属性的方法\n\n是否运行重试 (默认为开启重试)\n\n> setRetryEnabled(boolean retryEnabled) 设置是否开启请求重试\n> \n>  * 参数retryEnabled: true 开启重试，false 关闭重试\n\n// 开启请求重试（默认即开启）\nrequest.setRetryEnabled(true);\n// 关闭请求重试（关闭后该请求不会再触发重试）\nrequest.setRetryEnabled(false);\n\n\n1\n2\n3\n4\n\n\n设置最大重试次数 (默认为0次，即不会重试)\n\n> maxRetryCount(int retryCount) 设置请求失败后的最大重试次数\n> \n>  * 参数retryCount: 重试次数\n\n// 设置请求最大重试次数为 3 次\nrequest.maxRetryCount(3);\n\n\n1\n2\n\n\n设置最大请重试的时间间隔 (时间单位为毫秒, 默认为0毫秒)\n\n> maxRetryInterval(long maxRetryInterval) 设置最大请重试的时间间隔\n> \n>  * 参数maxRetryInterval: 最大请重试的时间间隔 (毫秒)\n\n// 设置请求最大重试次数为 10ms\nrequest.maxRetryInterval(10L);\n\n\n1\n2\n\n\n\n# 重试器\n\nRetryer 重试器，即重试策略，可以设定每次重试请求之间的时间间隔\n\nForest 默认重试器类为 com.dtflys.forest.retryer.BackOffRetryer，它是依据二进制退避算法的重试策略类\n\n若配置该重试器，重试过程如下：\n\n * 第一次重试与第一次请求之间间隔 0的2次方 * 1s, 即0s\n * 第二次重试与第一次重试之间间隔 1的2次方 * 1s, 即1s\n * 第三次次重试与第二次重试之间间隔 2的2次方 * 1s, 即4s\n * 后面几次重试时间间隔以此类推，直到达到最大请求次数后停止重试\n * 每次时间间隔不能大于 maxRetryInterval, 若 maxRetryInterval 设置为 10, 则每次间隔只能为 10ms\n\n您也可以自定义重试器\n\n// 自定义重试器\n// 继承 BackOffRetryer 类\npublic class MyRetryer extends BackOffRetryer {\n\n    public MyRetryer(ForestRequest request) {\n        super(request);\n    }\n\n    /**\n     * 重写 nextInterval 方法\n     * 该方法用于指定每次重试的时间间隔\n     * @param currentCount 当前重试次数\n     * @return 时间间隔 (时间单位为毫秒)\n     */\n    @Override\n    protected long nextInterval(int currentCount) {\n        // 每次重试时间间隔恒定为 1s (1000ms)\n        return 1000;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n再通过 ForestRequest 对象的 retryer(Class<? extends ForestRetryer> retryerClass) 设置该自定义重试器类\n\n// 设置自定义重试器类\nrequest.retryer(MyRetryer.class);\n\n\n1\n2\n\n\n\n# 重试条件\n\nForest 请求的重试条件有两种设置模式:\n\n * 将 SuccessWhen 请求成功/失败条件 作为重试条件\n * 设置 RetryWhen 重试条件\n\n一般情况下不会设置 RetryWhen 重试条件，即直通过请求的成功/失败来判断是否重试，逻辑很简单：请求成功不重试，失败就重试\n\n但有些特殊情况，需要在请求成功的情况下也重试，满足一定业务条件后才停止重试，这种情况就需要 RetryWhen 重试条件上场了\n\n> retryWhen(RetryWhen retryWhen) 设置重试条件：用于判断请求是否触发重试\n> \n>  * 参数retryWhen: RetryWhen 接口实例\n\nForest.get("/")\n     // 最大重试次数为 3\n    .maxRetryCount(3)\n     // 最大重试间隔为 10ms\n    .maxRetryInterval(10)\n     // 重试条件: 状态码为 203 就重试\n    .retryWhen(((req, res) -> res.statusIs(203)))\n     // onSuccess回调函数: 成功时调用\n    .onSuccess((data, req, res) -> {\n        System.out.println("成功!")\n    })\n     // 执行请求\n    .execute();\n// 若发送请求后，服务端返回 203 状态码\n// 就不断触发重试\n// 直到服务端不返回 203，或达到最大重试次数，停止重试\n// 若最后一次重试服务端发送的还是 203，则认为请求成功，执行 onSuccess\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n先定义自定义请求重试实现类\n\n// 自定义重试条件类\n// 需要实现 RetryWhen 接口\npublic class MyRetryCondition implements RetryWhen {\n    /**\n     * 请求重试条件\n     * @param req Forest请求对象\n     * @param res Forest响应对象\n     * @return true 重试，false 不重试\n     */\n    @Override\n    public boolean retryWhen(ForestRequest req, ForestResponse res) {\n        // 响应状态码为 203 就重试\n        return res.statusIs(203);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再通过调用 retryWhen(Class<? extends RetryWhen> conditionClass) 方法设置自定义重试条件类\n\nForest.get("/")\n     // 最大重试次数为 3\n    .maxRetryCount(3)\n     // 最大重试间隔为 10ms\n    .maxRetryInterval(10)\n     // 重试条件: 状态码为 203 就重试\n    .retryWhen(MyRetryCondition.class)\n     // onSuccess回调函数: 成功时调用\n    .onSuccess((data, req, res) -> {\n        System.out.println("成功!");\n    })\n     // 执行请求\n    .execute();\n// 若发送请求后，服务端返回 203 状态码\n// 就不断触发重试\n// 直到服务端不返回 203，或达到最大重试次数，停止重试\n// 若最后一次重试服务端发送的还是 203，则认为请求成功，执行 onSuccess\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'forestrequest 对象提供了设置重试相关属性的方法\n\n是否运行重试 (默认为开启重试)\n\n> setretryenabled(boolean retryenabled) 设置是否开启请求重试\n> \n>  * 参数retryenabled: true 开启重试，false 关闭重试\n\n// 开启请求重试（默认即开启）\nrequest.setretryenabled(true);\n// 关闭请求重试（关闭后该请求不会再触发重试）\nrequest.setretryenabled(false);\n\n\n1\n2\n3\n4\n\n\n设置最大重试次数 (默认为0次，即不会重试)\n\n> maxretrycount(int retrycount) 设置请求失败后的最大重试次数\n> \n>  * 参数retrycount: 重试次数\n\n// 设置请求最大重试次数为 3 次\nrequest.maxretrycount(3);\n\n\n1\n2\n\n\n设置最大请重试的时间间隔 (时间单位为毫秒, 默认为0毫秒)\n\n> maxretryinterval(long maxretryinterval) 设置最大请重试的时间间隔\n> \n>  * 参数maxretryinterval: 最大请重试的时间间隔 (毫秒)\n\n// 设置请求最大重试次数为 10ms\nrequest.maxretryinterval(10l);\n\n\n1\n2\n\n\n\n# 重试器\n\nretryer 重试器，即重试策略，可以设定每次重试请求之间的时间间隔\n\nforest 默认重试器类为 com.dtflys.forest.retryer.backoffretryer，它是依据二进制退避算法的重试策略类\n\n若配置该重试器，重试过程如下：\n\n * 第一次重试与第一次请求之间间隔 0的2次方 * 1s, 即0s\n * 第二次重试与第一次重试之间间隔 1的2次方 * 1s, 即1s\n * 第三次次重试与第二次重试之间间隔 2的2次方 * 1s, 即4s\n * 后面几次重试时间间隔以此类推，直到达到最大请求次数后停止重试\n * 每次时间间隔不能大于 maxretryinterval, 若 maxretryinterval 设置为 10, 则每次间隔只能为 10ms\n\n您也可以自定义重试器\n\n// 自定义重试器\n// 继承 backoffretryer 类\npublic class myretryer extends backoffretryer {\n\n    public myretryer(forestrequest request) {\n        super(request);\n    }\n\n    /**\n     * 重写 nextinterval 方法\n     * 该方法用于指定每次重试的时间间隔\n     * @param currentcount 当前重试次数\n     * @return 时间间隔 (时间单位为毫秒)\n     */\n    @override\n    protected long nextinterval(int currentcount) {\n        // 每次重试时间间隔恒定为 1s (1000ms)\n        return 1000;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n再通过 forestrequest 对象的 retryer(class<? extends forestretryer> retryerclass) 设置该自定义重试器类\n\n// 设置自定义重试器类\nrequest.retryer(myretryer.class);\n\n\n1\n2\n\n\n\n# 重试条件\n\nforest 请求的重试条件有两种设置模式:\n\n * 将 successwhen 请求成功/失败条件 作为重试条件\n * 设置 retrywhen 重试条件\n\n一般情况下不会设置 retrywhen 重试条件，即直通过请求的成功/失败来判断是否重试，逻辑很简单：请求成功不重试，失败就重试\n\n但有些特殊情况，需要在请求成功的情况下也重试，满足一定业务条件后才停止重试，这种情况就需要 retrywhen 重试条件上场了\n\n> retrywhen(retrywhen retrywhen) 设置重试条件：用于判断请求是否触发重试\n> \n>  * 参数retrywhen: retrywhen 接口实例\n\nforest.get("/")\n     // 最大重试次数为 3\n    .maxretrycount(3)\n     // 最大重试间隔为 10ms\n    .maxretryinterval(10)\n     // 重试条件: 状态码为 203 就重试\n    .retrywhen(((req, res) -> res.statusis(203)))\n     // onsuccess回调函数: 成功时调用\n    .onsuccess((data, req, res) -> {\n        system.out.println("成功!")\n    })\n     // 执行请求\n    .execute();\n// 若发送请求后，服务端返回 203 状态码\n// 就不断触发重试\n// 直到服务端不返回 203，或达到最大重试次数，停止重试\n// 若最后一次重试服务端发送的还是 203，则认为请求成功，执行 onsuccess\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n先定义自定义请求重试实现类\n\n// 自定义重试条件类\n// 需要实现 retrywhen 接口\npublic class myretrycondition implements retrywhen {\n    /**\n     * 请求重试条件\n     * @param req forest请求对象\n     * @param res forest响应对象\n     * @return true 重试，false 不重试\n     */\n    @override\n    public boolean retrywhen(forestrequest req, forestresponse res) {\n        // 响应状态码为 203 就重试\n        return res.statusis(203);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再通过调用 retrywhen(class<? extends retrywhen> conditionclass) 方法设置自定义重试条件类\n\nforest.get("/")\n     // 最大重试次数为 3\n    .maxretrycount(3)\n     // 最大重试间隔为 10ms\n    .maxretryinterval(10)\n     // 重试条件: 状态码为 203 就重试\n    .retrywhen(myretrycondition.class)\n     // onsuccess回调函数: 成功时调用\n    .onsuccess((data, req, res) -> {\n        system.out.println("成功!");\n    })\n     // 执行请求\n    .execute();\n// 若发送请求后，服务端返回 203 状态码\n// 就不断触发重试\n// 直到服务端不返回 203，或达到最大重试次数，停止重试\n// 若最后一次重试服务端发送的还是 203，则认为请求成功，执行 onsuccess\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🥯 Cookie",frontmatter:{title:"🥯 Cookie",date:"2022-07-14T12:43:23.000Z",permalink:"/pages/1.5.x/api_cookie/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/012.api_cookie.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/012.api_cookie.md",key:"v-57403bbe",path:"/pages/1.5.x/api_cookie/",headers:[{level:2,title:"加载 Cookie",slug:"加载-cookie",normalizedTitle:"加载 cookie",charIndex:2},{level:2,title:"保存 Cookie",slug:"保存-cookie",normalizedTitle:"保存 cookie",charIndex:342},{level:2,title:"严格匹配模式 (v1.5.25)",slug:"严格匹配模式-v1-5-25",normalizedTitle:"严格匹配模式 (v1.5.25)",charIndex:686}],headersStr:"加载 Cookie 保存 Cookie 严格匹配模式 (v1.5.25)",content:'# 加载 Cookie\n\nonLoadCookie(OnLoadCookie onLoadCookie) 设置加载Cookie回调函数: 加载Cookie时调用\n\n * 参数onLoadCookie: OnLoadCookie 接口实例\n\nForest.post("/")\n     // onLoadCookie回调函数: 加载Cookie时调用\n    .onLoadCookie(((req, cookies) -> {\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // cookies 为Cookie集合, 需要通过请求发送的Cookie都添加到该集合\n    }));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 保存 Cookie\n\nonSaveCookie(OnSaveCookie onSaveCookie) 设置保存Cookie回调函数: 需要保存Cookie时调用\n\n * 参数onSaveCookie: OnSaveCookie 接口实例\n\nForest.post("/")\n     // onSaveCookie回调函数: 需要保存Cookie时调用\n    .onSaveCookie(((req, cookies) -> {\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // cookies 为Cookie集合, 需要通过请求发送的Cookie都添加到该集合\n    }));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 严格匹配模式 (v1.5.25)\n\n默认情况下，只有符合条件 (和请求同域名、同URL路径、未过期) 的 Cookie 才能被添加到请求中\n\n这是因为 Forest 的 Cookie 集合默认为严格匹配模式，如果想添加符合匹配要求的 Cookie，只需修改严格匹配为false即可\n\n\n\n\n\n \n\n\n\n\n\n\n\nForest.post("/")\n    // onLoadCookie回调函数: 加载Cookie时调用\n    .onLoadCookie(((req, cookies) -> {\n        cookies.strict(false) // 设置为非严格匹配模式\n        .addCookie(new ForestCookie("attr1", "foo")) // 不设域名，默认情况下也能添加\n        .addCookie(new ForestCookie("attr2", "bar")) // 不设域名，默认情况下也能添加\n        // 不设域名，只有在非严格匹配模式下可以添加到请求中\n        .addCookie(new ForestCookie("attr3", "foobar").setDomain("xxx.com"));\n    }));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# 加载 cookie\n\nonloadcookie(onloadcookie onloadcookie) 设置加载cookie回调函数: 加载cookie时调用\n\n * 参数onloadcookie: onloadcookie 接口实例\n\nforest.post("/")\n     // onloadcookie回调函数: 加载cookie时调用\n    .onloadcookie(((req, cookies) -> {\n        // req 为forest请求对象，即 forestrequest 类实例\n        // cookies 为cookie集合, 需要通过请求发送的cookie都添加到该集合\n    }));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 保存 cookie\n\nonsavecookie(onsavecookie onsavecookie) 设置保存cookie回调函数: 需要保存cookie时调用\n\n * 参数onsavecookie: onsavecookie 接口实例\n\nforest.post("/")\n     // onsavecookie回调函数: 需要保存cookie时调用\n    .onsavecookie(((req, cookies) -> {\n        // req 为forest请求对象，即 forestrequest 类实例\n        // cookies 为cookie集合, 需要通过请求发送的cookie都添加到该集合\n    }));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 严格匹配模式 (v1.5.25)\n\n默认情况下，只有符合条件 (和请求同域名、同url路径、未过期) 的 cookie 才能被添加到请求中\n\n这是因为 forest 的 cookie 集合默认为严格匹配模式，如果想添加符合匹配要求的 cookie，只需修改严格匹配为false即可\n\n\n\n\n\n \n\n\n\n\n\n\n\nforest.post("/")\n    // onloadcookie回调函数: 加载cookie时调用\n    .onloadcookie(((req, cookies) -> {\n        cookies.strict(false) // 设置为非严格匹配模式\n        .addcookie(new forestcookie("attr1", "foo")) // 不设域名，默认情况下也能添加\n        .addcookie(new forestcookie("attr2", "bar")) // 不设域名，默认情况下也能添加\n        // 不设域名，只有在非严格匹配模式下可以添加到请求中\n        .addcookie(new forestcookie("attr3", "foobar").setdomain("xxx.com"));\n    }));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/07/21, 00:46:54",lastUpdatedTimestamp:1658335614e3},{title:"🛰️ 请求代理",frontmatter:{title:"🛰️ 请求代理",date:"2022-07-14T12:46:07.000Z",permalink:"/pages/1.5.x/api_proxy/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/010.%E8%AF%B7%E6%B1%82API/016.api_proxy.html",relativePath:"001.v1.5.x文档/050.编程式接口/010.请求API/016.api_proxy.md",key:"v-0daf3774",path:"/pages/1.5.x/api_proxy/",headersStr:null,content:'ForestRequest 提供了设置和获取正向代理的方法\n\n> proxy(ForestProxy proxy) 设置正向代理\n> \n>  * 参数proxy 正向代理，ForestProxy 类实例\n\n// 构建Forest正向代理对象\n// 设置代理服务器的主机地址和端口号\nForestProxy proxy = new ForestProxy("127.0.0.1", 3128);\n// 设置代理服务验证的用户名和密码\nproxy.setUsername("foo");\nproxy.setPassword("bar");\n// 为请求设置正向代理\nrequest.proxy(proxy);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'forestrequest 提供了设置和获取正向代理的方法\n\n> proxy(forestproxy proxy) 设置正向代理\n> \n>  * 参数proxy 正向代理，forestproxy 类实例\n\n// 构建forest正向代理对象\n// 设置代理服务器的主机地址和端口号\nforestproxy proxy = new forestproxy("127.0.0.1", 3128);\n// 设置代理服务验证的用户名和密码\nproxy.setusername("foo");\nproxy.setpassword("bar");\n// 为请求设置正向代理\nrequest.proxy(proxy);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/07/20, 22:33:22",lastUpdatedTimestamp:1658327602e3},{title:"🌠 响应对象",frontmatter:{title:"🌠 响应对象",date:"2022-07-14T12:56:15.000Z",permalink:"/pages/1.5.x/api_forest_response/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.%E5%93%8D%E5%BA%94API/001.api_forest_response.html",relativePath:"001.v1.5.x文档/050.编程式接口/020.响应API/001.api_forest_response.md",key:"v-3a7c0a5a",path:"/pages/1.5.x/api_forest_response/",headers:[{level:2,title:"响应对象",slug:"响应对象",normalizedTitle:"响应对象",charIndex:2},{level:2,title:"获取响应对象",slug:"获取响应对象",normalizedTitle:"获取响应对象",charIndex:122},{level:3,title:"声明式",slug:"声明式",normalizedTitle:"声明式",charIndex:178},{level:3,title:"编程式",slug:"编程式",normalizedTitle:"编程式",charIndex:192}],headersStr:"响应对象 获取响应对象 声明式 编程式",content:'# 响应对象\n\n响应对象是 Forest 中最核心组件之一，其类名为ForestResponse\n\n其主要承担的作用是，将服务端返回的响应信息（包括响应头、响应体、请求异常信息）封装在该对象中\n\n并提供直观的API对返回的数据进行读取\n\n\n# 获取响应对象\n\n如同《请求对象》一样，在 Forest 中有两种获取 ForestResponse 对象的方法：声明式接口方法返回响应对象和编程式接口创建响应对象。\n\n\n# 声明式\n\npublic interface MyClient {\n    /**\n     * Get类型请求，url路径为 /test\n     * <p>ForestResponse是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return Forest响应对象\n     */\n    @Get("/test")\n    ForestResponse<String> getForestResponse();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用 getForestResponse() 方法后即可马上发送请求，并且获取该请求所返回的 Forest 响应对象\n\n@Resouce\nMyClient myClient;\n\n... ...\n// 发送请求，并获取从服务端返回的响应数据对象\nForestResponse<String> response = myClient.getForestResponse();\n// 获取响应结果数据\nString result = response.getResult();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 编程式\n\nForestResponse response = Forest.get("/test")\n        .execute(ForestResponse.class);\n// 获取响应结果数据\nString result = response.getResult();\n\n\n1\n2\n3\n4\n',normalizedContent:'# 响应对象\n\n响应对象是 forest 中最核心组件之一，其类名为forestresponse\n\n其主要承担的作用是，将服务端返回的响应信息（包括响应头、响应体、请求异常信息）封装在该对象中\n\n并提供直观的api对返回的数据进行读取\n\n\n# 获取响应对象\n\n如同《请求对象》一样，在 forest 中有两种获取 forestresponse 对象的方法：声明式接口方法返回响应对象和编程式接口创建响应对象。\n\n\n# 声明式\n\npublic interface myclient {\n    /**\n     * get类型请求，url路径为 /test\n     * <p>forestresponse是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return forest响应对象\n     */\n    @get("/test")\n    forestresponse<string> getforestresponse();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用 getforestresponse() 方法后即可马上发送请求，并且获取该请求所返回的 forest 响应对象\n\n@resouce\nmyclient myclient;\n\n... ...\n// 发送请求，并获取从服务端返回的响应数据对象\nforestresponse<string> response = myclient.getforestresponse();\n// 获取响应结果数据\nstring result = response.getresult();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 编程式\n\nforestresponse response = forest.get("/test")\n        .execute(forestresponse.class);\n// 获取响应结果数据\nstring result = response.getresult();\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"✒️ 读取数据",frontmatter:{title:"✒️ 读取数据",date:"2022-07-14T14:26:34.000Z",permalink:"/pages/1.5.x/api_response_read/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.%E5%93%8D%E5%BA%94API/002.api_response_read.html",relativePath:"001.v1.5.x文档/050.编程式接口/020.响应API/002.api_response_read.md",key:"v-326ffa2f",path:"/pages/1.5.x/api_response_read/",headers:[{level:3,title:"自定义对象类型",slug:"自定义对象类型",normalizedTitle:"自定义对象类型",charIndex:38},{level:3,title:"字符串类型",slug:"字符串类型",normalizedTitle:"字符串类型",charIndex:591},{level:3,title:"字节数组类型",slug:"字节数组类型",normalizedTitle:"字节数组类型",charIndex:702},{level:3,title:"流类型",slug:"流类型",normalizedTitle:"流类型",charIndex:816}],headersStr:"自定义对象类型 字符串类型 字节数组类型 流类型",content:'Forest响应对象提供了多种数据读取的方式，以读取不同类型的数据\n\n\n# 自定义对象类型\n\nForest响应对象可以直接读取经过反序列化后的自定义类型的对象\n\n该对象的类型必须和 ForestResponse<泛型参数> 中泛型参数指向的类型一致\n\npublic interface MyClient {\n    /**\n     * Get类型请求，url路径为 /test\n     * <p>ForestResponse是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return Forest响应对象\n     */\n    @Get("/test")\n    ForestResponse<MyUser> getUser();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后通过getResult方法获取转换后的对象\n\n> getResult() 获取反序列化成对象类型的请求响应内容\n\n// 发送请求，并获取从服务端返回的响应数据对象\nForestResponse<getUser> response = myClient.getUser();\n// 获取转换后的响应结果对象\nMyUser user = response.getResult();\n\n\n1\n2\n3\n4\n\n\n\n# 字符串类型\n\n> readAsString() 以字符串方式读取请求响应内容\n\n// 以字符串方式读取请求响应内容\nString content = response.readAsString();\n\n\n1\n2\n\n\n\n# 字节数组类型\n\n> getByteArray() 以字节数组的形式获取请求响应内容\n\n// 以字节数组的形式获取请求响应内容\nbyte[] bytes = response.getByteArray();\n\n\n1\n2\n\n\n\n# 流类型\n\n> getInputStream() throws Exception 以输入流的形式获取请求响应内容\n\n友情提示\n\n 1. 以流的方式读取数据的时候，一定别忘了在读取完毕后关闭流\n 2. 流只能读取一次，关闭流后不能从response.getInputStream()以及其它数据读取方法中再次读取\n\n// 以 try-with-resource 方式读取流后，会自动关闭流\ntry (InputStream in = response.getInputStream()) {\n    // 从流中读取字符串数据\n    String content = IOUilts.toString(in, StandardCharsets.UTF_8);\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用response.close()方法亦可关闭响应的流\n\ntry {\n    // 获取响应流\n    InputStream in = response.getInputStream()\n    // 从流中读取字符串数据\n    String content = IOUilts.toString(in, StandardCharsets.UTF_8);\n} catch (Exception ex) {\n    ex.printStackTrace();\n} finally {\n    // 关闭响应流\n    // 关闭后不可再通过响应对象的数据读取方法获取数据\n    response.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',normalizedContent:'forest响应对象提供了多种数据读取的方式，以读取不同类型的数据\n\n\n# 自定义对象类型\n\nforest响应对象可以直接读取经过反序列化后的自定义类型的对象\n\n该对象的类型必须和 forestresponse<泛型参数> 中泛型参数指向的类型一致\n\npublic interface myclient {\n    /**\n     * get类型请求，url路径为 /test\n     * <p>forestresponse是带泛型参数的类型\n     * <p>泛型参数代表返回的响应数据所期望转化成的类型\n     * \n     * @return forest响应对象\n     */\n    @get("/test")\n    forestresponse<myuser> getuser();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后通过getresult方法获取转换后的对象\n\n> getresult() 获取反序列化成对象类型的请求响应内容\n\n// 发送请求，并获取从服务端返回的响应数据对象\nforestresponse<getuser> response = myclient.getuser();\n// 获取转换后的响应结果对象\nmyuser user = response.getresult();\n\n\n1\n2\n3\n4\n\n\n\n# 字符串类型\n\n> readasstring() 以字符串方式读取请求响应内容\n\n// 以字符串方式读取请求响应内容\nstring content = response.readasstring();\n\n\n1\n2\n\n\n\n# 字节数组类型\n\n> getbytearray() 以字节数组的形式获取请求响应内容\n\n// 以字节数组的形式获取请求响应内容\nbyte[] bytes = response.getbytearray();\n\n\n1\n2\n\n\n\n# 流类型\n\n> getinputstream() throws exception 以输入流的形式获取请求响应内容\n\n友情提示\n\n 1. 以流的方式读取数据的时候，一定别忘了在读取完毕后关闭流\n 2. 流只能读取一次，关闭流后不能从response.getinputstream()以及其它数据读取方法中再次读取\n\n// 以 try-with-resource 方式读取流后，会自动关闭流\ntry (inputstream in = response.getinputstream()) {\n    // 从流中读取字符串数据\n    string content = iouilts.tostring(in, standardcharsets.utf_8);\n} catch (exception ex) {\n    ex.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用response.close()方法亦可关闭响应的流\n\ntry {\n    // 获取响应流\n    inputstream in = response.getinputstream()\n    // 从流中读取字符串数据\n    string content = iouilts.tostring(in, standardcharsets.utf_8);\n} catch (exception ex) {\n    ex.printstacktrace();\n} finally {\n    // 关闭响应流\n    // 关闭后不可再通过响应对象的数据读取方法获取数据\n    response.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🦋 响应状态码",frontmatter:{title:"🦋 响应状态码",date:"2022-07-14T15:41:32.000Z",permalink:"/pages/1.5.x/api_response_status/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.%E5%93%8D%E5%BA%94API/003.api_response_status.html",relativePath:"001.v1.5.x文档/050.编程式接口/020.响应API/003.api_response_status.md",key:"v-b4a40016",path:"/pages/1.5.x/api_response_status/",headers:[{level:2,title:"响应状态码",slug:"响应状态码",normalizedTitle:"响应状态码",charIndex:2},{level:3,title:"状态码分类",slug:"状态码分类",normalizedTitle:"状态码分类",charIndex:67},{level:2,title:"获取响应状态码",slug:"获取响应状态码",normalizedTitle:"获取响应状态码",charIndex:322},{level:2,title:"判断响应状态码",slug:"判断响应状态码",normalizedTitle:"判断响应状态码",charIndex:571},{level:3,title:"判断状态码分类",slug:"判断状态码分类",normalizedTitle:"判断状态码分类",charIndex:626},{level:3,title:"判断状态码是否成功",slug:"判断状态码是否成功",normalizedTitle:"判断状态码是否成功",charIndex:1363},{level:3,title:"其他一些判断方法",slug:"其他一些判断方法",normalizedTitle:"其他一些判断方法",charIndex:1520},{level:2,title:"获取状态码短语",slug:"获取状态码短语",normalizedTitle:"获取状态码短语",charIndex:1694}],headersStr:"响应状态码 状态码分类 获取响应状态码 判断响应状态码 判断状态码分类 判断状态码是否成功 其他一些判断方法 获取状态码短语",content:'# 响应状态码\n\n我们常见的 404、500、200 就是HTTP响应状态码，每个数字都有不同的语义，分别表示不同的响应状态\n\n\n# 状态码分类\n\n状态码   描述\n1xx   响应中：表⽰服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程\n2xx   成功：表⽰服务器成功接收请求并已完成整个处理过程\n3xx   重定向：重定向到其它地方；它让客户端发起一个请求以完成整个处理\n4xx   客户端错误：表示客户端的请求有错误，如⽆法找到被请求的页⾯\n5xx   服务端错误：表示服务器端出现错误，如服务端代码执行过程中出现异常\n\n若想知道所有的HTTP响应状态码的定义，可以在W3C官网查看《RFC2616规范》\n\n\n# 获取响应状态码\n\nstatusCode() ： 获取请求响应的状态码\n\n * 返回值 : HTTP 状态码，但可能为 -1（表示未接收到服务端的响应信息）\n\n// 获取请求响应的状态码\nint statusCode = response.statusCode();\n\n// 若状态码为 -1，则表示未接收到服务端的响应信息\nif (statusCode == -1) {\n    System.out.println("未成功获得服务端响应信息");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 判断响应状态码\n\nForest为了方便后续处理，提供了一些快捷的状态码判断方法，用来判断状态码的类型\n\n\n# 判断状态码分类\n\nstatus_1xx() : 请求响应码是否在 100 ~ 199 范围内\n\n * 返回值 : true代表在 100 ~ 399 范围内, false表示不在\n\nstatus_2xx() : 请求响应码是否在 200 ~ 299 范围内\n\n * 返回值 : true代表在 200 ~ 299 范围内, false表示不在\n\nstatus_3xx() : 请求响应码是否在 300 ~ 399 范围内\n\n * 返回值 : true代表在 300 ~ 399 范围内, false表示不在\n\nstatus_4xx() : 请求响应码是否在 400 ~ 499 范围内\n\n * 返回值 : true代表在 400 ~ 499 范围内, false表示不在\n\nstatus_5xx() : 请求响应码是否在 500 ~ 599 范围内\n\n * 返回值 : true代表在 500 ~ 599 范围内, false表示不在\n\n// 判断响应状态码是否是 1xx\nboolean is_1xx = response.status_1xx();\n// 判断响应状态码是否是 2xx\nboolean is_2xx = response.status_2xx();\n// 判断响应状态码是否是 3xx\nboolean is_3xx = response.status_3xx();\n// 判断响应状态码是否是 4xx\nboolean is_4xx = response.status_4xx();\n// 判断响应状态码是否是 5xx\nboolean is_5xx = response.status_5xx();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 判断状态码是否成功\n\nstatusOk() : 请求响应码是否在成功范围内（100 ~ 399）\n\n * 返回值 : true代表在 100 ~ 399 成功范围内, false表示不在\n\n// 判断响应状态码是否成功\nboolean isOk = response.statusOk();\n\n\n1\n2\n\n\n\n# 其他一些判断方法\n\n// statusIs 方法可判断响应状态码是否为某一个数\nboolean is_404 = reponse.statusIs(404);\n// statusIsNot 方法可判断响应状态码是否不为某一个数\nboolean not_500 = response.statusIsNot(500);\n\n\n1\n2\n3\n4\n\n\n\n# 获取状态码短语\n\ngetReasonPhrase() : 获取请求响应状态码的原因短语\n\n * 返回值 : 请求响应状态码的原因短语，如状态码为 200 的时候，短语会是OK\n\n// 获取状态码短语\nString phrase = response.getReasonPhrase();\nSystem.out.println("状态码短语: " + phrase);\n\n\n1\n2\n3\n',normalizedContent:'# 响应状态码\n\n我们常见的 404、500、200 就是http响应状态码，每个数字都有不同的语义，分别表示不同的响应状态\n\n\n# 状态码分类\n\n状态码   描述\n1xx   响应中：表⽰服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程\n2xx   成功：表⽰服务器成功接收请求并已完成整个处理过程\n3xx   重定向：重定向到其它地方；它让客户端发起一个请求以完成整个处理\n4xx   客户端错误：表示客户端的请求有错误，如⽆法找到被请求的页⾯\n5xx   服务端错误：表示服务器端出现错误，如服务端代码执行过程中出现异常\n\n若想知道所有的http响应状态码的定义，可以在w3c官网查看《rfc2616规范》\n\n\n# 获取响应状态码\n\nstatuscode() ： 获取请求响应的状态码\n\n * 返回值 : http 状态码，但可能为 -1（表示未接收到服务端的响应信息）\n\n// 获取请求响应的状态码\nint statuscode = response.statuscode();\n\n// 若状态码为 -1，则表示未接收到服务端的响应信息\nif (statuscode == -1) {\n    system.out.println("未成功获得服务端响应信息");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 判断响应状态码\n\nforest为了方便后续处理，提供了一些快捷的状态码判断方法，用来判断状态码的类型\n\n\n# 判断状态码分类\n\nstatus_1xx() : 请求响应码是否在 100 ~ 199 范围内\n\n * 返回值 : true代表在 100 ~ 399 范围内, false表示不在\n\nstatus_2xx() : 请求响应码是否在 200 ~ 299 范围内\n\n * 返回值 : true代表在 200 ~ 299 范围内, false表示不在\n\nstatus_3xx() : 请求响应码是否在 300 ~ 399 范围内\n\n * 返回值 : true代表在 300 ~ 399 范围内, false表示不在\n\nstatus_4xx() : 请求响应码是否在 400 ~ 499 范围内\n\n * 返回值 : true代表在 400 ~ 499 范围内, false表示不在\n\nstatus_5xx() : 请求响应码是否在 500 ~ 599 范围内\n\n * 返回值 : true代表在 500 ~ 599 范围内, false表示不在\n\n// 判断响应状态码是否是 1xx\nboolean is_1xx = response.status_1xx();\n// 判断响应状态码是否是 2xx\nboolean is_2xx = response.status_2xx();\n// 判断响应状态码是否是 3xx\nboolean is_3xx = response.status_3xx();\n// 判断响应状态码是否是 4xx\nboolean is_4xx = response.status_4xx();\n// 判断响应状态码是否是 5xx\nboolean is_5xx = response.status_5xx();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 判断状态码是否成功\n\nstatusok() : 请求响应码是否在成功范围内（100 ~ 399）\n\n * 返回值 : true代表在 100 ~ 399 成功范围内, false表示不在\n\n// 判断响应状态码是否成功\nboolean isok = response.statusok();\n\n\n1\n2\n\n\n\n# 其他一些判断方法\n\n// statusis 方法可判断响应状态码是否为某一个数\nboolean is_404 = reponse.statusis(404);\n// statusisnot 方法可判断响应状态码是否不为某一个数\nboolean not_500 = response.statusisnot(500);\n\n\n1\n2\n3\n4\n\n\n\n# 获取状态码短语\n\ngetreasonphrase() : 获取请求响应状态码的原因短语\n\n * 返回值 : 请求响应状态码的原因短语，如状态码为 200 的时候，短语会是ok\n\n// 获取状态码短语\nstring phrase = response.getreasonphrase();\nsystem.out.println("状态码短语: " + phrase);\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🏥 响应错误处理",frontmatter:{title:"🏥 响应错误处理",date:"2022-07-14T17:20:14.000Z",permalink:"/pages/1.5.x/api_response_error/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.%E5%93%8D%E5%BA%94API/004.api_response_error.html",relativePath:"001.v1.5.x文档/050.编程式接口/020.响应API/004.api_response_error.md",key:"v-2022e0ae",path:"/pages/1.5.x/api_response_error/",headers:[{level:2,title:"请求成功/失败",slug:"请求成功-失败",normalizedTitle:"请求成功/失败",charIndex:2},{level:2,title:"错误类型",slug:"错误类型",normalizedTitle:"错误类型",charIndex:382},{level:3,title:"状态码错误",slug:"状态码错误",normalizedTitle:"状态码错误",charIndex:471},{level:3,title:"异常错误",slug:"异常错误",normalizedTitle:"异常错误",charIndex:481},{level:3,title:"超时错误",slug:"超时错误",normalizedTitle:"超时错误",charIndex:929}],headersStr:"请求成功/失败 错误类型 状态码错误 异常错误 超时错误",content:'# 请求成功/失败\n\n若Forest请求最终以ForestResponse作为返回类型，那么即便在请求过程中出现错误或异常，也不会直接中断抛出异常，且最终始终会返回一个非空的ForestResponse对象\n\n而在ForestResponse对象中提供了一些用来判断这次请求是否成功或失败的方法\n\nisSuccess() : 网络请求是否成功\n\n * 返回值 : true表示请求成功，false表示请求失败\n\nisError() : 网络请求是否失败\n\n * 返回值 : true表示请求失败，false表示请求成功\n\n// 获取网络请求是否成功\nboolean bSuccess = response.isSuccess();\n// 获取网络请求是否失败\nboolean bError = response.isError();\n\n\n1\n2\n3\n4\n\n\n\n# 错误类型\n\n在Forest请求过程中可能会出现各种各样的错误和异常，比如超时、SSL验证不通过，亦或者是服务端返回一个错误的HTTP状态码\n\n在这些错误中，主要分成两种类型错误：状态码错误，和客户端异常错误\n\n\n# 状态码错误\n\n状态码错误即表示HTTP响应状态码不在成功的范围数值内（100 ~ 399)，比如: 404、500 就是常见的表示失败的状态码\n\n关于状态码的分类与说明，以及如何获取状态码请参见《响应状态码》\n\n以下代码介绍如何判断状态码为失败:\n\n// 判断HTTP状态码是否失败\nboolean isStatusError = !response.statusOk();\n\n\n1\n2\n\n\n\n# 异常错误\n\n> getException() 获取请求过程中产生的异常\n> \n>  * 返回值: 异常对象，Throwable的子类对象\n\n// 获取请求过程中产生的异常\nThrowable exception = response.getException();\nif (exception != null) {\n    System.out.println("请求异常: " + exception.getMessage());    \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 超时错误\n\n> isTimeout() 请求是否超时\n> \n>  * 返回值: true表示已超时, false表示未超时\n\n// 获取请求是否超时\nboolean bTimeout = response.isTimeout();\n\n\n1\n2\n',normalizedContent:'# 请求成功/失败\n\n若forest请求最终以forestresponse作为返回类型，那么即便在请求过程中出现错误或异常，也不会直接中断抛出异常，且最终始终会返回一个非空的forestresponse对象\n\n而在forestresponse对象中提供了一些用来判断这次请求是否成功或失败的方法\n\nissuccess() : 网络请求是否成功\n\n * 返回值 : true表示请求成功，false表示请求失败\n\niserror() : 网络请求是否失败\n\n * 返回值 : true表示请求失败，false表示请求成功\n\n// 获取网络请求是否成功\nboolean bsuccess = response.issuccess();\n// 获取网络请求是否失败\nboolean berror = response.iserror();\n\n\n1\n2\n3\n4\n\n\n\n# 错误类型\n\n在forest请求过程中可能会出现各种各样的错误和异常，比如超时、ssl验证不通过，亦或者是服务端返回一个错误的http状态码\n\n在这些错误中，主要分成两种类型错误：状态码错误，和客户端异常错误\n\n\n# 状态码错误\n\n状态码错误即表示http响应状态码不在成功的范围数值内（100 ~ 399)，比如: 404、500 就是常见的表示失败的状态码\n\n关于状态码的分类与说明，以及如何获取状态码请参见《响应状态码》\n\n以下代码介绍如何判断状态码为失败:\n\n// 判断http状态码是否失败\nboolean isstatuserror = !response.statusok();\n\n\n1\n2\n\n\n\n# 异常错误\n\n> getexception() 获取请求过程中产生的异常\n> \n>  * 返回值: 异常对象，throwable的子类对象\n\n// 获取请求过程中产生的异常\nthrowable exception = response.getexception();\nif (exception != null) {\n    system.out.println("请求异常: " + exception.getmessage());    \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 超时错误\n\n> istimeout() 请求是否超时\n> \n>  * 返回值: true表示已超时, false表示未超时\n\n// 获取请求是否超时\nboolean btimeout = response.istimeout();\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🎧 响应头",frontmatter:{title:"🎧 响应头",date:"2022-07-14T18:04:30.000Z",permalink:"/pages/1.5.x/api_response_hreader/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.%E5%93%8D%E5%BA%94API/005.api_response_hreader.html",relativePath:"001.v1.5.x文档/050.编程式接口/020.响应API/005.api_response_hreader.md",key:"v-6cf70ea9",path:"/pages/1.5.x/api_response_hreader/",headers:[{level:2,title:"获取响应头",slug:"获取响应头",normalizedTitle:"获取响应头",charIndex:2},{level:2,title:"获取重名响应头",slug:"获取重名响应头",normalizedTitle:"获取重名响应头",charIndex:453},{level:2,title:"获取所有响应头",slug:"获取所有响应头",normalizedTitle:"获取所有响应头",charIndex:1040}],headersStr:"获取响应头 获取重名响应头 获取所有响应头",content:'# 获取响应头\n\ngetHeaderValue(String name) : 根据响应头名称获取请求响应头值\n\n * 参数name: 响应头名称\n * 返回值: 请求响应头值\n\n// 获取 Content-Encoding 响应头的值\nString value = response.getHeaderValue("Content-Encoding");\n\n\n1\n2\n\n\ngetHeader(String name) : 根据响应头名称获取单个请求响应头\n\n * 参数name: 响应头名称\n * 返回值: 请求响应头对象\n\n// 获取名为 Connection 的响应头对象 \nForestHeader header = response.getHeader("Connection");\n// 获取响应头名称\nString name = header.getName();\n// 获取响应头的值\nString value = header.getValue();\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 获取重名响应头\n\n有时候一个响应可能会存在多个重名的响应头，比如: Set-Cookie\n\ngetHeaderValues(String name) : 根据响应头名称获取请求响应头值列表\n\n * 参数name: 响应头名称\n * 返回值: 请求响应头值列表\n\n// 获取名为 Set-Cookie 的多个响应头\nList<String> values = response.getHeaderValues("Set-Cookie");\n\n\n1\n2\n\n\ngetHeaders(String name) : 根据响应头名称获取请求响应头对象列表\n\n * 参数name: 响应头名称\n * 返回值 : 请求响应头对象列表\n\n// 获取名为 Set-Cookie 的多个响应头的对象列表\nList<ForestHeader> headers = response.getHeaders("Set-Cookie");\n// 循环遍历响应头列表\nfor (ForestHeader header : headers) {\n    // 获取响应头名称\n    String name = header.getName();\n    // 获取响应头的值\n    String value = header.getValue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 获取所有响应头\n\ngetHeaders() : 获取请求响应的所有响应头\n\n * 返回值 : 请求响应的所有响应头的对象列表\n\n// 获取请求响应的所有响应头\nList<ForestHeader> headers = response.getHeaders();\n// 循环遍历响应头列表\nfor (ForestHeader header : headers) {\n    // 获取响应头名称\n    String name = header.getName();\n    // 获取响应头的值\n    String value = header.getValue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# 获取响应头\n\ngetheadervalue(string name) : 根据响应头名称获取请求响应头值\n\n * 参数name: 响应头名称\n * 返回值: 请求响应头值\n\n// 获取 content-encoding 响应头的值\nstring value = response.getheadervalue("content-encoding");\n\n\n1\n2\n\n\ngetheader(string name) : 根据响应头名称获取单个请求响应头\n\n * 参数name: 响应头名称\n * 返回值: 请求响应头对象\n\n// 获取名为 connection 的响应头对象 \nforestheader header = response.getheader("connection");\n// 获取响应头名称\nstring name = header.getname();\n// 获取响应头的值\nstring value = header.getvalue();\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 获取重名响应头\n\n有时候一个响应可能会存在多个重名的响应头，比如: set-cookie\n\ngetheadervalues(string name) : 根据响应头名称获取请求响应头值列表\n\n * 参数name: 响应头名称\n * 返回值: 请求响应头值列表\n\n// 获取名为 set-cookie 的多个响应头\nlist<string> values = response.getheadervalues("set-cookie");\n\n\n1\n2\n\n\ngetheaders(string name) : 根据响应头名称获取请求响应头对象列表\n\n * 参数name: 响应头名称\n * 返回值 : 请求响应头对象列表\n\n// 获取名为 set-cookie 的多个响应头的对象列表\nlist<forestheader> headers = response.getheaders("set-cookie");\n// 循环遍历响应头列表\nfor (forestheader header : headers) {\n    // 获取响应头名称\n    string name = header.getname();\n    // 获取响应头的值\n    string value = header.getvalue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 获取所有响应头\n\ngetheaders() : 获取请求响应的所有响应头\n\n * 返回值 : 请求响应的所有响应头的对象列表\n\n// 获取请求响应的所有响应头\nlist<forestheader> headers = response.getheaders();\n// 循环遍历响应头列表\nfor (forestheader header : headers) {\n    // 获取响应头名称\n    string name = header.getname();\n    // 获取响应头的值\n    string value = header.getvalue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🥞 Cookie",frontmatter:{title:"🥞 Cookie",date:"2022-07-15T18:14:06.000Z",permalink:"/pages/1.5.x/api_response_cookie/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/050.%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A5%E5%8F%A3/020.%E5%93%8D%E5%BA%94API/006.api_response_cookie.html",relativePath:"001.v1.5.x文档/050.编程式接口/020.响应API/006.api_response_cookie.md",key:"v-05d82ecb",path:"/pages/1.5.x/api_response_cookie/",headers:[{level:2,title:"Set-Cookie 响应头",slug:"set-cookie-响应头",normalizedTitle:"set-cookie 响应头",charIndex:2},{level:2,title:"获取 Cookie 对象",slug:"获取-cookie-对象",normalizedTitle:"获取 cookie 对象",charIndex:295},{level:2,title:"获取所有 Cookie",slug:"获取所有-cookie",normalizedTitle:"获取所有 cookie",charIndex:1061}],headersStr:"Set-Cookie 响应头 获取 Cookie 对象 获取所有 Cookie",content:'# Set-Cookie 响应头\n\nCookie 在本质上是通过HTTP请求的请求头和响应头进行传输和交互的\n\n而服务端发起的设置 Cookie 命令，是通过名为Set-Cookie的响应头传回给客户端的\n\n所以可以通过Set-Cookie的响应头来或许 Cookie 信息\n\n// 通过 Set-Cookie 响应头获取 Cookie 信息\nString cookieValue = response.getHeaderValue("Set-Cookie");\n// 解析 Cookie 信息\n\n\n1\n2\n3\n\n\n但这么做的弊端就是需要自己手动解析 Cookie 信息，十分不便\n\n\n# 获取 Cookie 对象\n\nForestResponse 对象提供了直接获取解析后的 Cookie 对象的方法\n\ngetCookie(String name) : 根据Cookie名称获取Cookie\n\n * 版本 : v1.5.23+\n * 参数name : Cookie 名称\n\n// 获取名为 userInfo 的 Cookie 对象\nForestCookie cookie = response.getCookie("userInfo");\n// 获取 Cookie 名称\nString name = cookie.getName();\n// 获取 Cookie 值\nString value = cookie.getValue();\n// 获取 Cookie 创建时间\nDate createTime = cookie.getCreateTime();\n// 获取 Cookie 最大有效时长\nDuration duration = cookie.getMaxAge();\n// 获取 Cookie 所在域名\nString domain = cookie.getDomain();\n// 获取 Cookie 所在路径\nString path = cookie.getPath();\n// 是否仅限HTTPS\nboolean bSecure = cookie.isSecure();\n// 是否仅限HTTP方式读取\nboolean bHttpOnly = cookie.isHttpOnly();\n// 是否持久化\nboolean bPersistent = cookie.isPersistent(); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 获取所有 Cookie\n\ngetCookies() : 从响应头中获取所有的 Cookie 对象列表\n\n * 版本 : v1.5.23+\n * 参数name : Cookie 名称\n * 返回值 : Cookie 对象列表\n\n// 获取所有的 Cookie 对象列表\nList<ForestCookie> cookies = response.getCookies();\nfor (ForestCookie cookie : cookies) {\n    // 获取 Cookie 名称\n    String name = cookie.getName();\n    // 获取 Cookie 值\n    String value = cookie.getValue();\n    // 获取 Cookie 创建时间\n    Date createTime = cookie.getCreateTime();\n    // 获取 Cookie 最大有效时长\n    Duration duration = cookie.getMaxAge();\n    // 获取 Cookie 所在域名\n    String domain = cookie.getDomain();\n    // 获取 Cookie 所在路径\n    String path = cookie.getPath();\n    // 是否仅限HTTPS\n    boolean bSecure = cookie.isSecure();\n    // 是否仅限HTTP方式读取\n    boolean bHttpOnly = cookie.isHttpOnly();\n    // 是否持久化\n    boolean bPersistent = cookie.isPersistent();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'# set-cookie 响应头\n\ncookie 在本质上是通过http请求的请求头和响应头进行传输和交互的\n\n而服务端发起的设置 cookie 命令，是通过名为set-cookie的响应头传回给客户端的\n\n所以可以通过set-cookie的响应头来或许 cookie 信息\n\n// 通过 set-cookie 响应头获取 cookie 信息\nstring cookievalue = response.getheadervalue("set-cookie");\n// 解析 cookie 信息\n\n\n1\n2\n3\n\n\n但这么做的弊端就是需要自己手动解析 cookie 信息，十分不便\n\n\n# 获取 cookie 对象\n\nforestresponse 对象提供了直接获取解析后的 cookie 对象的方法\n\ngetcookie(string name) : 根据cookie名称获取cookie\n\n * 版本 : v1.5.23+\n * 参数name : cookie 名称\n\n// 获取名为 userinfo 的 cookie 对象\nforestcookie cookie = response.getcookie("userinfo");\n// 获取 cookie 名称\nstring name = cookie.getname();\n// 获取 cookie 值\nstring value = cookie.getvalue();\n// 获取 cookie 创建时间\ndate createtime = cookie.getcreatetime();\n// 获取 cookie 最大有效时长\nduration duration = cookie.getmaxage();\n// 获取 cookie 所在域名\nstring domain = cookie.getdomain();\n// 获取 cookie 所在路径\nstring path = cookie.getpath();\n// 是否仅限https\nboolean bsecure = cookie.issecure();\n// 是否仅限http方式读取\nboolean bhttponly = cookie.ishttponly();\n// 是否持久化\nboolean bpersistent = cookie.ispersistent(); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 获取所有 cookie\n\ngetcookies() : 从响应头中获取所有的 cookie 对象列表\n\n * 版本 : v1.5.23+\n * 参数name : cookie 名称\n * 返回值 : cookie 对象列表\n\n// 获取所有的 cookie 对象列表\nlist<forestcookie> cookies = response.getcookies();\nfor (forestcookie cookie : cookies) {\n    // 获取 cookie 名称\n    string name = cookie.getname();\n    // 获取 cookie 值\n    string value = cookie.getvalue();\n    // 获取 cookie 创建时间\n    date createtime = cookie.getcreatetime();\n    // 获取 cookie 最大有效时长\n    duration duration = cookie.getmaxage();\n    // 获取 cookie 所在域名\n    string domain = cookie.getdomain();\n    // 获取 cookie 所在路径\n    string path = cookie.getpath();\n    // 是否仅限https\n    boolean bsecure = cookie.issecure();\n    // 是否仅限http方式读取\n    boolean bhttponly = cookie.ishttponly();\n    // 是否持久化\n    boolean bpersistent = cookie.ispersistent();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🍹 配置属性引用",frontmatter:{id:"refer_prop",title:"🍹 配置属性引用",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/refer_prop/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/002.refer_prop.html",relativePath:"001.v1.5.x文档/060.模板表达式/002.refer_prop.md",key:"v-e355a5c4",path:"/pages/1.5.x/refer_prop/",headersStr:null,content:'自 1.5.3 版本起，Forest 支持在模板表达式中直接引用 Properties 配置中的任意属性值\n\n语法格式: 使用井号字符#跟一对花括号{}形式，将变量名包裹起来，如 #{username}\n\n引用的配置属性可以是来自yaml文件中\n\nmydata:\n    username: foo\n    password: bar\n\n\n1\n2\n3\n\n\n或是properties文件中\n\nmydata.username=foo\nmydata.password=bar\n\n\n1\n2\n\n\n然后就可以在注解的属性中直接引用了\n\n@Get(url = "http://localhost:8080/?u=#{mydata.username}&pwd=#{mydata.password}")\nString getData();\n\n// 产生URL:\n// http://localhost:8080/?u=foo&pwd=bar\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'自 1.5.3 版本起，forest 支持在模板表达式中直接引用 properties 配置中的任意属性值\n\n语法格式: 使用井号字符#跟一对花括号{}形式，将变量名包裹起来，如 #{username}\n\n引用的配置属性可以是来自yaml文件中\n\nmydata:\n    username: foo\n    password: bar\n\n\n1\n2\n3\n\n\n或是properties文件中\n\nmydata.username=foo\nmydata.password=bar\n\n\n1\n2\n\n\n然后就可以在注解的属性中直接引用了\n\n@get(url = "http://localhost:8080/?u=#{mydata.username}&pwd=#{mydata.password}")\nstring getdata();\n\n// 产生url:\n// http://localhost:8080/?u=foo&pwd=bar\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🍬 Hello World",frontmatter:{id:"hello_world",hide_title:!0,title:"🍬 Hello World",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/hello_world/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/001.hello_world.html",relativePath:"001.v1.5.x文档/060.模板表达式/001.hello_world.md",key:"v-9669bccc",path:"/pages/1.5.x/hello_world/",headers:[{level:2,title:"模板表达式",slug:"模板表达式",normalizedTitle:"模板表达式",charIndex:2},{level:3,title:"表达式Hello World",slug:"表达式hello-world",normalizedTitle:"表达式hello world",charIndex:138},{level:2,title:"{表达式} 与 ${表达式}",slug:"表达式-与-表达式",normalizedTitle:"{表达式} 与 ${表达式}",charIndex:678},{level:3,title:"{表达式}代表一个Query参数",slug:"表达式-代表一个query参数",normalizedTitle:"{表达式}代表一个query参数",charIndex:697},{level:3,title:"${表达式}可以包含多个Query参数",slug:"表达式-可以包含多个query参数",normalizedTitle:"${表达式}可以包含多个query参数",charIndex:1057},{level:3,title:"推荐使用{表达式}作为模板参数",slug:"推荐使用-表达式-作为模板参数",normalizedTitle:"推荐使用{表达式}作为模板参数",charIndex:1406}],headersStr:"模板表达式 表达式Hello World {表达式} 与 ${表达式} {表达式}代表一个Query参数 ${表达式}可以包含多个Query参数 推荐使用{表达式}作为模板参数",content:'# 模板表达式\n\n在@Request的各大属性中大多数都是用String字符串填值的，如果要在这些字符串属性中动态地关联参数数据，用Java原生字符串连接(如+)是不行的，而且也不够直观。\n\n所以Forest为了帮助您参数数据动态绑定到这些属性上，提供了模板表达式。\n\n\n# 表达式Hello World\n\nForest的模板表达式是在普通的Java字符串中嵌入{表达式}来实现字符串和数据的动态绑定。\n\n嵌入的表达式由左花括号{开始，到右花括号}结束，在两边花括号中间填写的内容是表达式的本体。\n\n最简单的表达式可以是一个@Var标注的变量名，或是一个全局配置中定义的全局变量名。\n\n让我们来看一个最简单的模板表达式Hello World的例子吧\n\n@Request(url = "http://localhost:8080/hello/{name}")\nString send(@Var("name") String name);\n\n\n1\n2\n\n\n若在调用send方法时传入参数为"world"，那么这时被表达式绑定url属性则会变成：\n\nhttp://localhost:8080/hello/world\n\n\n也可以嵌入${表达式}这种以美元符号($)开始，再由左花括号{开始，到右花括号}结束的字符串模板形式\n\n@Request(url = "http://localhost:8080/hello/${name}")\nString send(@Var("name") String name);\n\n\n1\n2\n\n\n调用后效果和上面例子一样\n\n\n# {表达式} 与 ${表达式}\n\n\n# {表达式}代表一个Query参数\n\n{表达式}模板参数，在?a={a}的情况下，会被认为是一个Query参数，即便变量可能包含"1&x=10&y=20"这样多个参数的字符串，也会被转义成一个Query参数\n\n@Get("http://localhost/data?a={a}&b={b}")\nString getData(@Var("a") String a, @Var("b") String b)\n\n\n1\n2\n\n\n// 最终产生的URL是\n// http://localhost/data?a=1%26x%3D10%26y%3D20&b=hello\n// 也就是只会有 a 和 b 两个Query参数\nmyClient.getData("1&x=10&y=20", "hello");\n\n\n1\n2\n3\n4\n\n\n\n# ${表达式}可以包含多个Query参数\n\n而 ${表达式}模板参数，可以认为是一种字符串替换，替换完再对URL参数进行解析，所以一个模板参数引用的变量中可能包含多个参数，也会被解析成多个参数\n\n@Get("http://localhost/data?a=${a}&b=${b}")\nString getData(@Var("a") String a, @Var("b") String b)\n\n\n1\n2\n\n\n// 最终产生的URL是\n// http://localhost/data?a=1&x=10&y=20&b=hello\n// 也就是只会有 a、x、y、b 四个Query参数\nmyClient.getData("1&x=10&y=20", "hello");\n\n\n1\n2\n3\n4\n\n\n\n# 推荐使用{表达式}作为模板参数\n\n基于这两种模板参数各自的特性，都各有各的用处，但一般情况下，推荐使用{表达式}\n\n因为它更结构化、更语义化，也更容易让人理解，不容易出错，尤其是在URL参数中传递另一个URL地址时的作用更为突出\n\n比如，要传一个带参数的子URL：https://search.gitee.com/?type=repository&q=forest\n\n接到父URL后为 http://localhost/data?call={url}\n\n如果是用${url}就会出问题\n\n@Get("/data?call=${url}")\nString getData(@Var("url") String url);\n\n// 最后产生的URL是\n// http://localhost/data?call=https://search.gitee.com/?type=repository&q=forest\n\n\n1\n2\n3\n4\n5\n\n\n咋看起来没错，但最后那部分&q=forest会被认为是父URL的Query参数，但其实应该是子URL的\n\n如果用 {url} 就没这个问题，即使后来再有其它参数也毫无问题\n\n@Get("/data?call={url}&x={x}")\nString getData(@Var("url") String url, @Var("x") String x);\n\n// 最后产生的URL是\n// http://localhost/data?call=https://search.gitee.com/?type=repository%26q=forest&x=xxx\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，子URL中Query参数的连接符&被转义了，这样就解决了子URL参数和父URL参数(如后面的x)之间产生的歧义',normalizedContent:'# 模板表达式\n\n在@request的各大属性中大多数都是用string字符串填值的，如果要在这些字符串属性中动态地关联参数数据，用java原生字符串连接(如+)是不行的，而且也不够直观。\n\n所以forest为了帮助您参数数据动态绑定到这些属性上，提供了模板表达式。\n\n\n# 表达式hello world\n\nforest的模板表达式是在普通的java字符串中嵌入{表达式}来实现字符串和数据的动态绑定。\n\n嵌入的表达式由左花括号{开始，到右花括号}结束，在两边花括号中间填写的内容是表达式的本体。\n\n最简单的表达式可以是一个@var标注的变量名，或是一个全局配置中定义的全局变量名。\n\n让我们来看一个最简单的模板表达式hello world的例子吧\n\n@request(url = "http://localhost:8080/hello/{name}")\nstring send(@var("name") string name);\n\n\n1\n2\n\n\n若在调用send方法时传入参数为"world"，那么这时被表达式绑定url属性则会变成：\n\nhttp://localhost:8080/hello/world\n\n\n也可以嵌入${表达式}这种以美元符号($)开始，再由左花括号{开始，到右花括号}结束的字符串模板形式\n\n@request(url = "http://localhost:8080/hello/${name}")\nstring send(@var("name") string name);\n\n\n1\n2\n\n\n调用后效果和上面例子一样\n\n\n# {表达式} 与 ${表达式}\n\n\n# {表达式}代表一个query参数\n\n{表达式}模板参数，在?a={a}的情况下，会被认为是一个query参数，即便变量可能包含"1&x=10&y=20"这样多个参数的字符串，也会被转义成一个query参数\n\n@get("http://localhost/data?a={a}&b={b}")\nstring getdata(@var("a") string a, @var("b") string b)\n\n\n1\n2\n\n\n// 最终产生的url是\n// http://localhost/data?a=1%26x%3d10%26y%3d20&b=hello\n// 也就是只会有 a 和 b 两个query参数\nmyclient.getdata("1&x=10&y=20", "hello");\n\n\n1\n2\n3\n4\n\n\n\n# ${表达式}可以包含多个query参数\n\n而 ${表达式}模板参数，可以认为是一种字符串替换，替换完再对url参数进行解析，所以一个模板参数引用的变量中可能包含多个参数，也会被解析成多个参数\n\n@get("http://localhost/data?a=${a}&b=${b}")\nstring getdata(@var("a") string a, @var("b") string b)\n\n\n1\n2\n\n\n// 最终产生的url是\n// http://localhost/data?a=1&x=10&y=20&b=hello\n// 也就是只会有 a、x、y、b 四个query参数\nmyclient.getdata("1&x=10&y=20", "hello");\n\n\n1\n2\n3\n4\n\n\n\n# 推荐使用{表达式}作为模板参数\n\n基于这两种模板参数各自的特性，都各有各的用处，但一般情况下，推荐使用{表达式}\n\n因为它更结构化、更语义化，也更容易让人理解，不容易出错，尤其是在url参数中传递另一个url地址时的作用更为突出\n\n比如，要传一个带参数的子url：https://search.gitee.com/?type=repository&q=forest\n\n接到父url后为 http://localhost/data?call={url}\n\n如果是用${url}就会出问题\n\n@get("/data?call=${url}")\nstring getdata(@var("url") string url);\n\n// 最后产生的url是\n// http://localhost/data?call=https://search.gitee.com/?type=repository&q=forest\n\n\n1\n2\n3\n4\n5\n\n\n咋看起来没错，但最后那部分&q=forest会被认为是父url的query参数，但其实应该是子url的\n\n如果用 {url} 就没这个问题，即使后来再有其它参数也毫无问题\n\n@get("/data?call={url}&x={x}")\nstring getdata(@var("url") string url, @var("x") string x);\n\n// 最后产生的url是\n// http://localhost/data?call=https://search.gitee.com/?type=repository%26q=forest&x=xxx\n\n\n1\n2\n3\n4\n5\n\n\n可以看到，子url中query参数的连接符&被转义了，这样就解决了子url参数和父url参数(如后面的x)之间产生的歧义',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🥃 动态变量绑定",frontmatter:{id:"binding_var",title:"🥃 动态变量绑定",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/binding_var/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/003.binding_var.html",relativePath:"001.v1.5.x文档/060.模板表达式/003.binding_var.md",key:"v-41fb2586",path:"/pages/1.5.x/binding_var/",headers:[{level:2,title:"静态变量绑定",slug:"静态变量绑定",normalizedTitle:"静态变量绑定",charIndex:126},{level:2,title:"动态变量绑定",slug:"动态变量绑定",normalizedTitle:"动态变量绑定",charIndex:141},{level:2,title:"@BindingVar注解",slug:"bindingvar注解",normalizedTitle:"@bindingvar注解",charIndex:2626}],headersStr:"静态变量绑定 动态变量绑定 @BindingVar注解",content:'在大部分情况下，变量引用 + 配置文件的方式都可以满足要求，比如：不同环境下配置不同的变量。但如果我想在每次引用变量的时候，都根据某种条件动态获取变量值就办不到了\n\n因此，Forest 在 1.5.3 版本开始，提供了一种动态绑定变量名的技术\n\n\n# 静态变量绑定\n\n在了解什么是 动态变量绑定 之前，先来了解一下什么是 静态变量绑定\n\nForestConfiguration对象提供了setVariableValue方法可以动态设置静态绑定的全局变量值\n\n但该方法设置的值为静态的值，即设置完之后该变量就不会该改变了，所有再次调用 setVariableValue 方法覆盖原来的变量值，所以称为变量的 静态绑定。\n\n> setVariableValue(String name, Object value) 设置全局变量所对应的值\n> \n>  * 参数name: 变量名\n>  * 参数name: 变量值\n\n// 获取 Forest 全局配置对象\nForestConfiguration configuration = Forest.config();\n// 设置全局变量: name -> Peter\nconfiguration.setVariableValue("name", "Peter");\n// 设置全局变量: baseUrl -> http://abc.com\nconfiguration.setVariableValue("baseUrl", "http://abc.com");\n\n\n1\n2\n3\n4\n5\n6\n\n\n此时就能引用到刚才设置的全局变量名了\n\n@Get("${baseUrl}/data?n={name}")\nString getData();\n\n// 调用该方法所产生的URL为\n// http://abc.com/data?n=Peter\n\n\n1\n2\n3\n4\n5\n\n\n\n# 动态变量绑定\n\n动态变量绑定的概念是相对静态变量绑定而来的，静态绑定的变量是一个固定值，即一旦设置完之后，就不会再做改变，每次引用到同一个变量名的值都是相同的，除非将变量名重新设值，覆盖掉原来的值。\n\n而动态绑定的变量尤其说是变量，其实更接近于函数或者方法，即每次引用一个变量名的时候都会重新计算其变量值，相当于调用一次方法，而它的返回值即为变量名所对应的值。\n\n上面介绍过的ForestConfiguration对象的setVariableValue方法的兄弟方法（重载方法）可以动态设置动态绑定的全局变量值\n\n> setVariableValue(String name, ForestVariableValue value)\n> \n>  * 参数name: 变量名\n>  * 参数value: 变量值，ForestVariableValue接口的实现类\n\n欸，我们发现，这里的value是一个接口类的实例对象，这个接口本质上可以看成一个Lambda\n\n// 获取 Forest 全局配置对象\nForestConfiguration configuration = Forest.config();\n// 定义一个原子整数对象\nAtomicInteger count = new AtomicInteger(0);\n// 设置全局动态变量: num -> 从0开始记，每次引用加一的值\nconfiguration.setVariableValue("num", (method) -> count.getAndIncrement());\n\n\n1\n2\n3\n4\n5\n6\n\n\n此时就能引用到刚才设置的全局动态变量名了\n\n@Get("/data?num={num}")\nString getData();\n\n\n1\n2\n\n\n然后，多次调用该方法，所产生的结果都是不同的 (每次都累加一)\n\nmyClient.getData(); // 第一次调用，URL: http://localhost/data?num=0\nmyClient.getData(); // 第二次调用，URL: http://localhost/data?num=1\nmyClient.getData(); // 第三次调用，URL: http://localhost/data?num=2\n\n\n1\n2\n3\n\n\nForestVariableValue接口的 Lambda 带有一个参数 method, 它是 ForestMethod 类型的对象，即 Forest 接口方法对象\n\nForestConfiguration configuration = Forest.config();\n// 设置全局动态变量: baseUrl -> 根据条件产生不同的IP地址\nconfiguration.setVariableValue("num", (method) -> {\n    // method: Forest 接口方法对象，即对请求所对应的方法的封装对象\n    // method.getMethodName() 获得请求所对应的方法的方法名\n    String methodName = method.getMethodName();\n    if (methodName.equals("getData")) {\n        // 若调用的是 getData 方法，则返回 192.168.0.2\n        return "192.168.0.2";\n    }\n    // 默认返回 192.168.0.1\n    return "192.168.0.1";\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n引用该 baseUrl 变量\n\n@Get("{baseUrl}/data")\nString getData();\n\n@Get("{baseUrl}/user")\nString getUser();\n\n\n1\n2\n3\n4\n5\n\n\n调用不同方法产生的结果\n\nmyClient.getData(); // 调用getData，URL: http://192.168.0.2/data\nmyClient.getUser(); // 调用getUser，URL: http://192.168.0.1/user\n\n\n1\n2\n\n\n\n# @BindingVar注解\n\n还有一种更方便的声名式动态绑定变量的办法，就是在 Spring 环境下利用 @BindingVar 注解修饰某个在 Spring 上下文的 Bean 的方法\n\n@Service("myService")\npublic class MyService {\n    // 定义一个原子整数对象\n    private AtomicInteger count = new AtomicInteger(0); \n\n    /**\n     * 使用 @BindingVar 注解\n     * 将变量名 num 和一段方法代码绑定\n     * 方法的参数可以忽略不定义\n     * 每次引用 num 变量，都会调用该方法重算出该值\n     */\n    @BindingVar("num")\n    public int getNum() {\n        // 返回原子整数的值，每次调用加一\n        return count.getAndIncrement();\n    }\n    \n    /**\n     * 使用 @BindingVar 注解\n     * 将变量名 baseUrl 和一段方法代码绑定\n     * 该方法可以有一个 ForestMethod 类型的参数\n     */\n    @BindingVar("baseUrl")\n    public String getBaseUrl(ForestMethod method) {\n        // method: Forest 接口方法对象，即对请求所对应的方法的封装对象\n        // method.getMethodName() 获得请求所对应的方法的方法名\n        String methodName = method.getMethodName();\n        if (methodName.equals("getData")) {\n            // 若调用的是 getData 方法，则返回 192.168.0.2\n            return "192.168.0.2";\n        }\n        // 默认返回 192.168.0.1\n        return "192.168.0.1";\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n此时就能引用到刚才设置的全局动态变量名了\n\n@Get("{baseUrl}/data?num={num}")\nString getData();\n\n@Get("{baseUrl}/user?num={num}")\nString getUser();\n\n\n1\n2\n3\n4\n5\n\n\n然后，多次调用该方法，所产生的结果都是不同的 (每次都累加一)\n\nmyClient.getData(); // 第一次调用，URL: http://192.168.0.2/data?num=0\nmyClient.getData(); // 第二次调用，URL: http://192.168.0.2/data?num=1\nmyClient.getData(); // 第三次调用，URL: http://192.168.0.2/data?num=2\n\nmyClient.getUser(); // 调用另一个方法，URL: http://192.168.0.1/data?num=3\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'在大部分情况下，变量引用 + 配置文件的方式都可以满足要求，比如：不同环境下配置不同的变量。但如果我想在每次引用变量的时候，都根据某种条件动态获取变量值就办不到了\n\n因此，forest 在 1.5.3 版本开始，提供了一种动态绑定变量名的技术\n\n\n# 静态变量绑定\n\n在了解什么是 动态变量绑定 之前，先来了解一下什么是 静态变量绑定\n\nforestconfiguration对象提供了setvariablevalue方法可以动态设置静态绑定的全局变量值\n\n但该方法设置的值为静态的值，即设置完之后该变量就不会该改变了，所有再次调用 setvariablevalue 方法覆盖原来的变量值，所以称为变量的 静态绑定。\n\n> setvariablevalue(string name, object value) 设置全局变量所对应的值\n> \n>  * 参数name: 变量名\n>  * 参数name: 变量值\n\n// 获取 forest 全局配置对象\nforestconfiguration configuration = forest.config();\n// 设置全局变量: name -> peter\nconfiguration.setvariablevalue("name", "peter");\n// 设置全局变量: baseurl -> http://abc.com\nconfiguration.setvariablevalue("baseurl", "http://abc.com");\n\n\n1\n2\n3\n4\n5\n6\n\n\n此时就能引用到刚才设置的全局变量名了\n\n@get("${baseurl}/data?n={name}")\nstring getdata();\n\n// 调用该方法所产生的url为\n// http://abc.com/data?n=peter\n\n\n1\n2\n3\n4\n5\n\n\n\n# 动态变量绑定\n\n动态变量绑定的概念是相对静态变量绑定而来的，静态绑定的变量是一个固定值，即一旦设置完之后，就不会再做改变，每次引用到同一个变量名的值都是相同的，除非将变量名重新设值，覆盖掉原来的值。\n\n而动态绑定的变量尤其说是变量，其实更接近于函数或者方法，即每次引用一个变量名的时候都会重新计算其变量值，相当于调用一次方法，而它的返回值即为变量名所对应的值。\n\n上面介绍过的forestconfiguration对象的setvariablevalue方法的兄弟方法（重载方法）可以动态设置动态绑定的全局变量值\n\n> setvariablevalue(string name, forestvariablevalue value)\n> \n>  * 参数name: 变量名\n>  * 参数value: 变量值，forestvariablevalue接口的实现类\n\n欸，我们发现，这里的value是一个接口类的实例对象，这个接口本质上可以看成一个lambda\n\n// 获取 forest 全局配置对象\nforestconfiguration configuration = forest.config();\n// 定义一个原子整数对象\natomicinteger count = new atomicinteger(0);\n// 设置全局动态变量: num -> 从0开始记，每次引用加一的值\nconfiguration.setvariablevalue("num", (method) -> count.getandincrement());\n\n\n1\n2\n3\n4\n5\n6\n\n\n此时就能引用到刚才设置的全局动态变量名了\n\n@get("/data?num={num}")\nstring getdata();\n\n\n1\n2\n\n\n然后，多次调用该方法，所产生的结果都是不同的 (每次都累加一)\n\nmyclient.getdata(); // 第一次调用，url: http://localhost/data?num=0\nmyclient.getdata(); // 第二次调用，url: http://localhost/data?num=1\nmyclient.getdata(); // 第三次调用，url: http://localhost/data?num=2\n\n\n1\n2\n3\n\n\nforestvariablevalue接口的 lambda 带有一个参数 method, 它是 forestmethod 类型的对象，即 forest 接口方法对象\n\nforestconfiguration configuration = forest.config();\n// 设置全局动态变量: baseurl -> 根据条件产生不同的ip地址\nconfiguration.setvariablevalue("num", (method) -> {\n    // method: forest 接口方法对象，即对请求所对应的方法的封装对象\n    // method.getmethodname() 获得请求所对应的方法的方法名\n    string methodname = method.getmethodname();\n    if (methodname.equals("getdata")) {\n        // 若调用的是 getdata 方法，则返回 192.168.0.2\n        return "192.168.0.2";\n    }\n    // 默认返回 192.168.0.1\n    return "192.168.0.1";\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n引用该 baseurl 变量\n\n@get("{baseurl}/data")\nstring getdata();\n\n@get("{baseurl}/user")\nstring getuser();\n\n\n1\n2\n3\n4\n5\n\n\n调用不同方法产生的结果\n\nmyclient.getdata(); // 调用getdata，url: http://192.168.0.2/data\nmyclient.getuser(); // 调用getuser，url: http://192.168.0.1/user\n\n\n1\n2\n\n\n\n# @bindingvar注解\n\n还有一种更方便的声名式动态绑定变量的办法，就是在 spring 环境下利用 @bindingvar 注解修饰某个在 spring 上下文的 bean 的方法\n\n@service("myservice")\npublic class myservice {\n    // 定义一个原子整数对象\n    private atomicinteger count = new atomicinteger(0); \n\n    /**\n     * 使用 @bindingvar 注解\n     * 将变量名 num 和一段方法代码绑定\n     * 方法的参数可以忽略不定义\n     * 每次引用 num 变量，都会调用该方法重算出该值\n     */\n    @bindingvar("num")\n    public int getnum() {\n        // 返回原子整数的值，每次调用加一\n        return count.getandincrement();\n    }\n    \n    /**\n     * 使用 @bindingvar 注解\n     * 将变量名 baseurl 和一段方法代码绑定\n     * 该方法可以有一个 forestmethod 类型的参数\n     */\n    @bindingvar("baseurl")\n    public string getbaseurl(forestmethod method) {\n        // method: forest 接口方法对象，即对请求所对应的方法的封装对象\n        // method.getmethodname() 获得请求所对应的方法的方法名\n        string methodname = method.getmethodname();\n        if (methodname.equals("getdata")) {\n            // 若调用的是 getdata 方法，则返回 192.168.0.2\n            return "192.168.0.2";\n        }\n        // 默认返回 192.168.0.1\n        return "192.168.0.1";\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n此时就能引用到刚才设置的全局动态变量名了\n\n@get("{baseurl}/data?num={num}")\nstring getdata();\n\n@get("{baseurl}/user?num={num}")\nstring getuser();\n\n\n1\n2\n3\n4\n5\n\n\n然后，多次调用该方法，所产生的结果都是不同的 (每次都累加一)\n\nmyclient.getdata(); // 第一次调用，url: http://192.168.0.2/data?num=0\nmyclient.getdata(); // 第二次调用，url: http://192.168.0.2/data?num=1\nmyclient.getdata(); // 第三次调用，url: http://192.168.0.2/data?num=2\n\nmyclient.getuser(); // 调用另一个方法，url: http://192.168.0.1/data?num=3\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🥗 参数序号引用",frontmatter:{id:"refer_index",title:"🥗 参数序号引用",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/refer_index/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/004.refer_index.html",relativePath:"001.v1.5.x文档/060.模板表达式/004.refer_index.md",key:"v-78153190",path:"/pages/1.5.x/refer_index/",headers:[{level:3,title:"简化与非简化",slug:"简化与非简化",normalizedTitle:"简化与非简化",charIndex:958},{level:3,title:"参数序号总结",slug:"参数序号总结",normalizedTitle:"参数序号总结",charIndex:1350}],headersStr:"简化与非简化 参数序号总结",content:'直接在${}或{}中填入从0开始的数字，其中的数字代表方法参数的序号，比如{0}代表方法的第一个参数，{1}代表第二个参数，第n个参数引用用{n-1}表示（这里的n是数字，并不是变量名）\n\n友情提示\n\n代表参数序号的数字只能是整数，不能是小数，并且不能是负数。\n\n@Request(url = "http://localhost:8080/hello?p1={0}&p2={1}&p3={2}")\nString send(int a, int b, int c);\n\n\n1\n2\n\n\n如调用send()方法并传入参数 3, 6, 9, 那么产生的url值就是\n\nhttp://localhost:8080/hello?p1=3&p2=6&p3=9\n\n\n以上这种{数字}的形式是参数序号的简化语法，而有时候{表达式}中的数字如果和其它表达式结合起来参与计算，那此时它就不代表数字所对应的参数了，而只是纯粹的数字。如一下例子：\n\n@Request(url = "http://localhost:8080/hello?p1={0.toString()}")\nString send(int num);\n\n\n1\n2\n\n\n如果此时调用方法send(100)，那么产生的url将是：\n\nhttp://localhost:8080/hello?p1=0\n\n\n提示\n\n这里使用了模板表达式的方法调用语法\n\n这时{}中的0代表的并不是参数num的值，而仅仅就是数字0，作为被调用toString()方法的整数对象。\n\n若想此时也引用参数序号传入参数num的值，并且也参与toString()方法调用的运算，也是有办法的。\n\n这时就要用到参数序号的非简化语法$ + 非负整数了。\n\n@Request(url = "http://localhost:8080/hello?p1={$0.toString()}")\nString send(int num);\n\n\n1\n2\n\n\n如果此时调用方法send(100)，那么产生的url将是：\n\nhttp://localhost:8080/hello?p1=100\n\n\n这时我们所看到{$0.toString()}就我们所期望的num参数经过调用toString()方法最终返回的结果了。\n\n\n# 简化与非简化\n\n说到这里，可能我们有些小伙伴就凌乱了。什么简化的？非简化的？不都是参数序号吗？怎么又变成数字了呢？\n\n别急，其实要区分什么时候是数字，什么时候是参数序号，以及什么是简化参数序号，什么是非简化参数序号是很简单的，只要记住以下3条规则即可。\n\n>  1. ${}或{}中只包含一个非负整数时，就是参数序号，且是简化形态的。如：{1}, {5}等等。\n> \n>  2. ${}或{}中不只包含一个数字，还有其它东西存在时，那此时里面的数字都只是数字。如{1.toString()}, {json(0)}等等。\n> \n>  3. ${}或{}中的非负整数以$符号开头，那它就是一个参数序号（非简化的），不管{}中只有一个还是有多个都是。如{$1}, {json($0)}, $3.compareTo($2)\n\n注意\n\n还有不要忘了参数序号只能是整数，并且不能是负的。\n\n\n# 参数序号总结\n\n用参数序号方式比变量名方式更为简洁，因为不用定义@Var注解，也不用引用冗长的变量名，是目前比较推荐的引用方式。\n\n不过它也有缺点，就是在参数较多的时候较难立刻对应起来，不够直观，比较影响代码可读性。所以还请根据场景和入参的多寡来决定用哪种引用方式。',normalizedContent:'直接在${}或{}中填入从0开始的数字，其中的数字代表方法参数的序号，比如{0}代表方法的第一个参数，{1}代表第二个参数，第n个参数引用用{n-1}表示（这里的n是数字，并不是变量名）\n\n友情提示\n\n代表参数序号的数字只能是整数，不能是小数，并且不能是负数。\n\n@request(url = "http://localhost:8080/hello?p1={0}&p2={1}&p3={2}")\nstring send(int a, int b, int c);\n\n\n1\n2\n\n\n如调用send()方法并传入参数 3, 6, 9, 那么产生的url值就是\n\nhttp://localhost:8080/hello?p1=3&p2=6&p3=9\n\n\n以上这种{数字}的形式是参数序号的简化语法，而有时候{表达式}中的数字如果和其它表达式结合起来参与计算，那此时它就不代表数字所对应的参数了，而只是纯粹的数字。如一下例子：\n\n@request(url = "http://localhost:8080/hello?p1={0.tostring()}")\nstring send(int num);\n\n\n1\n2\n\n\n如果此时调用方法send(100)，那么产生的url将是：\n\nhttp://localhost:8080/hello?p1=0\n\n\n提示\n\n这里使用了模板表达式的方法调用语法\n\n这时{}中的0代表的并不是参数num的值，而仅仅就是数字0，作为被调用tostring()方法的整数对象。\n\n若想此时也引用参数序号传入参数num的值，并且也参与tostring()方法调用的运算，也是有办法的。\n\n这时就要用到参数序号的非简化语法$ + 非负整数了。\n\n@request(url = "http://localhost:8080/hello?p1={$0.tostring()}")\nstring send(int num);\n\n\n1\n2\n\n\n如果此时调用方法send(100)，那么产生的url将是：\n\nhttp://localhost:8080/hello?p1=100\n\n\n这时我们所看到{$0.tostring()}就我们所期望的num参数经过调用tostring()方法最终返回的结果了。\n\n\n# 简化与非简化\n\n说到这里，可能我们有些小伙伴就凌乱了。什么简化的？非简化的？不都是参数序号吗？怎么又变成数字了呢？\n\n别急，其实要区分什么时候是数字，什么时候是参数序号，以及什么是简化参数序号，什么是非简化参数序号是很简单的，只要记住以下3条规则即可。\n\n>  1. ${}或{}中只包含一个非负整数时，就是参数序号，且是简化形态的。如：{1}, {5}等等。\n> \n>  2. ${}或{}中不只包含一个数字，还有其它东西存在时，那此时里面的数字都只是数字。如{1.tostring()}, {json(0)}等等。\n> \n>  3. ${}或{}中的非负整数以$符号开头，那它就是一个参数序号（非简化的），不管{}中只有一个还是有多个都是。如{$1}, {json($0)}, $3.compareto($2)\n\n注意\n\n还有不要忘了参数序号只能是整数，并且不能是负的。\n\n\n# 参数序号总结\n\n用参数序号方式比变量名方式更为简洁，因为不用定义@var注解，也不用引用冗长的变量名，是目前比较推荐的引用方式。\n\n不过它也有缺点，就是在参数较多的时候较难立刻对应起来，不够直观，比较影响代码可读性。所以还请根据场景和入参的多寡来决定用哪种引用方式。',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🍍 引用对象属性",frontmatter:{id:"refer_attr",title:"🍍 引用对象属性",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/refer_attr/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/005.refer_attr.html",relativePath:"001.v1.5.x文档/060.模板表达式/005.refer_attr.md",key:"v-5b0d2084",path:"/pages/1.5.x/refer_attr/",headersStr:null,content:'模板表达式中除了可以引用变量和参数序号外，还可以引用它们的属性。\n\n属性引用和java以及SpringEL一样，通过在变量名或者参数序号后面跟上点.符号，再加上属性名即可。\n\n@Request(url = "http://localhost:8080/user/{user.username}")\nString getUser(@Var("user") User user);\n\n\n1\n2\n\n\n现在我们调用getUser()方法，并传入一个User类的对象，那么{user.username}得到的结果就是调用user对象的Getter方法getUsername()所得到的值。\n\n模板表达式支持连续的属性引用\n\n@Request(url = "http://localhost:8080/user/phone_number/{user.phone.number}")\nString getUser(@Var("user") User user);\n\n\n1\n2\n\n\n这里${user.phone.number}的结果就相当于调用user.getPhone().getNumber()的结果。',normalizedContent:'模板表达式中除了可以引用变量和参数序号外，还可以引用它们的属性。\n\n属性引用和java以及springel一样，通过在变量名或者参数序号后面跟上点.符号，再加上属性名即可。\n\n@request(url = "http://localhost:8080/user/{user.username}")\nstring getuser(@var("user") user user);\n\n\n1\n2\n\n\n现在我们调用getuser()方法，并传入一个user类的对象，那么{user.username}得到的结果就是调用user对象的getter方法getusername()所得到的值。\n\n模板表达式支持连续的属性引用\n\n@request(url = "http://localhost:8080/user/phone_number/{user.phone.number}")\nstring getuser(@var("user") user user);\n\n\n1\n2\n\n\n这里${user.phone.number}的结果就相当于调用user.getphone().getnumber()的结果。',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🍖 变量引用",frontmatter:{id:"refer_var",title:"🍖 变量引用",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/refer_var/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/007.refer_var.html",relativePath:"001.v1.5.x文档/060.模板表达式/007.refer_var.md",key:"v-3fd0a948",path:"/pages/1.5.x/refer_var/",headersStr:null,content:'模板表达式最原始的目的就是各种各样的数据动态绑定到HTTP请求的各个属性中，要完成这一步就要实现对外部数据的引用。\n\nForest的模板表达式提供了两种最基本的数据引用方式： 变量名引用、参数序号引用\n\n如上面Hello World例子所示，表达式中可以直接引用@Var或 @DataVariable 所标注的变量名。除此之外也可以直接引用全局配置中定义的全局变量名。\n\n全局变量名可以在 yaml 配置文件中定义\n\nforest:\n  variables:\n    a: foo\n    b: bar\n\n\n1\n2\n3\n4\n\n\n也可以在 properties 配置文件中定义\n\nforest.variables.a=foo\nforest.variables.b=bar\n\n\n1\n2\n\n\n注意\n\n无论是yaml配置文件还是properties配置文件，其定义的 Forest 全局变量必须定义在 forest.variables 之下，否则无法被引用到\n\n我们在全局配置中定义了两个全局变量，分别为a和b。接着就可以在@Request中同时引用这两个变量。\n\n@Request(url = "http://localhost:8080/{a}/{b}")\nString send();\n\n\n1\n2\n\n\n调用send()方法后产生的url的值为：\n\nhttp://localhost:8080/foo/bar\n\n\n这里因为是全局变量，{a}和{b}的值分别来自全局配置中的变量a和b的值，也就是foo和bar，所以并不需要在方法中传入额外的参数。\n\n与配置属性引用的异同\n\n 1. 配置属性引用以井号(#)开头，如#{a}。变量引用以花括号包裹或者以美元符号($)开头的花括号包裹，如 {a}、${a}\n 2. 配置属性只是简单的字符串，不能进行后续操作，而变量是可以当作类似java对象进行操作，某方法调用，和子属性访问\n 3. 在配置文件(application.yml 或 application.properties)中定义的变量，必须在forest.variables下，否则引用不到',normalizedContent:'模板表达式最原始的目的就是各种各样的数据动态绑定到http请求的各个属性中，要完成这一步就要实现对外部数据的引用。\n\nforest的模板表达式提供了两种最基本的数据引用方式： 变量名引用、参数序号引用\n\n如上面hello world例子所示，表达式中可以直接引用@var或 @datavariable 所标注的变量名。除此之外也可以直接引用全局配置中定义的全局变量名。\n\n全局变量名可以在 yaml 配置文件中定义\n\nforest:\n  variables:\n    a: foo\n    b: bar\n\n\n1\n2\n3\n4\n\n\n也可以在 properties 配置文件中定义\n\nforest.variables.a=foo\nforest.variables.b=bar\n\n\n1\n2\n\n\n注意\n\n无论是yaml配置文件还是properties配置文件，其定义的 forest 全局变量必须定义在 forest.variables 之下，否则无法被引用到\n\n我们在全局配置中定义了两个全局变量，分别为a和b。接着就可以在@request中同时引用这两个变量。\n\n@request(url = "http://localhost:8080/{a}/{b}")\nstring send();\n\n\n1\n2\n\n\n调用send()方法后产生的url的值为：\n\nhttp://localhost:8080/foo/bar\n\n\n这里因为是全局变量，{a}和{b}的值分别来自全局配置中的变量a和b的值，也就是foo和bar，所以并不需要在方法中传入额外的参数。\n\n与配置属性引用的异同\n\n 1. 配置属性引用以井号(#)开头，如#{a}。变量引用以花括号包裹或者以美元符号($)开头的花括号包裹，如 {a}、${a}\n 2. 配置属性只是简单的字符串，不能进行后续操作，而变量是可以当作类似java对象进行操作，某方法调用，和子属性访问\n 3. 在配置文件(application.yml 或 application.properties)中定义的变量，必须在forest.variables下，否则引用不到',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🥝 调用对象方法",frontmatter:{id:"invoke",title:"🥝 调用对象方法",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/invoke/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/060.%E6%A8%A1%E6%9D%BF%E8%A1%A8%E8%BE%BE%E5%BC%8F/006.invoke.html",relativePath:"001.v1.5.x文档/060.模板表达式/006.invoke.md",key:"v-0015b6de",path:"/pages/1.5.x/invoke/",headersStr:null,content:'既然模板表示能支持对象属性的引用，那也支持对象方法的调用吗？答案是肯定的，且调用方法的语法与Java的一致。\n\n@Request(url = "http://localhost:8080/user/phone_number/${user.getUsername()}")\nString getUser(@Var("user") User user);\n\n\n1\n2\n\n\n这里的${user.getUsername()}的运行结果和Java中调用user.getUsername()执行效果是一样的。\n\n此外，模板表达式有个特别的语法，即当调用的方法中没有参数时可以把括号()省去。\n\n@Request(url = "http://localhost:8080/user/phone_number/${user.getUsername}")\nString getUser(@Var("user") User user);\n\n\n1\n2\n\n\n这里的${user.getUsername}和上面的${user.getUsername()}是等价的。\n\n传入参数的形式也和Java中的一样：\n\n@Request(url = "http://localhost:8080/user/phone_number/${user.getPhoneList().get(phoneIndex).getNumber()}")\nString getUser(@Var("user") User user, @Var("phoneIndex") int phoneIndex);\n\n\n1\n2\n\n\n也可以结合参数序号形式：\n\n@Request(url = "http://localhost:8080/user/phone_number/${$0.getPhoneList().get($1).getNumber()}")\nString getUser(User user, int phoneIndex);\n\n\n1\n2\n\n\n结合属性引用，进一步简化：\n\n@Request(url = "http://localhost:8080/user/phone_number/${$0.phoneList.get($1).number}")\nString getUser(User user, int phoneIndex);\n\n\n1\n2\n',normalizedContent:'既然模板表示能支持对象属性的引用，那也支持对象方法的调用吗？答案是肯定的，且调用方法的语法与java的一致。\n\n@request(url = "http://localhost:8080/user/phone_number/${user.getusername()}")\nstring getuser(@var("user") user user);\n\n\n1\n2\n\n\n这里的${user.getusername()}的运行结果和java中调用user.getusername()执行效果是一样的。\n\n此外，模板表达式有个特别的语法，即当调用的方法中没有参数时可以把括号()省去。\n\n@request(url = "http://localhost:8080/user/phone_number/${user.getusername}")\nstring getuser(@var("user") user user);\n\n\n1\n2\n\n\n这里的${user.getusername}和上面的${user.getusername()}是等价的。\n\n传入参数的形式也和java中的一样：\n\n@request(url = "http://localhost:8080/user/phone_number/${user.getphonelist().get(phoneindex).getnumber()}")\nstring getuser(@var("user") user user, @var("phoneindex") int phoneindex);\n\n\n1\n2\n\n\n也可以结合参数序号形式：\n\n@request(url = "http://localhost:8080/user/phone_number/${$0.getphonelist().get($1).getnumber()}")\nstring getuser(user user, int phoneindex);\n\n\n1\n2\n\n\n结合属性引用，进一步简化：\n\n@request(url = "http://localhost:8080/user/phone_number/${$0.phonelist.get($1).number}")\nstring getuser(user user, int phoneindex);\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/07/19, 11:28:31",lastUpdatedTimestamp:1658201311e3},{title:"🥪 拦截器",frontmatter:{id:"interceptor",title:"🥪 拦截器",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/interceptor/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/070.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/001.interceptor.html",relativePath:"001.v1.5.x文档/070.高级特性/001.interceptor.md",key:"v-08061b16",path:"/pages/1.5.x/interceptor/",headers:[{level:3,title:"构建拦截器",slug:"构建拦截器",normalizedTitle:"构建拦截器",charIndex:112},{level:3,title:"拦截器与 Spring 集成",slug:"拦截器与-spring-集成",normalizedTitle:"拦截器与 spring 集成",charIndex:3089},{level:3,title:"在拦截器中传递数据",slug:"在拦截器中传递数据",normalizedTitle:"在拦截器中传递数据",charIndex:3407},{level:3,title:"Attribute",slug:"attribute",normalizedTitle:"attribute",charIndex:697},{level:3,title:"Attachment",slug:"attachment",normalizedTitle:"attachment",charIndex:5452},{level:4,title:"Attribute与Attachment的区别",slug:"attribute与attachment的区别",normalizedTitle:"attribute与attachment的区别",charIndex:6459},{level:3,title:"配置拦截器",slug:"配置拦截器",normalizedTitle:"配置拦截器",charIndex:6606},{level:4,title:"@Request上的拦截器",slug:"request上的拦截器",normalizedTitle:"@request上的拦截器",charIndex:6679},{level:4,title:"@BaseRequest 上的拦截器",slug:"baserequest-上的拦截器",normalizedTitle:"@baserequest 上的拦截器",charIndex:7326},{level:4,title:"全局拦截器",slug:"全局拦截器",normalizedTitle:"全局拦截器",charIndex:8108}],headersStr:"构建拦截器 拦截器与 Spring 集成 在拦截器中传递数据 Attribute Attachment Attribute与Attachment的区别 配置拦截器 @Request上的拦截器 @BaseRequest 上的拦截器 全局拦截器",content:'用过Spring MVC的朋友一定对Spring的拦截器并不陌生，Forest也同样支持针对Forest请求的拦截器。\n\n如果您想在很多个请求发送之前或之后做一些事情（如打印日志、计数等等），拦截器就是您的好帮手。\n\n\n# 构建拦截器\n\n定义一个拦截器需要实现com.dtflys.forest.interceptor.Interceptor接口\n\npublic class SimpleInterceptor<T> implements Interceptor<T> {\n\n    private final static Logger log = LoggerFactory.getLogger(SimpleInterceptor.class);\n\n    /**\n     * 该方法在被调用时，并在beforeExecute前被调用 \n     * @Param request Forest请求对象\n     * @Param args 方法被调用时传入的参数数组 \n     */\n    @Override\n    public void onInvokeMethod(ForestRequest req, ForestMethod method, Object[] args) {\n        log.info("on invoke method");\n        // req 为Forest请求对象，即 ForestRequest 类实例\n        // method 为Forest方法对象，即 ForestMethod 类实例\n        // addAttribute作用是添加和Forest请求对象以及该拦截器绑定的属性\n        addAttribute(req, "A", "value1");\n        addAttribute(req, "B", "value2");\n    }\n\n    /**\n     * 该方法在请求发送之前被调用, 若返回false则不会继续发送请求\n     * @Param request Forest请求对象\n     */\n    @Override\n    public boolean beforeExecute(ForestRequest req) {\n        log.info("invoke Simple beforeExecute");\n        // 执行在发送请求之前处理的代码\n        req.addHeader("accessToken", "11111111");  // 添加Header\n        req.addQuery("username", "foo");  // 添加URL的Query参数\n        return true;  // 继续执行请求返回true\n    }\n\n    /**\n     * 该方法在请求成功响应时被调用\n     */\n    @Override\n    public void onSuccess(T data, ForestRequest req, ForestResponse res) {\n        log.info("invoke Simple onSuccess");\n        // 执行成功接收响应后处理的代码\n        int status = res.getStatusCode(); // 获取请求响应状态码\n        String content = res.getContent(); // 获取请求的响应内容\n        String result = (String)data;  // data参数是方法返回类型对应的返回数据结果,注意需要视情况修改对应的类型否则有可能出现类转型异常\n        result = res.getResult(); // getResult()也可以获取返回的数据结果\n        response.setResult("修改后的结果: " + result);  // 可以修改请求响应的返回数据结果\n        \n        // 使用getAttributeAsString取出属性，这里只能取到与该Forest请求对象，以及该拦截器绑定的属性\n        String attrValue1 = getAttributeAsString(req, "A1");\n\n    }\n\n    /**\n     * 该方法在请求发送失败时被调用\n     */\n    @Override\n    public void onError(ForestRuntimeException ex, ForestRequest req, ForestResponse res) {\n        log.info("invoke Simple onError");\n        // 执行发送请求失败后处理的代码\n        int status = res.getStatusCode(); // 获取请求响应状态码\n        String content = res.getContent(); // 获取请求的响应内容\n        String result = res.getResult(); // 获取方法返回类型对应的返回数据结果\n    }\n\n    /**\n     * 该方法在请求发送之后被调用\n     */\n    @Override\n    public void afterExecute(ForestRequest req, ForestResponse res) {\n        log.info("invoke Simple afterExecute");\n        // 执行在发送请求之后处理的代码\n        int status = res.getStatusCode(); // 获取请求响应状态码\n        String content = res.getContent(); // 获取请求的响应内容\n        String result = res.getResult(); // 获取方法返回类型对应的最终数据结果\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\nInterceptor接口带有一个泛型参数，其表示的是请求响应后返回的数据类型。 Interceptor<String>即代表返回的数据类型为 String。\n\n在拦截器的方法参数中基本都有 ForestRequest 类对象，即Forest请求对象，Forest的绝大部分操作都是围绕请求对象所作的工作。\n\n文档导航\n\n要详细了解 Forest 请求对象如何使用，请参见《请求对象》\n\n\n# 拦截器与 Spring 集成\n\n若我要在拦截器中注入 Spring 的 Bean 改如何做？\n\n\n/**\n * 在拦截器的类上加上@Component注解，并保证它能被Spring扫描到\n */\n@Component\npublic class SimpleInterceptor implements Interceptor<String> {\n\n    // 如此便能直接注入Spring上下文中所有的Bean了\n    @Resouce\n    private UserService userService;\n    \n    ... ...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 在拦截器中传递数据\n\n在Forest中，拦截器是基于单例模式创建的，也就是说一个拦截器类最多只能对应一个拦截器实例。\n\n那么以下这种通过共享变量的方式就可能造成错误：\n\npublic class SimpleInterceptor implements Interceptor<String> {\n  \n    private String name;\n   \n    @Override\n    public boolean beforeExecute(ForestRequest req) {\n        this.name = req.getQuery("name");\n    }\n\n    @Override\n    public void onSuccess(String data, ForestRequest req, ForestResponse res) {\n        System.out.println("name = " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n若有两个请求同时进入该拦截器（请求1 url=...?name=A1, 请求2 url=...?name=A2）, 而最后当请求1进入onSuccess方法时，应该打印出 name = A2，却因为之前执行了请求2的beforeExecute方法，将类变量name的值改成了A2, 所以最终打印出来的是 name = A2 （其实应该是 name = A1），这明显是错误的。\n\n那该如何做能在传递数据的同时避免这类问题呢？\n\n方法也很简单，就是将您要传递的数据与请求对象绑定在一起，比如在 onSuccess 中调用req.getQuery方法。\n\nSystem.out.println("name = " + forest.getQuery("name"));\n\n\n1\n\n\n虽然这种方法能够解决并发问题，但有个明显的限制：如果要传递的数据不想出现在请求中的任何位置(包括URL、请求头、请求体)，那就无能为力了。\n\n这时候就要使用 ForestRequest 的扩展绑定数据的方法了。\n\n\n# Attribute\n\n在拦截器中使用addAttribute方法和getAttribute方法来添加和获取Attribute。\n\nAttribute 是和请求以及所在拦截器绑定的属性值，这些属性值不能通过网络请求传递到远端服务器。\n\n而且，在使用getAttribute方法时，只能获取在相同拦截器，以及相同请求中绑定的Attribute，这两个条件缺一不可。\n\npublic class SimpleInterceptor implements Interceptor<String> {\n  \n    @Override\n    public void onInvokeMethod(ForestRequest req, ForestMethod method, Object[] args) {\n        String methodName = method.getMethodName();\n        addAttribute(req, "methodName", methodName); // 添加Attribute\n        addAttribute(req, "num", (Integer) args[0]); // 添加Attribute\n    }\n\n    @Override\n    public void onSuccess(String data, ForestRequest req, ForestResponse res) {\n        Object value1 = getAttribute(req, "methodName");  // 获取名称为methodName的Attribute，不指定返回类型\n        String value2 = getAttribute(req, "methodName", String.class);  // 获取名称为methodName的Attribute，并转换为指定的Class类型\n        String value3 = getAttributeAsString(req, "methodName");  // 获取名称为methodName的Attribute，并转换为String类型\n        Integer value4 = getAttributeAsInteger(req, "num");  // 获取名称为num的Attribute，并转换为Integer类型\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# Attachment\n\n可以使用ForestRequest对象的addAttachment方法和getAttachment方法来添加和获取Attachment。\n\nAttachment 是和请求绑定的附件属性值，这些值不能通过网络请求传递到远端服务器。\n\n而且，在使用getAttachment方法时，只能获取在相同请求中绑定的Attachment，但不必是相同的拦截器。\n\npublic class SimpleInterceptor1 implements Interceptor<String> {\n  \n    @Override\n    public void onInvokeMethod(ForestRequest req, ForestMethod method, Object[] args) {\n        String methodName = method.getMethodName();\n        req.addAttachment("methodName", methodName); // 添加Attachment\n        req.addAttachment("num", (Integer) args[0]); // 添加Attachment\n    }\n    ... ...\n}\n\n/**\n * Attachment不依赖任何一个拦截器，可以跨拦截器传递数据\n */\npublic class SimpleInterceptor2 implements Interceptor<String> {\n  \n    @Override\n    public void onSuccess(String data, ForestRequest req, ForestResponse res) {\n        Object value1 = req.getAttachment("methodName");  // 获取名称为methodName的Attachment\n        Object value2 = req.getAttachment("num");  // 获取名称为num的Attachment\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# Attribute与Attachment的区别\n\nAttribute和Attachment都是能通过请求进行绑定的数据传递方式，但也有所不同。\n\n             绑定请求   绑定拦截器\nAttribute    ✔      ✔\nAttachment   ✔      ✘\n\n\n# 配置拦截器\n\nForest有三个地方可以添加拦截器：@Request、@BaseRequest、全局配置，这三个地方代表三个不同的作用域。\n\n# @Request上的拦截器\n\n若您想要指定的拦截器只作用在指定的请求上，只需要在该请求方法的@Request注解中设置interceptor属性即可。\n\n\npublic interface SimpleClient {\n\n    @Request(\n            url = "http://localhost:8080/hello/user?username=foo",\n            headers = {"Accept:text/plain"},\n            interceptor = SimpleInterceptor.class\n    )\n    String simple();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n@Request中拦截器可以配置多个:\n\n    @Request(\n            url = "http://localhost:8080/hello/user?username=foo",\n            headers = {"Accept:text/plain"},\n            interceptor = {SimpleInterceptor1.class, SimpleInterceptor2.class, ...}\n    )\n    String simple();\n\n\n1\n2\n3\n4\n5\n6\n\n\n友情提示\n\n@Request上的拦截器只会拦截指定的请求\n\n# @BaseRequest 上的拦截器\n\n若您想使一个interface内的所有请求方法都指定某一个拦截器，可以在@BaseRequest的interceptor中设置\n\n\n@BaseRequest(baseURL = "http://localhost:8080", interceptor = SimpleInterceptor.class)\npublic interface SimpleClient {\n\n    @Request(url = "/hello/user1?username=foo" )\n    String send1();\n\n    @Request(url = "/hello/user2?username=foo" )\n    String send2();\n\n    @Request(url = "/hello/user3?username=foo" )\n    String send3();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如以上代码所示，SimpleClient接口中的send1、send2、send3方法都被会SimpleInterceptor拦截器拦截\n\n@BaseRequest也如@Request中的interceptor属性一样，可以配1到多个拦截器，如代码所示：\n\n@BaseRequest(\n    baseURL = "http://localhost:8080", \n    interceptor = {SimpleInterceptor1.class, SimpleInterceptor2.class, ...})\npublic interface SimpleClient {\n    // ... ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 全局拦截器\n\n若要配置能拦截项目范围所有Forest请求的拦截器也很简单，只要在全局配置中加上interceptors属性即可\n\nforest:\n  ...\n  interceptors:                   # 可配置1到多个拦截器\n     - com.your.site.client.SimpleInterceptor1\n     - com.your.site.client.SimpleInterceptor2\n     ...\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'用过spring mvc的朋友一定对spring的拦截器并不陌生，forest也同样支持针对forest请求的拦截器。\n\n如果您想在很多个请求发送之前或之后做一些事情（如打印日志、计数等等），拦截器就是您的好帮手。\n\n\n# 构建拦截器\n\n定义一个拦截器需要实现com.dtflys.forest.interceptor.interceptor接口\n\npublic class simpleinterceptor<t> implements interceptor<t> {\n\n    private final static logger log = loggerfactory.getlogger(simpleinterceptor.class);\n\n    /**\n     * 该方法在被调用时，并在beforeexecute前被调用 \n     * @param request forest请求对象\n     * @param args 方法被调用时传入的参数数组 \n     */\n    @override\n    public void oninvokemethod(forestrequest req, forestmethod method, object[] args) {\n        log.info("on invoke method");\n        // req 为forest请求对象，即 forestrequest 类实例\n        // method 为forest方法对象，即 forestmethod 类实例\n        // addattribute作用是添加和forest请求对象以及该拦截器绑定的属性\n        addattribute(req, "a", "value1");\n        addattribute(req, "b", "value2");\n    }\n\n    /**\n     * 该方法在请求发送之前被调用, 若返回false则不会继续发送请求\n     * @param request forest请求对象\n     */\n    @override\n    public boolean beforeexecute(forestrequest req) {\n        log.info("invoke simple beforeexecute");\n        // 执行在发送请求之前处理的代码\n        req.addheader("accesstoken", "11111111");  // 添加header\n        req.addquery("username", "foo");  // 添加url的query参数\n        return true;  // 继续执行请求返回true\n    }\n\n    /**\n     * 该方法在请求成功响应时被调用\n     */\n    @override\n    public void onsuccess(t data, forestrequest req, forestresponse res) {\n        log.info("invoke simple onsuccess");\n        // 执行成功接收响应后处理的代码\n        int status = res.getstatuscode(); // 获取请求响应状态码\n        string content = res.getcontent(); // 获取请求的响应内容\n        string result = (string)data;  // data参数是方法返回类型对应的返回数据结果,注意需要视情况修改对应的类型否则有可能出现类转型异常\n        result = res.getresult(); // getresult()也可以获取返回的数据结果\n        response.setresult("修改后的结果: " + result);  // 可以修改请求响应的返回数据结果\n        \n        // 使用getattributeasstring取出属性，这里只能取到与该forest请求对象，以及该拦截器绑定的属性\n        string attrvalue1 = getattributeasstring(req, "a1");\n\n    }\n\n    /**\n     * 该方法在请求发送失败时被调用\n     */\n    @override\n    public void onerror(forestruntimeexception ex, forestrequest req, forestresponse res) {\n        log.info("invoke simple onerror");\n        // 执行发送请求失败后处理的代码\n        int status = res.getstatuscode(); // 获取请求响应状态码\n        string content = res.getcontent(); // 获取请求的响应内容\n        string result = res.getresult(); // 获取方法返回类型对应的返回数据结果\n    }\n\n    /**\n     * 该方法在请求发送之后被调用\n     */\n    @override\n    public void afterexecute(forestrequest req, forestresponse res) {\n        log.info("invoke simple afterexecute");\n        // 执行在发送请求之后处理的代码\n        int status = res.getstatuscode(); // 获取请求响应状态码\n        string content = res.getcontent(); // 获取请求的响应内容\n        string result = res.getresult(); // 获取方法返回类型对应的最终数据结果\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\ninterceptor接口带有一个泛型参数，其表示的是请求响应后返回的数据类型。 interceptor<string>即代表返回的数据类型为 string。\n\n在拦截器的方法参数中基本都有 forestrequest 类对象，即forest请求对象，forest的绝大部分操作都是围绕请求对象所作的工作。\n\n文档导航\n\n要详细了解 forest 请求对象如何使用，请参见《请求对象》\n\n\n# 拦截器与 spring 集成\n\n若我要在拦截器中注入 spring 的 bean 改如何做？\n\n\n/**\n * 在拦截器的类上加上@component注解，并保证它能被spring扫描到\n */\n@component\npublic class simpleinterceptor implements interceptor<string> {\n\n    // 如此便能直接注入spring上下文中所有的bean了\n    @resouce\n    private userservice userservice;\n    \n    ... ...\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 在拦截器中传递数据\n\n在forest中，拦截器是基于单例模式创建的，也就是说一个拦截器类最多只能对应一个拦截器实例。\n\n那么以下这种通过共享变量的方式就可能造成错误：\n\npublic class simpleinterceptor implements interceptor<string> {\n  \n    private string name;\n   \n    @override\n    public boolean beforeexecute(forestrequest req) {\n        this.name = req.getquery("name");\n    }\n\n    @override\n    public void onsuccess(string data, forestrequest req, forestresponse res) {\n        system.out.println("name = " + name);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n若有两个请求同时进入该拦截器（请求1 url=...?name=a1, 请求2 url=...?name=a2）, 而最后当请求1进入onsuccess方法时，应该打印出 name = a2，却因为之前执行了请求2的beforeexecute方法，将类变量name的值改成了a2, 所以最终打印出来的是 name = a2 （其实应该是 name = a1），这明显是错误的。\n\n那该如何做能在传递数据的同时避免这类问题呢？\n\n方法也很简单，就是将您要传递的数据与请求对象绑定在一起，比如在 onsuccess 中调用req.getquery方法。\n\nsystem.out.println("name = " + forest.getquery("name"));\n\n\n1\n\n\n虽然这种方法能够解决并发问题，但有个明显的限制：如果要传递的数据不想出现在请求中的任何位置(包括url、请求头、请求体)，那就无能为力了。\n\n这时候就要使用 forestrequest 的扩展绑定数据的方法了。\n\n\n# attribute\n\n在拦截器中使用addattribute方法和getattribute方法来添加和获取attribute。\n\nattribute 是和请求以及所在拦截器绑定的属性值，这些属性值不能通过网络请求传递到远端服务器。\n\n而且，在使用getattribute方法时，只能获取在相同拦截器，以及相同请求中绑定的attribute，这两个条件缺一不可。\n\npublic class simpleinterceptor implements interceptor<string> {\n  \n    @override\n    public void oninvokemethod(forestrequest req, forestmethod method, object[] args) {\n        string methodname = method.getmethodname();\n        addattribute(req, "methodname", methodname); // 添加attribute\n        addattribute(req, "num", (integer) args[0]); // 添加attribute\n    }\n\n    @override\n    public void onsuccess(string data, forestrequest req, forestresponse res) {\n        object value1 = getattribute(req, "methodname");  // 获取名称为methodname的attribute，不指定返回类型\n        string value2 = getattribute(req, "methodname", string.class);  // 获取名称为methodname的attribute，并转换为指定的class类型\n        string value3 = getattributeasstring(req, "methodname");  // 获取名称为methodname的attribute，并转换为string类型\n        integer value4 = getattributeasinteger(req, "num");  // 获取名称为num的attribute，并转换为integer类型\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# attachment\n\n可以使用forestrequest对象的addattachment方法和getattachment方法来添加和获取attachment。\n\nattachment 是和请求绑定的附件属性值，这些值不能通过网络请求传递到远端服务器。\n\n而且，在使用getattachment方法时，只能获取在相同请求中绑定的attachment，但不必是相同的拦截器。\n\npublic class simpleinterceptor1 implements interceptor<string> {\n  \n    @override\n    public void oninvokemethod(forestrequest req, forestmethod method, object[] args) {\n        string methodname = method.getmethodname();\n        req.addattachment("methodname", methodname); // 添加attachment\n        req.addattachment("num", (integer) args[0]); // 添加attachment\n    }\n    ... ...\n}\n\n/**\n * attachment不依赖任何一个拦截器，可以跨拦截器传递数据\n */\npublic class simpleinterceptor2 implements interceptor<string> {\n  \n    @override\n    public void onsuccess(string data, forestrequest req, forestresponse res) {\n        object value1 = req.getattachment("methodname");  // 获取名称为methodname的attachment\n        object value2 = req.getattachment("num");  // 获取名称为num的attachment\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# attribute与attachment的区别\n\nattribute和attachment都是能通过请求进行绑定的数据传递方式，但也有所不同。\n\n             绑定请求   绑定拦截器\nattribute    ✔      ✔\nattachment   ✔      ✘\n\n\n# 配置拦截器\n\nforest有三个地方可以添加拦截器：@request、@baserequest、全局配置，这三个地方代表三个不同的作用域。\n\n# @request上的拦截器\n\n若您想要指定的拦截器只作用在指定的请求上，只需要在该请求方法的@request注解中设置interceptor属性即可。\n\n\npublic interface simpleclient {\n\n    @request(\n            url = "http://localhost:8080/hello/user?username=foo",\n            headers = {"accept:text/plain"},\n            interceptor = simpleinterceptor.class\n    )\n    string simple();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n@request中拦截器可以配置多个:\n\n    @request(\n            url = "http://localhost:8080/hello/user?username=foo",\n            headers = {"accept:text/plain"},\n            interceptor = {simpleinterceptor1.class, simpleinterceptor2.class, ...}\n    )\n    string simple();\n\n\n1\n2\n3\n4\n5\n6\n\n\n友情提示\n\n@request上的拦截器只会拦截指定的请求\n\n# @baserequest 上的拦截器\n\n若您想使一个interface内的所有请求方法都指定某一个拦截器，可以在@baserequest的interceptor中设置\n\n\n@baserequest(baseurl = "http://localhost:8080", interceptor = simpleinterceptor.class)\npublic interface simpleclient {\n\n    @request(url = "/hello/user1?username=foo" )\n    string send1();\n\n    @request(url = "/hello/user2?username=foo" )\n    string send2();\n\n    @request(url = "/hello/user3?username=foo" )\n    string send3();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如以上代码所示，simpleclient接口中的send1、send2、send3方法都被会simpleinterceptor拦截器拦截\n\n@baserequest也如@request中的interceptor属性一样，可以配1到多个拦截器，如代码所示：\n\n@baserequest(\n    baseurl = "http://localhost:8080", \n    interceptor = {simpleinterceptor1.class, simpleinterceptor2.class, ...})\npublic interface simpleclient {\n    // ... ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 全局拦截器\n\n若要配置能拦截项目范围所有forest请求的拦截器也很简单，只要在全局配置中加上interceptors属性即可\n\nforest:\n  ...\n  interceptors:                   # 可配置1到多个拦截器\n     - com.your.site.client.simpleinterceptor1\n     - com.your.site.client.simpleinterceptor2\n     ...\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/07/22, 16:00:45",lastUpdatedTimestamp:1658476845e3},{title:"🍏 自定义注解",frontmatter:{id:"custom_annotation",title:"🍏 自定义注解",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/custom_annotation/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/070.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/002.custom_annotation.html",relativePath:"001.v1.5.x文档/070.高级特性/002.custom_annotation.md",key:"v-2c782d95",path:"/pages/1.5.x/custom_annotation/",headers:[{level:3,title:"定义一个注解",slug:"定义一个注解",normalizedTitle:"定义一个注解",charIndex:351},{level:3,title:"生命周期类",slug:"生命周期类",normalizedTitle:"生命周期类",charIndex:473},{level:2,title:"组合注解",slug:"组合注解",normalizedTitle:"组合注解",charIndex:3317}],headersStr:"定义一个注解 生命周期类 组合注解",content:'Forest提供了很多内置的注解，比如 @Request, @Get, @DownloadFile 等等。Forest对于请求接口的构建也是基于这些注解来工作的， 那么总有一些需求是光靠这些内置注解是满足不了的，比如公司内部定义的加签加密方式，自定义数据转换类型等等。当然，您也可以通过拦截器来做，但每个接口类或者每个方法上加上一长串类名总觉得不那么优雅，而且无法通过方法动态传入参数。 为了克服拦截器的这些缺点，自定义注解就应运而生了，以便于您可以简单优雅得解决上述各种需求，而且极大得扩展了Forest的能力。\n\n自定义注解在技术结构上基于拦截器，本质上就是把拦截器封装成了一个个注解，所以如果还不知道拦截器是啥的话，请先看拦截器。 Forest中的所有内置注解也都是通过这样方式工作的。\n\n\n# 定义一个注解\n\n/**\n * 用Forest自定义注解实现一个自定义的签名加密注解\n * 凡用此接口修饰的方法或接口，其对应的所有请求都会执行自定义的签名加密过程\n * 而自定义的签名加密过程，由这里的@MethodLifeCycle注解指定的生命周期类进行处理\n * 可以将此注解用在接口类和方法上\n */\n@Documented\n/** 重点： @MethodLifeCycle注解指定该注解的生命周期类*/\n@MethodLifeCycle(MyAuthLifeCycle.class)\n@RequestAttributes\n@Retention(RetentionPolicy.RUNTIME)\n/** 指定该注解可用于类上或方法上 */\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface MyAuth {\n\n    /**\n     * 自定义注解的属性：用户名\n     * 所有自定注解的属性可以在生命周期类中被获取到\n     */\n    String username();\n\n    /**\n     * 自定义注解的属性：密码\n     * 所有自定注解的属性可以在生命周期类中被获取到\n     */\n    String password();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n上面的代码定义了一个名叫 @MyAuth 的注解，在这个注解又有一个叫 @MethodLifeCycle 的注解，这个注解的value参数指定了该注解所绑定的接口或方法的对应请求，所要执行的生命周期类。\n\n\n# 生命周期类\n\n生命周期类，就如其名字所暗示的一样，它包括了一个请求从方法调用、创建请求、执行完成、成功、失败等生命周期中各个环节所要经历的整个过程。\n\n当然，您也可以理解为另一种拦截器，事实上三种生命周期接口BaseAnnotationLifeCycle、MethodAnnotationLifeCycle 和 ParameterAnnotationLifeCycle 都继承自 Interceptor 接口。\n\n好了，来看下为我们 @MyAuth 注解写的生命周期类\n\n\n/**\n *  MyAuthLifeCycle 为自定义的 @MyAuth 注解的生命周期类\n * 因为 @MyAuth 是针对每个请求方法的，所以它实现自 MethodAnnotationLifeCycle 接口\n * MethodAnnotationLifeCycle 接口带有泛型参数\n * 第一个泛型参数是该生命周期类绑定的注解类型\n * 第二个泛型参数为请求方法返回的数据类型，为了尽可能适应多的不同方法的返回类型，这里使用 Object\n */\npublic class MyAuthLifeCycle implements MethodAnnotationLifeCycle<MyAuth, Object> {\n\n\n    /**\n     * 当方法调用时调用此方法，此时还没有执行请求发送\n     * 此方法可以获得请求对应的方法调用信息，以及动态传入的方法调用参数列表\n     */\n    @Override\n    public void onInvokeMethod(ForestRequest request, ForestMethod method, Object[] args) {\n        System.out.println("Invoke Method \'" + method.getMethodName() + "\' Arguments: " + args);\n    }\n\n    /**\n     * 发送请求前执行此方法，同拦截器中的一样\n     */\n    @Override\n    public boolean beforeExecute(ForestRequest request) {\n        // 通过getAttribute方法获取自定义注解中的属性值\n        // getAttribute第一个参数为request对象，第二个参数为自定义注解中的属性名\n        String username = (String) getAttribute(request, "username");\n        String password = (String) getAttribute(request, "password");\n        // 使用Base64进行加密\n        String basic = "MyAuth " + Base64Utils.encode("{" + username + ":" + password + "}");\n        // 调用addHeader方法将加密结构加到请求头MyAuthorization中\n        request.addHeader("MyAuthorization", basic);\n        return true;\n    }\n\n    /**\n     * 此方法在请求方法初始化的时候被调用\n     */\n    @Override\n    public void onMethodInitialized(ForestMethod method, BasicAuth annotation) {\n        System.out.println("Method \'" + method.getMethodName() + "\' Initialized, Arguments: " + args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nOK, 定义部分基本完成了。就让我们来使用刚刚定义好的 @MyAuth 注解吧\n\n/**\n * 在请求接口上加上自定义的 @MyAuth 注解\n * 注解的参数可以是字符串模板，通过方法调用的时候动态传入\n * 也可以是写死的字符串\n */\n@Get(\n        url = "http://localhost:8080/hello/user?username=${username}",\n        headers = {"Accept:text/plain"}\n)\n@MyAuth(username = "${username}", password = "bar")\nString send(@Var("username") String username);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 组合注解\n\nForest 的自定义注解功能强大，能将复杂的生命周期封装成一个优雅的注解\n\n但每次都需要定义一个生命周期类也十分麻烦，有时候想定义的注解功能十分简单\n\n（比如将 @Headers("Content-Type: application/json") 封装成 @MyHeaders）\n\n这时候再定义一个类来处理此事就显得很不划算\n\n但其实 Forest 提供了一个更简单更优雅的办法来做此类事情，那就是《组合注解》',normalizedContent:'forest提供了很多内置的注解，比如 @request, @get, @downloadfile 等等。forest对于请求接口的构建也是基于这些注解来工作的， 那么总有一些需求是光靠这些内置注解是满足不了的，比如公司内部定义的加签加密方式，自定义数据转换类型等等。当然，您也可以通过拦截器来做，但每个接口类或者每个方法上加上一长串类名总觉得不那么优雅，而且无法通过方法动态传入参数。 为了克服拦截器的这些缺点，自定义注解就应运而生了，以便于您可以简单优雅得解决上述各种需求，而且极大得扩展了forest的能力。\n\n自定义注解在技术结构上基于拦截器，本质上就是把拦截器封装成了一个个注解，所以如果还不知道拦截器是啥的话，请先看拦截器。 forest中的所有内置注解也都是通过这样方式工作的。\n\n\n# 定义一个注解\n\n/**\n * 用forest自定义注解实现一个自定义的签名加密注解\n * 凡用此接口修饰的方法或接口，其对应的所有请求都会执行自定义的签名加密过程\n * 而自定义的签名加密过程，由这里的@methodlifecycle注解指定的生命周期类进行处理\n * 可以将此注解用在接口类和方法上\n */\n@documented\n/** 重点： @methodlifecycle注解指定该注解的生命周期类*/\n@methodlifecycle(myauthlifecycle.class)\n@requestattributes\n@retention(retentionpolicy.runtime)\n/** 指定该注解可用于类上或方法上 */\n@target({elementtype.type, elementtype.method})\npublic @interface myauth {\n\n    /**\n     * 自定义注解的属性：用户名\n     * 所有自定注解的属性可以在生命周期类中被获取到\n     */\n    string username();\n\n    /**\n     * 自定义注解的属性：密码\n     * 所有自定注解的属性可以在生命周期类中被获取到\n     */\n    string password();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n上面的代码定义了一个名叫 @myauth 的注解，在这个注解又有一个叫 @methodlifecycle 的注解，这个注解的value参数指定了该注解所绑定的接口或方法的对应请求，所要执行的生命周期类。\n\n\n# 生命周期类\n\n生命周期类，就如其名字所暗示的一样，它包括了一个请求从方法调用、创建请求、执行完成、成功、失败等生命周期中各个环节所要经历的整个过程。\n\n当然，您也可以理解为另一种拦截器，事实上三种生命周期接口baseannotationlifecycle、methodannotationlifecycle 和 parameterannotationlifecycle 都继承自 interceptor 接口。\n\n好了，来看下为我们 @myauth 注解写的生命周期类\n\n\n/**\n *  myauthlifecycle 为自定义的 @myauth 注解的生命周期类\n * 因为 @myauth 是针对每个请求方法的，所以它实现自 methodannotationlifecycle 接口\n * methodannotationlifecycle 接口带有泛型参数\n * 第一个泛型参数是该生命周期类绑定的注解类型\n * 第二个泛型参数为请求方法返回的数据类型，为了尽可能适应多的不同方法的返回类型，这里使用 object\n */\npublic class myauthlifecycle implements methodannotationlifecycle<myauth, object> {\n\n\n    /**\n     * 当方法调用时调用此方法，此时还没有执行请求发送\n     * 此方法可以获得请求对应的方法调用信息，以及动态传入的方法调用参数列表\n     */\n    @override\n    public void oninvokemethod(forestrequest request, forestmethod method, object[] args) {\n        system.out.println("invoke method \'" + method.getmethodname() + "\' arguments: " + args);\n    }\n\n    /**\n     * 发送请求前执行此方法，同拦截器中的一样\n     */\n    @override\n    public boolean beforeexecute(forestrequest request) {\n        // 通过getattribute方法获取自定义注解中的属性值\n        // getattribute第一个参数为request对象，第二个参数为自定义注解中的属性名\n        string username = (string) getattribute(request, "username");\n        string password = (string) getattribute(request, "password");\n        // 使用base64进行加密\n        string basic = "myauth " + base64utils.encode("{" + username + ":" + password + "}");\n        // 调用addheader方法将加密结构加到请求头myauthorization中\n        request.addheader("myauthorization", basic);\n        return true;\n    }\n\n    /**\n     * 此方法在请求方法初始化的时候被调用\n     */\n    @override\n    public void onmethodinitialized(forestmethod method, basicauth annotation) {\n        system.out.println("method \'" + method.getmethodname() + "\' initialized, arguments: " + args);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nok, 定义部分基本完成了。就让我们来使用刚刚定义好的 @myauth 注解吧\n\n/**\n * 在请求接口上加上自定义的 @myauth 注解\n * 注解的参数可以是字符串模板，通过方法调用的时候动态传入\n * 也可以是写死的字符串\n */\n@get(\n        url = "http://localhost:8080/hello/user?username=${username}",\n        headers = {"accept:text/plain"}\n)\n@myauth(username = "${username}", password = "bar")\nstring send(@var("username") string username);\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 组合注解\n\nforest 的自定义注解功能强大，能将复杂的生命周期封装成一个优雅的注解\n\n但每次都需要定义一个生命周期类也十分麻烦，有时候想定义的注解功能十分简单\n\n（比如将 @headers("content-type: application/json") 封装成 @myheaders）\n\n这时候再定义一个类来处理此事就显得很不划算\n\n但其实 forest 提供了一个更简单更优雅的办法来做此类事情，那就是《组合注解》',charsets:{cjk:!0},lastUpdated:"2022/07/20, 16:59:33",lastUpdatedTimestamp:1658307573e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-46c27bdf",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/01, 19:32:06",lastUpdatedTimestamp:1656675126e3},{title:"🍇 组合注解",frontmatter:{id:"makeup_annotation",title:"🍇 组合注解",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/1.5.x/makeup_annotation/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/070.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/003.makeup_annotation.html",relativePath:"001.v1.5.x文档/070.高级特性/003.makeup_annotation.md",key:"v-37b0d296",path:"/pages/1.5.x/makeup_annotation/",headers:[{level:2,title:"组合一个注解",slug:"组合一个注解",normalizedTitle:"组合一个注解",charIndex:55},{level:2,title:"组合多个注解",slug:"组合多个注解",normalizedTitle:"组合多个注解",charIndex:839}],headersStr:"组合一个注解 组合多个注解",content:'Forest 除了能用生命周期来自定义注解外，也允许您把已有的 Forest 注解组合成一个新的注解\n\n\n# 组合一个注解\n\n/**\n * 用Forest组合注解实现一个自定义的请求头注解\n * 此注解加上了 @Headers 注解，并为注解的参数赋了值\n * 那么以后使用此注解的接口和方法，会自动添加上 @Headers 注解以及它的参数值\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.TYPE})\n// 被组合的注解\n@Headers({\n        "Accept: text/plain",\n        "Content-Type: application/json",\n        // 在组合注解中可以在模板字符串中引用变量\n        // 它会从全局变量或方法的参数中获取变量值\n        "Token: ${token}"\n})\npublic @interface MyHeaders {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用组合注解的方法\n\n// 该方法使用了自定义的组合注解 @MyHeaders\n// 所以该方法发送的请求会自动添加以下请求头:\n// Accept: text/plain\n// Content-Type: application/json\n// Token: xxx (从形参 token 中传入的值)\n@Get("/data")\n@MyHeaders\nString getData(@Var("token") String token);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n组合注解目前无法在字符串模板中引用自身的注解属性\n\n如需要定义和解析注解的属性，请使用《自定义注解》\n\n\n# 组合多个注解\n\nForest 还可以组合2个及2个以上的 Forest 注解\n\n/**\n * Forest 可以同时组合多个注解\n * 如方法使用该自定义的 @MySite 注解\n * 那么就等同使用这里被组合的 @Headers 注解和 @Address 注解\n * 以及它们的参数值\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.TYPE})\n// 组合第一个注解\n@Headers({\n        "Accept: text/plain",\n        "Content-Type: application/json"\n})\n// 组合第二个注解\n// 可以从全局变量或方法参数中获取变量值\n@Address(host = "${my-site.host}", port = "${my-site.port}")\npublic @interface MySite {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意\n\n定义组合注解的时候要注解不要组合自身，以及组合过自身的其它注解，以免引起循环引用',normalizedContent:'forest 除了能用生命周期来自定义注解外，也允许您把已有的 forest 注解组合成一个新的注解\n\n\n# 组合一个注解\n\n/**\n * 用forest组合注解实现一个自定义的请求头注解\n * 此注解加上了 @headers 注解，并为注解的参数赋了值\n * 那么以后使用此注解的接口和方法，会自动添加上 @headers 注解以及它的参数值\n */\n@documented\n@retention(retentionpolicy.runtime)\n@target({elementtype.method, elementtype.type})\n// 被组合的注解\n@headers({\n        "accept: text/plain",\n        "content-type: application/json",\n        // 在组合注解中可以在模板字符串中引用变量\n        // 它会从全局变量或方法的参数中获取变量值\n        "token: ${token}"\n})\npublic @interface myheaders {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用组合注解的方法\n\n// 该方法使用了自定义的组合注解 @myheaders\n// 所以该方法发送的请求会自动添加以下请求头:\n// accept: text/plain\n// content-type: application/json\n// token: xxx (从形参 token 中传入的值)\n@get("/data")\n@myheaders\nstring getdata(@var("token") string token);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n组合注解目前无法在字符串模板中引用自身的注解属性\n\n如需要定义和解析注解的属性，请使用《自定义注解》\n\n\n# 组合多个注解\n\nforest 还可以组合2个及2个以上的 forest 注解\n\n/**\n * forest 可以同时组合多个注解\n * 如方法使用该自定义的 @mysite 注解\n * 那么就等同使用这里被组合的 @headers 注解和 @address 注解\n * 以及它们的参数值\n */\n@documented\n@retention(retentionpolicy.runtime)\n@target({elementtype.method, elementtype.type})\n// 组合第一个注解\n@headers({\n        "accept: text/plain",\n        "content-type: application/json"\n})\n// 组合第二个注解\n// 可以从全局变量或方法参数中获取变量值\n@address(host = "${my-site.host}", port = "${my-site.port}")\npublic @interface mysite {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意\n\n定义组合注解的时候要注解不要组合自身，以及组合过自身的其它注解，以免引起循环引用',charsets:{cjk:!0},lastUpdated:"2022/07/20, 16:59:33",lastUpdatedTimestamp:1658307573e3},{title:"🥑 自定义转换器",frontmatter:{title:"🥑 自定义转换器",date:"2022-07-20T23:48:08.000Z",permalink:"/pages/custom_converter/"},regularPath:"/001.v1.5.x%E6%96%87%E6%A1%A3/070.%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/004.custom_converter.html",relativePath:"001.v1.5.x文档/070.高级特性/004.custom_converter.md",key:"v-09990286",path:"/pages/custom_converter/",headers:[{level:2,title:"实现 ForestConverter 接口",slug:"实现-forestconverter-接口",normalizedTitle:"实现 forestconverter 接口",charIndex:300},{level:2,title:"注册全局自定义转换器",slug:"注册全局自定义转换器",normalizedTitle:"注册全局自定义转换器",charIndex:803},{level:2,title:"Springboot 下注册全局转换器",slug:"springboot-下注册全局转换器",normalizedTitle:"springboot 下注册全局转换器",charIndex:1919},{level:2,title:"接口/方法级别自定义转换器",slug:"接口-方法级别自定义转换器",normalizedTitle:"接口/方法级别自定义转换器",charIndex:2118}],headersStr:"实现 ForestConverter 接口 注册全局自定义转换器 Springboot 下注册全局转换器 接口/方法级别自定义转换器",content:'在Forest中，每个转换类型都对应一个转换器对象，比如JSON格式的转换器有com.dtflys.forest.converter.json.ForestFastjsonConverter、com.dtflys.forest.converter.json.ForestGsonConverter、com.dtflys.forest.converter.json.ForestJacksonConverter三种，分别是基于FastJson、Gson、Jackson三种不同的JSON序列化框架。\n\n当然，您也可以自定义自己的转换器，以适应自己项目的需要。只需三步便可完成自定义扩展转换器。\n\n\n# 实现 ForestConverter 接口\n\n定义一个转换器类，并实现com.dtflys.forest.converter.ForestConverter接口\n\n/**\n *  自定义一个Protobuf的转换器，并实现ForestConverter接口下的convertToJavaObject方法\n */\npublic class MyProtobufConverter implements ForestConverter {\n\n    public <T> T convertToJavaObject(String source, Class<T> targetType) {\n        // 将字符串参数source转换成目标Class对象\n    }\n\n    public <T> T convertToJavaObject(String source, Type targetType) {\n        // 将字符串参数source转换成目标Type(可能是一个泛型类型)对象\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 注册全局自定义转换器\n\n注册到全局配置中\n\nforest:\n  converters:\n    # JSON转换器\n    json:\n      # JSON转换器设置为MyJsonConverter转换器\n      type: com.xxx.MyJsonConverter\n      \n    # XML转换器\n    xml:\n      # 配置为MyXmlConverter转换器\n      type: com.xxx.MyXmlConverter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# JSON转换器\n# JSON转换器设置为MyJsonConverter转换器\nforest.converters.json.type=com.xxx.MyJsonConverter\n# XML转换器\n# 配置为MyXmlConverter转换器\nforest.converters.xml.type=com.xxx.MyXmlConverter\n\n\n1\n2\n3\n4\n5\n6\n\n\n<forest:configuration>\n    \x3c!-- Forest转换器定义 开始 --\x3e\n    \x3c!-- 设置JSON转换器 --\x3e\n    \x3c!-- JSON转换器设置为MyJsonConverter转换器 --\x3e\n    <forest:converter dataType="json" class="com.xxx.MyJsonConverter">\n    </forest:converter>\n    \x3c!-- Forest转换器定义 结束 --\x3e\n    \x3c!-- 设置XML转换器 --\x3e\n    \x3c!-- 设置为MyXmlConverter转换器 --\x3e\n    <forest:converter dataType="xml" class="com.xxx.MyXmlConverter">\n    </forest:converter>\n    \x3c!-- Forest转换器定义 结束 --\x3e\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n// 设置JSON转换器\nforestConfiguration.setJsonConverter(new MyJsonConverter());\n// 设置XML转换器\nforestConfiguration.getConverterMap().put(ForestDataType.XML, new MyXmlConverter());\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# Springboot 下注册全局转换器\n\n同上文的 《springboot 下配置全局转换器》一样，可通过@Bean注解方法将自定义转换器实例注入到 Spring 上下文\n\n@Bean\npublic MyProtobufConverter myProtobufConverter() {\n    return new MyProtobufConverter();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 接口/方法级别自定义转换器\n\n也同上文的 《配置接口/方法级别转换器》一样，通过@BodyType注解来指定自定义的转换器类\n\n// 接口级别转换器定义\n@BodyType(type = "protobuf", encoder = MyProtobufConverter.class)\npublic interface MyClient {\n\n    // 方法级别转换器定义\n    @Get("/data")\n    @BodyType(type = "protobuf", encoder = MyProtobufConverter2.class)\n    String sendData(@Body MyData data);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'在forest中，每个转换类型都对应一个转换器对象，比如json格式的转换器有com.dtflys.forest.converter.json.forestfastjsonconverter、com.dtflys.forest.converter.json.forestgsonconverter、com.dtflys.forest.converter.json.forestjacksonconverter三种，分别是基于fastjson、gson、jackson三种不同的json序列化框架。\n\n当然，您也可以自定义自己的转换器，以适应自己项目的需要。只需三步便可完成自定义扩展转换器。\n\n\n# 实现 forestconverter 接口\n\n定义一个转换器类，并实现com.dtflys.forest.converter.forestconverter接口\n\n/**\n *  自定义一个protobuf的转换器，并实现forestconverter接口下的converttojavaobject方法\n */\npublic class myprotobufconverter implements forestconverter {\n\n    public <t> t converttojavaobject(string source, class<t> targettype) {\n        // 将字符串参数source转换成目标class对象\n    }\n\n    public <t> t converttojavaobject(string source, type targettype) {\n        // 将字符串参数source转换成目标type(可能是一个泛型类型)对象\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 注册全局自定义转换器\n\n注册到全局配置中\n\nforest:\n  converters:\n    # json转换器\n    json:\n      # json转换器设置为myjsonconverter转换器\n      type: com.xxx.myjsonconverter\n      \n    # xml转换器\n    xml:\n      # 配置为myxmlconverter转换器\n      type: com.xxx.myxmlconverter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# json转换器\n# json转换器设置为myjsonconverter转换器\nforest.converters.json.type=com.xxx.myjsonconverter\n# xml转换器\n# 配置为myxmlconverter转换器\nforest.converters.xml.type=com.xxx.myxmlconverter\n\n\n1\n2\n3\n4\n5\n6\n\n\n<forest:configuration>\n    \x3c!-- forest转换器定义 开始 --\x3e\n    \x3c!-- 设置json转换器 --\x3e\n    \x3c!-- json转换器设置为myjsonconverter转换器 --\x3e\n    <forest:converter datatype="json" class="com.xxx.myjsonconverter">\n    </forest:converter>\n    \x3c!-- forest转换器定义 结束 --\x3e\n    \x3c!-- 设置xml转换器 --\x3e\n    \x3c!-- 设置为myxmlconverter转换器 --\x3e\n    <forest:converter datatype="xml" class="com.xxx.myxmlconverter">\n    </forest:converter>\n    \x3c!-- forest转换器定义 结束 --\x3e\n</forest:configuration>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n// 设置json转换器\nforestconfiguration.setjsonconverter(new myjsonconverter());\n// 设置xml转换器\nforestconfiguration.getconvertermap().put(forestdatatype.xml, new myxmlconverter());\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# springboot 下注册全局转换器\n\n同上文的 《springboot 下配置全局转换器》一样，可通过@bean注解方法将自定义转换器实例注入到 spring 上下文\n\n@bean\npublic myprotobufconverter myprotobufconverter() {\n    return new myprotobufconverter();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 接口/方法级别自定义转换器\n\n也同上文的 《配置接口/方法级别转换器》一样，通过@bodytype注解来指定自定义的转换器类\n\n// 接口级别转换器定义\n@bodytype(type = "protobuf", encoder = myprotobufconverter.class)\npublic interface myclient {\n\n    // 方法级别转换器定义\n    @get("/data")\n    @bodytype(type = "protobuf", encoder = myprotobufconverter2.class)\n    string senddata(@body mydata data);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/07/21, 00:37:03",lastUpdatedTimestamp:1658335023e3},{title:"⚒️ 参与贡献",frontmatter:{id:"contribute",title:"⚒️ 参与贡献",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/contribute/"},regularPath:"/%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AE.html",relativePath:"参与贡献.md",key:"v-2ae768c1",path:"/pages/contribute/",headers:[{level:3,title:"如何成为提交者",slug:"如何成为提交者",normalizedTitle:"如何成为提交者",charIndex:57},{level:3,title:"如何成为维护者",slug:"如何成为维护者",normalizedTitle:"如何成为维护者",charIndex:217},{level:3,title:"代码提交规范",slug:"代码提交规范",normalizedTitle:"代码提交规范",charIndex:324}],headersStr:"如何成为提交者 如何成为维护者 代码提交规范",content:"非常欢迎大家参与到Forest开源项目中来，Forest如要继续服务更多的人，就离不开大家的帮助和贡献。\n\n\n# 如何成为提交者\n\n 1. 需要对开源有热情，技术扎实\n\n 2. 需要熟读Forest源码，理解Forest的设计\n\n 3. 找作者在Gitee上分配Issue\n\n 4. 帮助解决1个Issue并合并到master后，给提交者权限\n\n 5. 帮助解决5个Issue，其中必须包含2个新特性Issue，给管理员权限\n\n\n# 如何成为维护者\n\n 1. 需要对开源有热情\n\n 2. 需要理解Forest的设计和核心代码\n\n 3. 帮助回复Issue和维护官网文档\n\n 4. 帮助推广和收集反馈\n\n 5. 完成2，3点后，给提交者权限\n\n\n# 代码提交规范\n\n 1. 进群讨论，可以在群里抛出您遇到的问题，或者在Gitee的Issue列表中搜索关键字，或许已经有人解决了或正在解决您的问题，避免重复。\n\n 2. 找作者分配Issue，也可以自己直接提Issue，如果在Gitee的Issue中已经有您想解决的问题，可以直接将该Issue分配给您自己。\n\n 3. Fork 本项目的仓库。\n\n 4. 新建分支，如果是加新特性，分支名格式为feat_${Issue的ID号}，如果是修改bug，则命名为fix_${Issue的ID号}。\n\n 5. 编写该Issue相关的单元测试。\n\n 6. 在代码注释的作者栏中加上自己的ID，新的方法或类请加上新的注释。\n\n 7. 本地自测，提交前请通过所有的已经单元测试，以及为您要解决的问题新增单元测试。\n\n 8. 新建 Pull Request。\n\n 9. 我会对您的PR进行验证和测试，如通过测试，我会合到dev分支上随新版本发布时再合到master分支上。",normalizedContent:"非常欢迎大家参与到forest开源项目中来，forest如要继续服务更多的人，就离不开大家的帮助和贡献。\n\n\n# 如何成为提交者\n\n 1. 需要对开源有热情，技术扎实\n\n 2. 需要熟读forest源码，理解forest的设计\n\n 3. 找作者在gitee上分配issue\n\n 4. 帮助解决1个issue并合并到master后，给提交者权限\n\n 5. 帮助解决5个issue，其中必须包含2个新特性issue，给管理员权限\n\n\n# 如何成为维护者\n\n 1. 需要对开源有热情\n\n 2. 需要理解forest的设计和核心代码\n\n 3. 帮助回复issue和维护官网文档\n\n 4. 帮助推广和收集反馈\n\n 5. 完成2，3点后，给提交者权限\n\n\n# 代码提交规范\n\n 1. 进群讨论，可以在群里抛出您遇到的问题，或者在gitee的issue列表中搜索关键字，或许已经有人解决了或正在解决您的问题，避免重复。\n\n 2. 找作者分配issue，也可以自己直接提issue，如果在gitee的issue中已经有您想解决的问题，可以直接将该issue分配给您自己。\n\n 3. fork 本项目的仓库。\n\n 4. 新建分支，如果是加新特性，分支名格式为feat_${issue的id号}，如果是修改bug，则命名为fix_${issue的id号}。\n\n 5. 编写该issue相关的单元测试。\n\n 6. 在代码注释的作者栏中加上自己的id，新的方法或类请加上新的注释。\n\n 7. 本地自测，提交前请通过所有的已经单元测试，以及为您要解决的问题新增单元测试。\n\n 8. 新建 pull request。\n\n 9. 我会对您的pr进行验证和测试，如通过测试，我会合到dev分支上随新版本发布时再合到master分支上。",charsets:{cjk:!0},lastUpdated:"2022/07/18, 19:21:45",lastUpdatedTimestamp:1658143305e3},{title:"关于作者",frontmatter:{id:"about_author",title:"关于作者",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/about_author/"},regularPath:"/%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85.html",relativePath:"关于作者.md",key:"v-d5edb880",path:"/pages/about_author/",headers:[{level:3,title:"网络账号",slug:"网络账号",normalizedTitle:"网络账号",charIndex:2},{level:3,title:"职业发展",slug:"职业发展",normalizedTitle:"职业发展",charIndex:100},{level:3,title:"开源经历",slug:"开源经历",normalizedTitle:"开源经历",charIndex:212},{level:3,title:"兴趣爱好",slug:"兴趣爱好",normalizedTitle:"兴趣爱好",charIndex:481},{level:3,title:"我的公众号",slug:"我的公众号",normalizedTitle:"我的公众号",charIndex:568}],headersStr:"网络账号 职业发展 开源经历 兴趣爱好 我的公众号",content:"# 网络账号\n\n * 网名：公子骏\n * gitee：https://gitee.com/dt_flys\n * github: https://github.com/mySingleLive\n\n\n# 职业发展\n\n在上海一家垂直电商工作，担任后台架构师。从事Java后端已有10年，主要专注于架构、微服务、分布式等领域，也会研究机器学习、算法等业界新技术。\n\n同时目前在中国人民大学读在职研究生，计算机应用技术专业。\n\n\n# 开源经历\n\n热爱开源，经常造些轮子，比如自制编程语言、基础框架等玩意儿。\n\n * Soya语言： 一款基于JVM的动态语言，语法结合了Java、Coffee、以及Rebol等语言的特性，并编译为Java字节码再运行。这是我早期的一个开源项目，现已不再维护。\n\n * Forest： Forest是我最近的一个开源项目，它以RPC的形式进行HTTP请求调用，目前我个人维护，并且会一直迭代和维护下去。如果Forest对您有帮助，或喜欢这个项目，请在Gitee或GitHub上为我Star，开源不易，您的宝贵支持是我坚持下去的动力！\n\n\n# 兴趣爱好\n\n喜欢音乐，会作曲/编曲，这是我的专辑曲目，水平不咋样，如不幸点进去就当听个响~\n\n喜欢技术，喜欢开源，喜欢造轮子，喜欢上Gitee和开源中国 (◠‿◠)\n\n\n# 我的公众号\n\n我的公众号还目前没啥文章和内容，主要是加入Forest技术群的渠道\n\n",normalizedContent:"# 网络账号\n\n * 网名：公子骏\n * gitee：https://gitee.com/dt_flys\n * github: https://github.com/mysinglelive\n\n\n# 职业发展\n\n在上海一家垂直电商工作，担任后台架构师。从事java后端已有10年，主要专注于架构、微服务、分布式等领域，也会研究机器学习、算法等业界新技术。\n\n同时目前在中国人民大学读在职研究生，计算机应用技术专业。\n\n\n# 开源经历\n\n热爱开源，经常造些轮子，比如自制编程语言、基础框架等玩意儿。\n\n * soya语言： 一款基于jvm的动态语言，语法结合了java、coffee、以及rebol等语言的特性，并编译为java字节码再运行。这是我早期的一个开源项目，现已不再维护。\n\n * forest： forest是我最近的一个开源项目，它以rpc的形式进行http请求调用，目前我个人维护，并且会一直迭代和维护下去。如果forest对您有帮助，或喜欢这个项目，请在gitee或github上为我star，开源不易，您的宝贵支持是我坚持下去的动力！\n\n\n# 兴趣爱好\n\n喜欢音乐，会作曲/编曲，这是我的专辑曲目，水平不咋样，如不幸点进去就当听个响~\n\n喜欢技术，喜欢开源，喜欢造轮子，喜欢上gitee和开源中国 (◠‿◠)\n\n\n# 我的公众号\n\n我的公众号还目前没啥文章和内容，主要是加入forest技术群的渠道\n\n",charsets:{cjk:!0},lastUpdated:"2022/07/18, 19:21:45",lastUpdatedTimestamp:1658143305e3},{title:"支持 Forest",frontmatter:{id:"donate",title:"支持 Forest",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/donate/"},regularPath:"/%E6%94%AF%E6%8C%81.html",relativePath:"支持.md",key:"v-2ccc5a68",path:"/pages/donate/",headers:[{level:2,title:"用爱发电",slug:"用爱发电",normalizedTitle:"用爱发电",charIndex:129},{level:2,title:"成为赞助商",slug:"成为赞助商",normalizedTitle:"成为赞助商",charIndex:275},{level:2,title:"赞助企业",slug:"赞助企业",normalizedTitle:"赞助企业",charIndex:557},{level:2,title:"赞助人列表",slug:"赞助人列表",normalizedTitle:"赞助人列表",charIndex:650}],headersStr:"用爱发电 成为赞助商 赞助企业 赞助人列表",content:"开源承诺\n\nForest作为开源项目发展到现在，全靠社区的支持和贡献。我们承诺Forest将永远免费提供给大家。\n\n但为了项目能够良好健康的发展下去，我们也需要一些额外的支持。\n\n如果您觉得Forest有用或对您有帮助，那么我们也期待您的有力支持。\n\n\n# 用爱发电\n\n如果您正在使用这个项目并感觉良好，或是想支持我们继续开发，您可以通过如下方式支持我们：\n\n1.Star并向您的朋友推荐或分享 Forest🚀\n\n2.轻轻点击一次文档中最上面的AD🙃\n\n3.通过以下二维码进行一次性捐款赞助，请作者喝一杯咖啡☕️\n\n非常感谢！❤️\n\n\n\n\n\n# 成为赞助商\n\n1.赞助任意金额，您将获得 赞助者列表 的永久留名。\n\n2.赞助达到20元，您将获得 赞助者列表 的永久留名，并可附上在赞助者列表里的投放链接。\n\n3.赞助达50元，您额外获得 Forest的私下VIP 1对1的技术咨询服务（长达1年）。\n\n4.赞助达100元，您将额外同时获得 Forest文档首页的特别赞助广告展示栏位（长达1年）。\n\n5.赞助达200元，您将额外同时获得 Forest文档首页右上角推荐位和首页下方特别赞助2个栏位（长达1年）。\n\n6.赞助达500元，您将额外同时获得 Forest所有文档页面的广告栏位（长达1年）。\n\n\n# 赞助企业\n\nLOGO   赞助企业      金额                 附言\n       众创逸云企业云   一台云服务器（价值2000左右）   你的开源很好用\n\n\n# 赞助人列表\n\n注: 赞助按捐赠的时间排序\n\n赞助人ID        金额           附言\nbryan31      10           感谢您的开源项目！\nsamuel       10           感谢您的开源项目！\nTsujiShiki   1            支持！\nDrXDr        10           Thank you for your open source project!\nabel533      1            感谢您的开源项目！\nMeng🐳       微信红包 2       来兄弟 抽根华子\n石大宝 daddy    微信红包 50      感谢为中国开源做出的杰出贡献\n铂赛东          微信赞赏码 10     牛逼啊，支持下\nETLGRN       微信赞赏码 10     在使用 支持一下\n123456       微信赞赏码 50     支持大佬\n彼岸花开         微信赞赏码 5      彼岸花开\n说有万里山        微信赞赏码 10     感谢开源\n达思           微信赞赏码 20     很棒的开源项目\nZhong Fan    微信赞赏码 1      \nkgotec       微信赞赏码 1.10   就是我\n🇲 🇽 🇲     微信赞赏码 10     不错，继续努力。\n🔆 阿童木。      微信赞赏码 20     加油\n田志利คิดถึง    微信赞赏码 3.08   感谢大佬的开源\n长安           微信赞赏码 100    支持开源轮子\n云            微信赞赏码 50     加油加油\nk1ngl1ng🤩   微信赞赏码 10     鼎力支持\npool         微信赞赏码 10     \n侯坤林          微信赞赏码 10     \n吴雷明          微信赞赏码 10     感谢作者开源\n孤单枪手         微信赞赏码 50     \n倾城           微信赞赏码 10     \n毓鹏           微信赞赏码 5      祝forest前程似锦\n邢爱明          微信赞赏码 10     简单用过forest，简单易用，一点小心意，希望能持续做下去\n米米酥乄         微信赞赏码 10     😀😀😀😀😀😀😀😀😀😀😀\n飞鸿雪泥         微信赞赏码 10     支持！\n谢新           微信赞赏码 5      工具非常好用，支持支持\nhim enough   微信赞赏码 10     nice\n伍世宇          微信赞赏码 6.66   很棒的开源项目\n时间、抹平一切      微信赞赏码 5      刚开始推广的时候就用了，很好用，奈斯\n云自遥          微信赞赏码 10     支持开源\n蜜蜂🐝🐝       微信赞赏码 10     感谢大佬\ncrazy        微信赞赏码 1      很棒的开源项目，持续迭代下去哟\n孤身纵马一骑绝尘     微信赞赏码 10     THOMAS\nH__k         微信赞赏码 5      祝forest越来越好，愿作者一直坚持下去！\n十一的老父亲       微信赞赏码 20     谢谢分享\n天空           微信赞赏码 1      加油\nxmchen       微信赞赏码 5      YYDS\n😶           微信赞赏码 10     😐🙄\n左手           微信赞赏码 10     加油\n程浩           微信赞赏码 5      牛逼666\nFirework     微信赞赏码 10     牛批的项目，支持一下\n彼岸花开         微信赞赏码 10     点赞\n风迷了眼         微信赞赏码 10     大佬 加油啊\n那个男人         微信赞赏码 10     不错，很优雅\nせんせい         微信赞赏码 5      非常好用 省了不少代码\nAIFeng🍁     微信赞赏码 10     成为 Forest 的赞助商\n**尚          支付宝收款码 20    refacter\n**夫          支付宝收款码 10    感谢开源",normalizedContent:"开源承诺\n\nforest作为开源项目发展到现在，全靠社区的支持和贡献。我们承诺forest将永远免费提供给大家。\n\n但为了项目能够良好健康的发展下去，我们也需要一些额外的支持。\n\n如果您觉得forest有用或对您有帮助，那么我们也期待您的有力支持。\n\n\n# 用爱发电\n\n如果您正在使用这个项目并感觉良好，或是想支持我们继续开发，您可以通过如下方式支持我们：\n\n1.star并向您的朋友推荐或分享 forest🚀\n\n2.轻轻点击一次文档中最上面的ad🙃\n\n3.通过以下二维码进行一次性捐款赞助，请作者喝一杯咖啡☕️\n\n非常感谢！❤️\n\n\n\n\n\n# 成为赞助商\n\n1.赞助任意金额，您将获得 赞助者列表 的永久留名。\n\n2.赞助达到20元，您将获得 赞助者列表 的永久留名，并可附上在赞助者列表里的投放链接。\n\n3.赞助达50元，您额外获得 forest的私下vip 1对1的技术咨询服务（长达1年）。\n\n4.赞助达100元，您将额外同时获得 forest文档首页的特别赞助广告展示栏位（长达1年）。\n\n5.赞助达200元，您将额外同时获得 forest文档首页右上角推荐位和首页下方特别赞助2个栏位（长达1年）。\n\n6.赞助达500元，您将额外同时获得 forest所有文档页面的广告栏位（长达1年）。\n\n\n# 赞助企业\n\nlogo   赞助企业      金额                 附言\n       众创逸云企业云   一台云服务器（价值2000左右）   你的开源很好用\n\n\n# 赞助人列表\n\n注: 赞助按捐赠的时间排序\n\n赞助人id        金额           附言\nbryan31      10           感谢您的开源项目！\nsamuel       10           感谢您的开源项目！\ntsujishiki   1            支持！\ndrxdr        10           thank you for your open source project!\nabel533      1            感谢您的开源项目！\nmeng🐳       微信红包 2       来兄弟 抽根华子\n石大宝 daddy    微信红包 50      感谢为中国开源做出的杰出贡献\n铂赛东          微信赞赏码 10     牛逼啊，支持下\netlgrn       微信赞赏码 10     在使用 支持一下\n123456       微信赞赏码 50     支持大佬\n彼岸花开         微信赞赏码 5      彼岸花开\n说有万里山        微信赞赏码 10     感谢开源\n达思           微信赞赏码 20     很棒的开源项目\nzhong fan    微信赞赏码 1      \nkgotec       微信赞赏码 1.10   就是我\n🇲 🇽 🇲     微信赞赏码 10     不错，继续努力。\n🔆 阿童木。      微信赞赏码 20     加油\n田志利คิดถึง    微信赞赏码 3.08   感谢大佬的开源\n长安           微信赞赏码 100    支持开源轮子\n云            微信赞赏码 50     加油加油\nk1ngl1ng🤩   微信赞赏码 10     鼎力支持\npool         微信赞赏码 10     \n侯坤林          微信赞赏码 10     \n吴雷明          微信赞赏码 10     感谢作者开源\n孤单枪手         微信赞赏码 50     \n倾城           微信赞赏码 10     \n毓鹏           微信赞赏码 5      祝forest前程似锦\n邢爱明          微信赞赏码 10     简单用过forest，简单易用，一点小心意，希望能持续做下去\n米米酥乄         微信赞赏码 10     😀😀😀😀😀😀😀😀😀😀😀\n飞鸿雪泥         微信赞赏码 10     支持！\n谢新           微信赞赏码 5      工具非常好用，支持支持\nhim enough   微信赞赏码 10     nice\n伍世宇          微信赞赏码 6.66   很棒的开源项目\n时间、抹平一切      微信赞赏码 5      刚开始推广的时候就用了，很好用，奈斯\n云自遥          微信赞赏码 10     支持开源\n蜜蜂🐝🐝       微信赞赏码 10     感谢大佬\ncrazy        微信赞赏码 1      很棒的开源项目，持续迭代下去哟\n孤身纵马一骑绝尘     微信赞赏码 10     thomas\nh__k         微信赞赏码 5      祝forest越来越好，愿作者一直坚持下去！\n十一的老父亲       微信赞赏码 20     谢谢分享\n天空           微信赞赏码 1      加油\nxmchen       微信赞赏码 5      yyds\n😶           微信赞赏码 10     😐🙄\n左手           微信赞赏码 10     加油\n程浩           微信赞赏码 5      牛逼666\nfirework     微信赞赏码 10     牛批的项目，支持一下\n彼岸花开         微信赞赏码 10     点赞\n风迷了眼         微信赞赏码 10     大佬 加油啊\n那个男人         微信赞赏码 10     不错，很优雅\nせんせい         微信赞赏码 5      非常好用 省了不少代码\naifeng🍁     微信赞赏码 10     成为 forest 的赞助商\n**尚          支付宝收款码 20    refacter\n**夫          支付宝收款码 10    感谢开源",charsets:{cjk:!0},lastUpdated:"2022/07/19, 00:54:05",lastUpdatedTimestamp:1658163245e3},{title:"更新记录",frontmatter:{id:"releases",title:"更新记录",date:"2022-07-01T12:44:20.000Z",permalink:"/pages/releases/"},regularPath:"/%E5%8F%91%E5%B8%83%E8%AE%B0%E5%BD%95.html",relativePath:"发布记录.md",key:"v-044a573f",path:"/pages/releases/",headersStr:null,content:"v1.5.25\n\n * fix: 匹配验证secure cookie\n * fix: cookie携带请求不成功 (#I5F8IY)\n * fix: OKHTTP 连接泄漏问题 (#I5E613)\n * fix: forest 支持springboot 1.5.14.realese 启动失败 (#I5FDBG)\n * fix: 传的参数带有+号，但是服务接收时，获取的参数值中+号全部变成空格了 (#I5EG9L)\n * add: OkHttp3Cookie\n * add: HttpclientCookie\n * update: 更新jackson版本到2.13.3\n * update: 更新jackson-databind版本到2.13.3\n * update: 更新jackson-annotations版本到2.13.3\n * update: 更新gson版本到2.8.9\n * update: 更新fastjson版本到1.2.83\n\nv1.5.24\n\n * fix: OKHTTP 连接泄漏问题 (#I5E613)\n * fix: 遇到无法解析的Cookie时会报空指针 (#I5E27R)\n\nv1.5.23\n\n * feat: 快速接口支持快速下载文件\n * feat: 可配置注入OkHttpClient和HttpClient对象 (#I5CWAL)\n * feat: 可配置接口的后端Client对象是否缓存 (#I5D818)\n * fix: springboot配置binary转换器初始化失败 (#I5D07S)\n * fix: ForestResponse.statusIs(xxx)会出现空指针 (#I5CWQL)\n * fix: 在@Address注解的basePath中写的端口号会失效 (#I5CR15)\n * fix: 使用@HTTPProxy注解对https请求设置http代理后出现java.lang.IllegalArgumentException:Socket may not be null\n * fix: 在不设置ContentType和BodyType的情况下无法正常发送请求 (#I5CML4)\n * fix: ForestRequest.addBody(List) 循环中只执行一次\n * refactor: 重构Cookie (#I5C26U)\n * refactor: 重构OkHttpClient\n * add: 添加拦截器到请求中方法ForestRequest#addInterceptor(Class<? extends Interceptor>)\n * add: HttpClientFactory\n * add: OkHttpClientFactory\n\nv1.5.22\n\n * feat: 统一连接池 (#I5APJA)\n * feat: 可配置异步请求线程池队列大小 (#I5B78X)\n * feat: 支持通过参数定义返回类型 (#I5ANZL)\n * fix: spring 5.1 以下的低版本启动失败\n * fix: 请求地址中包含#字符会被转义导致资源找不到 (#I59O7M)\n * fix: 配置BaseRequest的baseURL属性后,完整请求路径中的默认端口号会被覆盖,导致请求失败 (#I4YBDV)\n * fix: 解决当@body注解在对象上标识以后，char&Character类型的属性无法从客户端传输至服务端问题\n * fix: kotlin项目启动异常 (#I50PDZ)\n * fix: RetryWhen重试条件接口在最后一次重试后会执行两次 (#I599BT)\n * update: #I5ANZR 删除单元测试代码中的Log4j2依赖\n\nv1.5.21\n\n * feat: 字符串模板支持手动URLEncode (#I58D1C)\n * fix: url在某些场景下的解析错误 (#I56XDM)\n\nv1.5.20\n\n * feat: 支持JDK17，兼容从8、11到17所有JDK版本\n * fix: BaseRequest 设置connectTimeout和readTimeout没效果 (#I4Z8Y0)\n * fix: 下载，内存溢出 (#I4NFPE)\n * fix: AddressSource 里面配置 basePath 不生效 (#I50LVA)\n\nv1.5.19\n\n * fix: 在原生Spring环境中，拦截器无法注入Spring上下文 (#I4UE9T)\n * fix: httpclient后端的https连接池并发时数据会串 (#I4TYJ1)\n * fix: 响应头两个 Set-Cookie 的时候只能取到最后一个 (#I4TATV)\n * refactor: 去掉 commons-logging 包的依赖\n\nv1.5.17\n\n * feat: 动态正向代理来源信息 (#I4SYM1)\n * fix: 异常：The file of SSL KeyStore is empty (#I4SYGB)\n * fix: maxRetryInterval配置失效 (#I4SV2P)\n * fix: 主项目没有依赖lang3会报错的问题 (#I4M9DE)\n * fix: 组合注解未生效 (#I4N2HC)\n * refactor: 去掉 NameUtils 工具类中重复的if分支\n\nv1.5.16\n\n * feat: 自定义 hostnameVerifier 和 SSLSocketFactoryBuilder (#I4LGW8)\n * feat: 根据Response的Content-Encoding自动识别是否为gzip压缩数据，并自动解压\n * fix: 重定向后URL的Query参数会重复增加 (#I4LPGU)\n * fix: 修复content-encoding导致的字符编码转换异常 (#I4LJ3X)\n * fix: 修复字符编码判断的BUG\n * add: @SSLHostnameVerifier 注解\n * add: @SSLSocketFactoryBuilder 注解\n\nv1.5.14\n\n * feat: 支持设置异步请求的线程池大小 (#I4JXN3)\n * feat: ForestBody对象添加获取所有键值对的方法（包括对象Body项） (#I4JDRR)\n * fix: URL中包含@，会去掉@ (#I4J3LU)\n * add: AsyncAbortPolicy类\n * add: ForestBody.nameValuesMapWithObject\n\nv1.5.13\n\n * feat: 指定请求体类型的@BodyType注解 (#I4IF3N)\n * feat: 新增获取全部请求体中键值对参数的方法 (#I4GWO7)\n * fix: 在请求中设置自定义Encoder无效 (#I4HNZF)\n * fix: url解析问题，如果包含@符@会去掉 (#I4GQWW)\n * add: BodyType注解\n * add: FastjsonEncoder注解\n * add: GsonEncoder注解\n * add: JacksonEncoder注解\n * delete: com.dtflys.forest.http.ForestBodyType类\n * update: ForestRequest类的setBodyType方法和bodyType方法的参数类型改为ForestDataType\n\nv1.5.12\n\n * feat: getbody可以有key-value形式进行取值 (#I4FUSB)\n * fix: URL参数会重复Encode (#I4FDJC)\n * fix: {变量名}格式字符串模板在引用隐式变量时出错 (#I4EP04)\n * fix: 对于http://localhost/xxx:yyy这种形式的URL解析错误 (#I4GC5M)\n * fix: httpclient和okhttp编码行为不一致 (#I4FRR5)\n * fix: post请求的url为空的时候有bug (#I4F3XS)\n * fix: retrywhen中的异常被吃掉, 无法抛出. 且异常后仅触发一次重试 (#I4E4X7)\n * fix: Httpclient后端在连续异步发送请求后会出现I/IO报错 (#I47FD7)\n * optimize: Forest对于一些错误的响应处理不友好 (#I4EIDJ)\n * refactor: 重构后端代码: 表单类型Body部分\n * refactor: 重构后端: okhttp3\n * refactor: 重构后端: httpclient\n * refactor: 重构后端: 重写异步请求逻辑\n * add: ForestBody类\n * add: Validations类\n * delete: OkHttp3不再使用的请求执行器类\n\nv1.5.11\n\n * fix: connect-timeout配置在springboot 1.x 版本下无法解析 (#I4ECR3)\n * optimize: 增强字符串模板报错信息 (#I4EC9V)\n\nv1.5.10\n\n * fix: 重新URL解析后，引起的空指针问题\n\nv1.5.9\n\n * fix: URI路径的URLEncoder编码结果不正确 (#I4DUFG)\n\nv1.5.8\n\n * fix: 使用@DownloadFile下载文件时，在某些环境下会发送阻塞 (#I4DLBI)\n\nv1.5.7\n\n * fix: response对google protobuf包依赖 (#I4DKQW)\n\nv1.5.6\n\n * feat: 将timeout细化为connectTimeout和readTimeout (#I4DH21)\n * fix: Google Protobuf包依赖错误 (#I4DDZY)\n * fix: 配置forest.connect-timeout不生效 (#I45298)\n\nv1.5.5\n\n * feat: 支持每个请求都可自定义序列化转换器 (#I4CLV8)\n * feat: 二进制类型请求体 (#I4D4GY)\n * feat: Protobuf请求体 (#I4D4JT)\n * feat: 转换器对应包依赖 需要时获取 (#I29XE0)\n * fix: getAttribute方法在多线程情况下取值会串 (#I4D5KS)\n * fix: 在onRetry方法中，调用 addQuery 或 addBody 能API无效 (#I4CZS5)\n * add: @OkHttp3 注解\n * add: @HttpClient 注解\n * add: ForestRequest.type(ForestRequestType type) 方法\n * add: ForestLogHandler.logContent(String content) 方法\n\nv1.5.4\n\n * fix: 依赖Guava包 (#I4CC9B)\n * fix: @Query注解修饰Map参数时，Map中的列表属性无法正常序列化 (#I4C8UC)\n * fix: 多线程下的并发问题\n * update: 去掉多余的DEBUG日志\n * add: ForestLogHandler.logContent(String content) 方法\n * add: ForestRequest.addQuery(String name, Collection collection) 方法\n * add: ForestRequest.addQuery(String name, Object... array) 方法\n * add: ForestRequest.addArrayQuery(String name, Collection collection) 方法\n * add: ForestRequest.addArrayQuery(String name, Object... array) 方法\n\nv1.5.3\n\n * feat: Forest快捷接口 (#I4893Q)\n * feat: 支持全局变量动态绑定方法 (#I478N2)\n * feat: 支持引用properties的字符串模板 (#I3P1QK)\n * feat: 支持获取响应原因短语，即响应状态文本 (#I4BJVF)\n * feat: 自定义组合注解 (#I4BISF)\n * feat: 可自定义请求是否成功的条件 (#I4AEMT)\n * feat: 可动态设置主机地址和端口号 (#I4AEJ8)\n * feat: 自定义重试条件 (#I493N3)\n * feat: 新增 OnRetry 回调函数 (#I493N6)\n * feat: 新增 @Headers 注解 (#I4BJQ6)\n * feat: Forest请求接口继承规则 (#I4B0N7)\n * feat: 自动重定向控制 (#I4B0FM)\n * feat: 全局变量支持动态绑定方法 (#I478N2)\n * feat: 在请求日志中显示后端框架名称 (#I4AKTD)\n * feat: 新建forest-mock子项目 (#I468JB)\n * fix: POST请求中，空Map无法转成{} JSON字符串 (#I455O2)\n * fix: 过滤器参数总是为第一个参数 (#I43VV0)\n * fix: 自定义请求头content-type会替换为大写 (#I46WNW)\n * fix: 在Spring项目中如果不配置转换器就会找不到Converter (#I46FKV)\n * fix: Response不带Content-Type和Content-Encoding头时无法正常解析 (#I455PO)\n * fix: 当请求 302 请求时，Forest 会自动的访问重定向的url，导致 302 的响应头拿不到 (#I4AF3B)\n * fix: SpringSSLKeyStore 在Spring中初始化失败\n * fix: 配置有ForestConfiguration参数的转换器的时候，在springboot中会初始化失败 (#I4AKT3)\n * fix: 在多线程环境下使用上传文件接口，运行时间长后会报出堆栈溢出的错误 (#I37UGY)\n * fix: BeanPostProcessor 接口在低版本 springboot 环境下不兼容\n * opt: 优化 StringUtils 工具类方法\n * opt: 优化 URLUtils 工具类方法\n * add: SpringForestProperties类\n * add: 在所有请求注解中(如 @Request, @Get)添加 responseEncoding 属性，用于强制指定响应数据的编码格式\n * add: SpringForestObjectFactory类\n * add: ForestResponse.isRedirection 方法\n * add: ForestResponse.getRedirectionLocation 方法\n * add: ForestResponse.redirectionRequest 方法\n * add: ForestHeaderMap.clone 方法\n * add: ForestQueryMap.clone 方法\n * refactor: retryCount属性不在建议使用\n * update: 去掉MethodLifeCycle\n * refactor: 修改Forest接口扫描逻辑\n * refactor: 将 TypeReference 类改为抽象类\n\nv1.5.1\n\n * feat: 添加@URLEncode注解 (#I3SR0L)\n * feat: 新增强制UrlEncoded的字符串模板 (#I3P1R0)\n * feat: 支持对gzip格式返回数据进行解压 (#I3SUSL)\n * feat: spring项目通过定义Bean自动从Spring上下文中注入对应的ForestConverter (#I3E63M)\n * fix: 在JSON或XML转换失败后，没有直接报错，而是转成了字符串 (#I3IUKC)\n * fix: 在GET请求时带有空的body实体 (#I3RBR2)\n * fix: 去掉protobuf decoder 根据返回类型序列化\n * fix: 代理 (#I3E1MF)\n * fix: 遇到非application/json的Response Header无法正常解析JSON (#I3AJSD)\n * fix: 调用configuration.getLogHandler().setLogger()方法无效 (#I3IUKD)\n * fix: okhttp后端情况下，response返回gzip或deflate压缩数据解析乱码 (#I3A54I)\n * fix: 单向SSL不填protocol时报空指针\n * fix: statusCode空指针\n * fix: status在非网络错误情况下为404\n * fix: 修改方法名拼写错误 getDateType -> getDataType\n * update: 修改gson版本 -> 2.8.6\n * refactor: 指定统一的spring-boot版本\n * update: 去掉QLExpress\n * add: @URLEncode注解\n * add: URLEncodeLifeCycle类\n\nv1.5.0\n\n * feat: 支持application/octet-stream等二进制请求方式 (#I3B3UZ)\n * feat: 变量未定义时，报错给予更友好的提示 (#I3DOAP)\n * feat: 添加@Var注解，作为@DataVariable注解的简化快捷版本 (#I3E0FD)\n * fix: ForestResponse<File>作为返回值使用@DownloadFile注解进行下载后getResult()为空(#I3DAEQ)\n * add: ForestConfiguration#isVariableDefined方法\n * add: @Var注解\n * add: ResourceRequestBody类\n * add: ResourceRequestBodyBuilder类\n * add: MultipartRequestBody类\n * add: MultipartRequestBodyBuilder类\n * add: SupportFormUrlEncoded类\n * refactor: 将DataVariableLifeCycle改名为VariableLifeCycle\n * refactor: Body的解析方式改为构建器模式\n * refactor: ForestVariableUndefined.java 改名为 ForestVariableUndefinedException\n * update: 更新Spring-Core和Spring-Webmvc版本\n * update: 更新JUnit版本\n\nv1.5.0-RC7\n\n * fix: 反序列化XML为泛型类对象时报错 (#I3B5VH)\n * fix: 全局配置的log-handler不起作用 (#I3B49O)\n\nv1.5.0-RC6\n\n * feat: @LogHandler 和 @LogEnabled 注解作用域添加 ElementType.TYPE级别(#I3AHLC)\n * feat: Query参数可以选择是否urlencoded\n * fix: 遇到非application/json的Response Header无法正常解析JSON (#I3AJSD)\n * fix: 多模块开发多个@ForestScan注解只能扫描到其中一个注解的basePackages\n * fix: 基本类型判断漏掉了boolean\n * refactor: 将 gourpid 'spring-boot-starter-forest' 改为 'forest-spring-boot-starter'\n * refactor: 将 spring-boot-starter-forest 模块改名为 forest-spring-boot-starter\n * refactor: 将forest-spring-boot-starter模块下的包名修改为 'com.dtflys.forest.springboot'\n\nv1.5.0-RC5\n\n * feat: 可以从ForestResponse对象获取请求总耗时 (#I39O55)\n * fix: LogEnabled注解的logResponseContent在请求失败的情况下无效 (#I39M2G)\n * add: ForestResponse.requestTime属性\n * add: ForestResponse.responseTime属性\n * add: ForestResponse.getTimeAsMillisecond方法\n\nv1.5.0-RC4\n\n * fix: 请求不能设置proxy用户名和密码 (#I36SJ8)\n * fix: https的url字符串会自动去掉 :80 端口部分 (#I38KEJ)\n\nv1.5.0-RC3\n\n * fix: 全局配置重试次数，对 [Forest] [Network Error]: Read timed out 错误无效 (#I34X5D)\n * fix: URL井号(#)后面字符串没有encoding\n * fix: httpclient后端处理Cookie时产生'Invalid cookie header'的问题\n * refactor: 实现Interceptor接口时，不必强制实现onSuccess方法和onError方法\n\nv1.5.0-RC2\n\n * feat: 支持负数的字符串模板下标引用 (#I2BF4N)\n * feat: @Query, @Body, @Header注解支持defaultValue默认值属性\n * fix: Fastjson使用JSONField注解的format属性设置日期格式没起效果 (#I29BFM)\n * refactor: 去掉多余的System.out.println命令行输出\n * refactor: forest在spring的xml配置部分\n * add: @Query, @Body, @Header注解的defaultValue属性\n * add: jsr305依赖\n * add: ForestRequest.methodReturn方法和ForestRequest.getMethodReturnValue方法\n * update: 将错误拼写的方法名 handleSyncWicthException 改为 handleSyncWithException\n\nv1.5.0-RC1\n\n * feat: 处理Cookie (#I1QR18)\n * feat: 通过@FormBody注解将参数标识为表单格式的请求体 (#I28MY5)\n * feat: @Request、@Get、@Post等请求注解支持增加value属性作为url属性的别名 (#I28FWM)\n * feat: 可以将Response返回的\"true\"， \"false\"字符串转换成Boolean返回类型 (#I281O0)\n * fix: 用httpclient的方式上传文件会不成功，但用okhttp就是成功的 (#I28SA1)\n * fix: 遇到一些自定义的Response Content-Type，无法正常读取响应内容 (#I28PL7)\n * add: ForestCookies类\n * add: ForestCookie类\n * add: OnLoadCookie接口\n * add: OnSaveCookie接口",normalizedContent:"v1.5.25\n\n * fix: 匹配验证secure cookie\n * fix: cookie携带请求不成功 (#i5f8iy)\n * fix: okhttp 连接泄漏问题 (#i5e613)\n * fix: forest 支持springboot 1.5.14.realese 启动失败 (#i5fdbg)\n * fix: 传的参数带有+号，但是服务接收时，获取的参数值中+号全部变成空格了 (#i5eg9l)\n * add: okhttp3cookie\n * add: httpclientcookie\n * update: 更新jackson版本到2.13.3\n * update: 更新jackson-databind版本到2.13.3\n * update: 更新jackson-annotations版本到2.13.3\n * update: 更新gson版本到2.8.9\n * update: 更新fastjson版本到1.2.83\n\nv1.5.24\n\n * fix: okhttp 连接泄漏问题 (#i5e613)\n * fix: 遇到无法解析的cookie时会报空指针 (#i5e27r)\n\nv1.5.23\n\n * feat: 快速接口支持快速下载文件\n * feat: 可配置注入okhttpclient和httpclient对象 (#i5cwal)\n * feat: 可配置接口的后端client对象是否缓存 (#i5d818)\n * fix: springboot配置binary转换器初始化失败 (#i5d07s)\n * fix: forestresponse.statusis(xxx)会出现空指针 (#i5cwql)\n * fix: 在@address注解的basepath中写的端口号会失效 (#i5cr15)\n * fix: 使用@httpproxy注解对https请求设置http代理后出现java.lang.illegalargumentexception:socket may not be null\n * fix: 在不设置contenttype和bodytype的情况下无法正常发送请求 (#i5cml4)\n * fix: forestrequest.addbody(list) 循环中只执行一次\n * refactor: 重构cookie (#i5c26u)\n * refactor: 重构okhttpclient\n * add: 添加拦截器到请求中方法forestrequest#addinterceptor(class<? extends interceptor>)\n * add: httpclientfactory\n * add: okhttpclientfactory\n\nv1.5.22\n\n * feat: 统一连接池 (#i5apja)\n * feat: 可配置异步请求线程池队列大小 (#i5b78x)\n * feat: 支持通过参数定义返回类型 (#i5anzl)\n * fix: spring 5.1 以下的低版本启动失败\n * fix: 请求地址中包含#字符会被转义导致资源找不到 (#i59o7m)\n * fix: 配置baserequest的baseurl属性后,完整请求路径中的默认端口号会被覆盖,导致请求失败 (#i4ybdv)\n * fix: 解决当@body注解在对象上标识以后，char&character类型的属性无法从客户端传输至服务端问题\n * fix: kotlin项目启动异常 (#i50pdz)\n * fix: retrywhen重试条件接口在最后一次重试后会执行两次 (#i599bt)\n * update: #i5anzr 删除单元测试代码中的log4j2依赖\n\nv1.5.21\n\n * feat: 字符串模板支持手动urlencode (#i58d1c)\n * fix: url在某些场景下的解析错误 (#i56xdm)\n\nv1.5.20\n\n * feat: 支持jdk17，兼容从8、11到17所有jdk版本\n * fix: baserequest 设置connecttimeout和readtimeout没效果 (#i4z8y0)\n * fix: 下载，内存溢出 (#i4nfpe)\n * fix: addresssource 里面配置 basepath 不生效 (#i50lva)\n\nv1.5.19\n\n * fix: 在原生spring环境中，拦截器无法注入spring上下文 (#i4ue9t)\n * fix: httpclient后端的https连接池并发时数据会串 (#i4tyj1)\n * fix: 响应头两个 set-cookie 的时候只能取到最后一个 (#i4tatv)\n * refactor: 去掉 commons-logging 包的依赖\n\nv1.5.17\n\n * feat: 动态正向代理来源信息 (#i4sym1)\n * fix: 异常：the file of ssl keystore is empty (#i4sygb)\n * fix: maxretryinterval配置失效 (#i4sv2p)\n * fix: 主项目没有依赖lang3会报错的问题 (#i4m9de)\n * fix: 组合注解未生效 (#i4n2hc)\n * refactor: 去掉 nameutils 工具类中重复的if分支\n\nv1.5.16\n\n * feat: 自定义 hostnameverifier 和 sslsocketfactorybuilder (#i4lgw8)\n * feat: 根据response的content-encoding自动识别是否为gzip压缩数据，并自动解压\n * fix: 重定向后url的query参数会重复增加 (#i4lpgu)\n * fix: 修复content-encoding导致的字符编码转换异常 (#i4lj3x)\n * fix: 修复字符编码判断的bug\n * add: @sslhostnameverifier 注解\n * add: @sslsocketfactorybuilder 注解\n\nv1.5.14\n\n * feat: 支持设置异步请求的线程池大小 (#i4jxn3)\n * feat: forestbody对象添加获取所有键值对的方法（包括对象body项） (#i4jdrr)\n * fix: url中包含@，会去掉@ (#i4j3lu)\n * add: asyncabortpolicy类\n * add: forestbody.namevaluesmapwithobject\n\nv1.5.13\n\n * feat: 指定请求体类型的@bodytype注解 (#i4if3n)\n * feat: 新增获取全部请求体中键值对参数的方法 (#i4gwo7)\n * fix: 在请求中设置自定义encoder无效 (#i4hnzf)\n * fix: url解析问题，如果包含@符@会去掉 (#i4gqww)\n * add: bodytype注解\n * add: fastjsonencoder注解\n * add: gsonencoder注解\n * add: jacksonencoder注解\n * delete: com.dtflys.forest.http.forestbodytype类\n * update: forestrequest类的setbodytype方法和bodytype方法的参数类型改为forestdatatype\n\nv1.5.12\n\n * feat: getbody可以有key-value形式进行取值 (#i4fusb)\n * fix: url参数会重复encode (#i4fdjc)\n * fix: {变量名}格式字符串模板在引用隐式变量时出错 (#i4ep04)\n * fix: 对于http://localhost/xxx:yyy这种形式的url解析错误 (#i4gc5m)\n * fix: httpclient和okhttp编码行为不一致 (#i4frr5)\n * fix: post请求的url为空的时候有bug (#i4f3xs)\n * fix: retrywhen中的异常被吃掉, 无法抛出. 且异常后仅触发一次重试 (#i4e4x7)\n * fix: httpclient后端在连续异步发送请求后会出现i/io报错 (#i47fd7)\n * optimize: forest对于一些错误的响应处理不友好 (#i4eidj)\n * refactor: 重构后端代码: 表单类型body部分\n * refactor: 重构后端: okhttp3\n * refactor: 重构后端: httpclient\n * refactor: 重构后端: 重写异步请求逻辑\n * add: forestbody类\n * add: validations类\n * delete: okhttp3不再使用的请求执行器类\n\nv1.5.11\n\n * fix: connect-timeout配置在springboot 1.x 版本下无法解析 (#i4ecr3)\n * optimize: 增强字符串模板报错信息 (#i4ec9v)\n\nv1.5.10\n\n * fix: 重新url解析后，引起的空指针问题\n\nv1.5.9\n\n * fix: uri路径的urlencoder编码结果不正确 (#i4dufg)\n\nv1.5.8\n\n * fix: 使用@downloadfile下载文件时，在某些环境下会发送阻塞 (#i4dlbi)\n\nv1.5.7\n\n * fix: response对google protobuf包依赖 (#i4dkqw)\n\nv1.5.6\n\n * feat: 将timeout细化为connecttimeout和readtimeout (#i4dh21)\n * fix: google protobuf包依赖错误 (#i4ddzy)\n * fix: 配置forest.connect-timeout不生效 (#i45298)\n\nv1.5.5\n\n * feat: 支持每个请求都可自定义序列化转换器 (#i4clv8)\n * feat: 二进制类型请求体 (#i4d4gy)\n * feat: protobuf请求体 (#i4d4jt)\n * feat: 转换器对应包依赖 需要时获取 (#i29xe0)\n * fix: getattribute方法在多线程情况下取值会串 (#i4d5ks)\n * fix: 在onretry方法中，调用 addquery 或 addbody 能api无效 (#i4czs5)\n * add: @okhttp3 注解\n * add: @httpclient 注解\n * add: forestrequest.type(forestrequesttype type) 方法\n * add: forestloghandler.logcontent(string content) 方法\n\nv1.5.4\n\n * fix: 依赖guava包 (#i4cc9b)\n * fix: @query注解修饰map参数时，map中的列表属性无法正常序列化 (#i4c8uc)\n * fix: 多线程下的并发问题\n * update: 去掉多余的debug日志\n * add: forestloghandler.logcontent(string content) 方法\n * add: forestrequest.addquery(string name, collection collection) 方法\n * add: forestrequest.addquery(string name, object... array) 方法\n * add: forestrequest.addarrayquery(string name, collection collection) 方法\n * add: forestrequest.addarrayquery(string name, object... array) 方法\n\nv1.5.3\n\n * feat: forest快捷接口 (#i4893q)\n * feat: 支持全局变量动态绑定方法 (#i478n2)\n * feat: 支持引用properties的字符串模板 (#i3p1qk)\n * feat: 支持获取响应原因短语，即响应状态文本 (#i4bjvf)\n * feat: 自定义组合注解 (#i4bisf)\n * feat: 可自定义请求是否成功的条件 (#i4aemt)\n * feat: 可动态设置主机地址和端口号 (#i4aej8)\n * feat: 自定义重试条件 (#i493n3)\n * feat: 新增 onretry 回调函数 (#i493n6)\n * feat: 新增 @headers 注解 (#i4bjq6)\n * feat: forest请求接口继承规则 (#i4b0n7)\n * feat: 自动重定向控制 (#i4b0fm)\n * feat: 全局变量支持动态绑定方法 (#i478n2)\n * feat: 在请求日志中显示后端框架名称 (#i4aktd)\n * feat: 新建forest-mock子项目 (#i468jb)\n * fix: post请求中，空map无法转成{} json字符串 (#i455o2)\n * fix: 过滤器参数总是为第一个参数 (#i43vv0)\n * fix: 自定义请求头content-type会替换为大写 (#i46wnw)\n * fix: 在spring项目中如果不配置转换器就会找不到converter (#i46fkv)\n * fix: response不带content-type和content-encoding头时无法正常解析 (#i455po)\n * fix: 当请求 302 请求时，forest 会自动的访问重定向的url，导致 302 的响应头拿不到 (#i4af3b)\n * fix: springsslkeystore 在spring中初始化失败\n * fix: 配置有forestconfiguration参数的转换器的时候，在springboot中会初始化失败 (#i4akt3)\n * fix: 在多线程环境下使用上传文件接口，运行时间长后会报出堆栈溢出的错误 (#i37ugy)\n * fix: beanpostprocessor 接口在低版本 springboot 环境下不兼容\n * opt: 优化 stringutils 工具类方法\n * opt: 优化 urlutils 工具类方法\n * add: springforestproperties类\n * add: 在所有请求注解中(如 @request, @get)添加 responseencoding 属性，用于强制指定响应数据的编码格式\n * add: springforestobjectfactory类\n * add: forestresponse.isredirection 方法\n * add: forestresponse.getredirectionlocation 方法\n * add: forestresponse.redirectionrequest 方法\n * add: forestheadermap.clone 方法\n * add: forestquerymap.clone 方法\n * refactor: retrycount属性不在建议使用\n * update: 去掉methodlifecycle\n * refactor: 修改forest接口扫描逻辑\n * refactor: 将 typereference 类改为抽象类\n\nv1.5.1\n\n * feat: 添加@urlencode注解 (#i3sr0l)\n * feat: 新增强制urlencoded的字符串模板 (#i3p1r0)\n * feat: 支持对gzip格式返回数据进行解压 (#i3susl)\n * feat: spring项目通过定义bean自动从spring上下文中注入对应的forestconverter (#i3e63m)\n * fix: 在json或xml转换失败后，没有直接报错，而是转成了字符串 (#i3iukc)\n * fix: 在get请求时带有空的body实体 (#i3rbr2)\n * fix: 去掉protobuf decoder 根据返回类型序列化\n * fix: 代理 (#i3e1mf)\n * fix: 遇到非application/json的response header无法正常解析json (#i3ajsd)\n * fix: 调用configuration.getloghandler().setlogger()方法无效 (#i3iukd)\n * fix: okhttp后端情况下，response返回gzip或deflate压缩数据解析乱码 (#i3a54i)\n * fix: 单向ssl不填protocol时报空指针\n * fix: statuscode空指针\n * fix: status在非网络错误情况下为404\n * fix: 修改方法名拼写错误 getdatetype -> getdatatype\n * update: 修改gson版本 -> 2.8.6\n * refactor: 指定统一的spring-boot版本\n * update: 去掉qlexpress\n * add: @urlencode注解\n * add: urlencodelifecycle类\n\nv1.5.0\n\n * feat: 支持application/octet-stream等二进制请求方式 (#i3b3uz)\n * feat: 变量未定义时，报错给予更友好的提示 (#i3doap)\n * feat: 添加@var注解，作为@datavariable注解的简化快捷版本 (#i3e0fd)\n * fix: forestresponse<file>作为返回值使用@downloadfile注解进行下载后getresult()为空(#i3daeq)\n * add: forestconfiguration#isvariabledefined方法\n * add: @var注解\n * add: resourcerequestbody类\n * add: resourcerequestbodybuilder类\n * add: multipartrequestbody类\n * add: multipartrequestbodybuilder类\n * add: supportformurlencoded类\n * refactor: 将datavariablelifecycle改名为variablelifecycle\n * refactor: body的解析方式改为构建器模式\n * refactor: forestvariableundefined.java 改名为 forestvariableundefinedexception\n * update: 更新spring-core和spring-webmvc版本\n * update: 更新junit版本\n\nv1.5.0-rc7\n\n * fix: 反序列化xml为泛型类对象时报错 (#i3b5vh)\n * fix: 全局配置的log-handler不起作用 (#i3b49o)\n\nv1.5.0-rc6\n\n * feat: @loghandler 和 @logenabled 注解作用域添加 elementtype.type级别(#i3ahlc)\n * feat: query参数可以选择是否urlencoded\n * fix: 遇到非application/json的response header无法正常解析json (#i3ajsd)\n * fix: 多模块开发多个@forestscan注解只能扫描到其中一个注解的basepackages\n * fix: 基本类型判断漏掉了boolean\n * refactor: 将 gourpid 'spring-boot-starter-forest' 改为 'forest-spring-boot-starter'\n * refactor: 将 spring-boot-starter-forest 模块改名为 forest-spring-boot-starter\n * refactor: 将forest-spring-boot-starter模块下的包名修改为 'com.dtflys.forest.springboot'\n\nv1.5.0-rc5\n\n * feat: 可以从forestresponse对象获取请求总耗时 (#i39o55)\n * fix: logenabled注解的logresponsecontent在请求失败的情况下无效 (#i39m2g)\n * add: forestresponse.requesttime属性\n * add: forestresponse.responsetime属性\n * add: forestresponse.gettimeasmillisecond方法\n\nv1.5.0-rc4\n\n * fix: 请求不能设置proxy用户名和密码 (#i36sj8)\n * fix: https的url字符串会自动去掉 :80 端口部分 (#i38kej)\n\nv1.5.0-rc3\n\n * fix: 全局配置重试次数，对 [forest] [network error]: read timed out 错误无效 (#i34x5d)\n * fix: url井号(#)后面字符串没有encoding\n * fix: httpclient后端处理cookie时产生'invalid cookie header'的问题\n * refactor: 实现interceptor接口时，不必强制实现onsuccess方法和onerror方法\n\nv1.5.0-rc2\n\n * feat: 支持负数的字符串模板下标引用 (#i2bf4n)\n * feat: @query, @body, @header注解支持defaultvalue默认值属性\n * fix: fastjson使用jsonfield注解的format属性设置日期格式没起效果 (#i29bfm)\n * refactor: 去掉多余的system.out.println命令行输出\n * refactor: forest在spring的xml配置部分\n * add: @query, @body, @header注解的defaultvalue属性\n * add: jsr305依赖\n * add: forestrequest.methodreturn方法和forestrequest.getmethodreturnvalue方法\n * update: 将错误拼写的方法名 handlesyncwicthexception 改为 handlesyncwithexception\n\nv1.5.0-rc1\n\n * feat: 处理cookie (#i1qr18)\n * feat: 通过@formbody注解将参数标识为表单格式的请求体 (#i28my5)\n * feat: @request、@get、@post等请求注解支持增加value属性作为url属性的别名 (#i28fwm)\n * feat: 可以将response返回的\"true\"， \"false\"字符串转换成boolean返回类型 (#i281o0)\n * fix: 用httpclient的方式上传文件会不成功，但用okhttp就是成功的 (#i28sa1)\n * fix: 遇到一些自定义的response content-type，无法正常读取响应内容 (#i28pl7)\n * add: forestcookies类\n * add: forestcookie类\n * add: onloadcookie接口\n * add: onsavecookie接口",charsets:{cjk:!0},lastUpdated:"2022/07/19, 15:12:42",lastUpdatedTimestamp:1658214762e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/forest_logo.png",heroText:"Forest",tagline:"声明式HTTP客户端框架，减轻您的开发负担",actionText:"开始使用 →",actionLink:"/pages/1.5.x/install_guide/",bannerBg:"none",features:[{title:"🍭 容易上手",details:"10分钟即可完成请求的定义、发送、接收、解析、错误处理、日志打印等过程，此外还有直观的API和详尽的文档"},{title:"☕ 简单优雅",details:"将繁复的 HTTP 请求细节封装成 Java 接口 + 注解的形式，不必关心请求发送的具体过程"},{title:"🧩 扩展灵活",details:"能使用自定义拦截器和自定义注解来扩展Forest的能力，即使面对意想不到的场景也能轻松应对"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-160dfc8b",path:"/",headers:[{level:2,title:"🎉 特性",slug:"🎉-特性",normalizedTitle:"🎉 特性",charIndex:14},{level:2,title:"🎨 最新版本",slug:"🎨-最新版本",normalizedTitle:"🎨 最新版本",charIndex:289},{level:2,title:"🛰️ 代码托管",slug:"🛰️-代码托管",normalizedTitle:"🛰️ 代码托管",charIndex:993},{level:2,title:"🥤 开源平台社区",slug:"🥤-开源平台社区",normalizedTitle:"🥤 开源平台社区",charIndex:1010},{level:2,title:"🍻 dromara 组织项目",slug:"🍻-dromara-组织项目",normalizedTitle:"🍻 dromara 组织项目",charIndex:1028}],headersStr:"🎉 特性 🎨 最新版本 🛰️ 代码托管 🥤 开源平台社区 🍻 dromara 组织项目",content:"\n\n\n支持这个项目\n\n\n# 🎉 特性\n\n * 支持 声明式接口，方便与业务代码解耦\n * 支持 编程式接口，方便快速访问请求\n * 支持 OkHttp 和 Httpclient 两种底层框架\n * 不依赖中间件\n * 支持 GET、POST、PUT 等所有请求方法\n * 约定大于配置\n * 自动 JSON、XML、Protobuf 转换\n * 支持 自定义转换器\n * 多种加签方式\n * 支持 Spring 和 Springboot 集成\n * 支持 上传下载\n * 支持 模板表达式\n * 支持 拦截器\n * 支持 自定义注解\n * 支持 异步请求\n\n\n\n\n\n\n\n\n# 🎨 最新版本\n\n<dependency>\n  <groupId>com.dtflys.forest</groupId>\n  <artifactId>forest-spring-boot-starter</artifactId>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n<dependency>\n    <groupId>com.dtflys.forest</groupId>\n    <artifactId>forest-core</artifactId>\n    <version>1.5.25</version>\n</dependency>\n\n<dependency>\n  <groupId>com.dtflys.forest</groupId>\n  <artifactId>forest-spring</artifactId>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n<dependency>\n  <groupId>com.dtflys.forest</groupId>\n  <artifactId>forest-core</artifactId>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n所需环境\n\nJDK版本: 8+\n\n可集成的 spring boot 版本: 1.x, 2.x\n\n也可不依赖 spring boot 和 spring\n\n\n\n\n\n\n# 🛰️ 代码托管\n\n\n\n\n\n\n# 🥤 开源平台社区\n\n\n\n\n\n\n# 🍻 dromara 组织项目\n\n\n\n\n\n",normalizedContent:"\n\n\n支持这个项目\n\n\n# 🎉 特性\n\n * 支持 声明式接口，方便与业务代码解耦\n * 支持 编程式接口，方便快速访问请求\n * 支持 okhttp 和 httpclient 两种底层框架\n * 不依赖中间件\n * 支持 get、post、put 等所有请求方法\n * 约定大于配置\n * 自动 json、xml、protobuf 转换\n * 支持 自定义转换器\n * 多种加签方式\n * 支持 spring 和 springboot 集成\n * 支持 上传下载\n * 支持 模板表达式\n * 支持 拦截器\n * 支持 自定义注解\n * 支持 异步请求\n\n\n\n\n\n\n\n\n# 🎨 最新版本\n\n<dependency>\n  <groupid>com.dtflys.forest</groupid>\n  <artifactid>forest-spring-boot-starter</artifactid>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n<dependency>\n    <groupid>com.dtflys.forest</groupid>\n    <artifactid>forest-core</artifactid>\n    <version>1.5.25</version>\n</dependency>\n\n<dependency>\n  <groupid>com.dtflys.forest</groupid>\n  <artifactid>forest-spring</artifactid>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n<dependency>\n  <groupid>com.dtflys.forest</groupid>\n  <artifactid>forest-core</artifactid>\n  <version>1.5.25</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n所需环境\n\njdk版本: 8+\n\n可集成的 spring boot 版本: 1.x, 2.x\n\n也可不依赖 spring boot 和 spring\n\n\n\n\n\n\n# 🛰️ 代码托管\n\n\n\n\n\n\n# 🥤 开源平台社区\n\n\n\n\n\n\n# 🍻 dromara 组织项目\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/08/02, 19:12:52",lastUpdatedTimestamp:1659438772e3}],themeConfig:{nav:[{text:"💒 首页",link:"/"},{text:"📚 文档",link:"/pages/1.5.x/intro/",items:[{text:"v1.5.x",link:"/pages/1.5.x/intro/"}]},{text:"💖 支持",link:"/pages/donate/"},{text:"🛫 更新记录",link:"/pages/releases/"},{text:"🧢 关于作者",link:"/pages/about_author/"},{text:"⚒️ 参与贡献",link:"/pages/contribute/"},{text:"Gitee",link:"https://gitee.com/dromara/forest"},{text:"Github",link:"https://github.com/dromara/forest"}],sidebarDepth:2,logo:"/img/logo.png",searchMaxSuggestions:10,lastUpdated:"上次更新",docsRepo:"dt_flys/forest-website",docsDir:"docs",editLinks:!0,editLinkText:"帮助我们改善此文档",version:"1.5.25",sidebar:{"/001.v1.5.x文档/":[{title:"序言",collapsable:!1,children:[["010.序言/001.intro.md","🎁 新手介绍","/pages/1.5.x/intro/"],["010.序言/002.docs.md","📖 文档","/pages/1.5.x/docs/"],["010.序言/003.author.md","🕵️‍ 联系作者","/pages/1.5.x/author/"],["010.序言/004.contributors.md","👨‍🎓 贡献者列表","/pages/1.5.x/contributors/"]]},{title:"入门",collapsable:!1,children:[["020.入门/001.install_guide.md","🎬 安装配置说明","/pages/1.5.x/install_guide/"],["020.入门/002.spring_boot_install.md","🏹 Springboot环境安装","/pages/1.5.x/spring_boot_install/"],["020.入门/003.spring_boot_config.md","📐 Springboot环境配置","/pages/1.5.x/spring_boot_config/"],["020.入门/004.spring_boot_usage.md","🎯 Springboot环境使用","/pages/1.5.x/spring_boot_usage/"],["020.入门/005.spring_install.md","🏹 Spring环境安装","/pages/1.5.x/spring_install/"],["020.入门/006.spring_config.md","📐 Spring环境配置","/pages/1.5.x/spring_config/"],["020.入门/007.spring_usage.md","🎯 Spring环境使用","/pages/1.5.x/spring_usage/"],["020.入门/008.java_install.md","🏹 原生Java环境安装","/pages/1.5.x/java_install/"],["020.入门/009.java_config.md","📐 原生Java环境配置","/pages/1.5.x/java_config/"],["020.入门/010.java_usage.md","🎯 原生Java环境使用","/pages/1.5.x/java_usage/"],["020.入门/011.param_api.md","🧬 编程式接口","/pages/1.5.x/param_api/"]]},{title:"配置项",collapsable:!1,children:[["030.配置项/001.spring_boot_config_items.md","👜 Springboot环境配置项","/pages/1.5.x/spring_boot_config_items/"],["030.配置项/002.spring_config_items.md","👝 Spring环境配置项","/pages/1.5.x/spring_config_items/"],["030.配置项/003.java_config_items.md","🎒 原生Java环境配置项","/pages/1.5.x/java_config_items/"],["030.配置项/004.config_level.md","📚 配置优先级/作用域","/pages/1.5.x/config_level/"]]},{title:"声明式接口",collapsable:!1,children:[["040.声明式接口/001.build_interface.md","🧱 构建接口","/pages/1.5.x/build_interface/"],["040.声明式接口/002.http_method.md","🍀 请求方法","/pages/1.5.x/http_method/"],["040.声明式接口/003.http_url.md","🚚 请求地址","/pages/1.5.x/http_url/"],["040.声明式接口/004.http_query.md","🎈 URL 参数","/pages/http_query/"],["040.声明式接口/005.http_header.md","🍭 请求头","/pages/1.5.x/http_header/"],["040.声明式接口/006.http_body.md","👔 请求体","/pages/1.5.x/http_body/"],["040.声明式接口/007.backend.md","🍮 后端框架","/pages/1.5.x/backend/"],["040.声明式接口/008.base_request.md","🧁 接口注解","/pages/1.5.x/base_request/"],["040.声明式接口/009.receive_data.md","📬 接收数据","/pages/1.5.x/receive_data/"],["040.声明式接口/010.converter.md","🍛 数据转换","/pages/1.5.x/converter/"],["040.声明式接口/011.success.md","🍓 成功/失败条件","/pages/1.5.x/success/"],["040.声明式接口/012.retry.md","🍌 重试机制","/pages/1.5.x/retry/"],["040.声明式接口/013.redirection.md","🥂 重定向","/pages/1.5.x/redirection/"],["040.声明式接口/014.decompress.md","🍔 Gzip解压","/pages/1.5.x/decompress/"],["040.声明式接口/015.logs.md","🎂 日志管理","/pages/1.5.x/logs/"],["040.声明式接口/016.callback.md","⚽ 回调函数","/pages/1.5.x/callback/"],["040.声明式接口/017.async.md","🍟 异步请求","/pages/1.5.x/async/"],["040.声明式接口/018.https.md","🛡️ HTTPS","/pages/1.5.x/https/"],["040.声明式接口/019.cookie.md","🍪 使用Cookie","/pages/1.5.x/cookie/"],["040.声明式接口/020.proxy.md","🛸 使用代理","/pages/1.5.x/proxy/"],["040.声明式接口/021.upload_download.md","🍉 上传下载","/pages/1.5.x/upload_download/"],["040.声明式接口/022.exception.md","🚑 异常处理","/pages/1.5.x/exception/"]]},{title:"编程式接口",collapsable:!1,children:[{title:"请求API",collapsable:!1,children:[["050.编程式接口/010.请求API/001.api_forest_request.md","🚀 请求对象","/pages/1.5.x/api_forest_request/"],["050.编程式接口/010.请求API/002.api_request_properties.md","🚢 请求属性","/pages/1.5.x/api_request_prop/"],["050.编程式接口/010.请求API/003.api_execute.md","✨ 执行请求","/pages/1.5.x/api_execute/"],["050.编程式接口/010.请求API/004.api_backend.md","🎊 后端框架","/pages/1.5.x/api_backend/"],["050.编程式接口/010.请求API/005.api_request_type.md","🎪 请求类型","/pages/1.5.x/api_request_type/"],["050.编程式接口/010.请求API/006.api_request_address.md","🔮 请求地址","/pages/1.5.x/api_request_address/"],["050.编程式接口/010.请求API/007.api_request_query.md","🧀 URL 参数","/pages/api_request_query/"],["050.编程式接口/010.请求API/008.api_request_header.md","🚅 请求头","/pages/1.5.x/api_request_header/"],["050.编程式接口/010.请求API/009.api_request_body.md","🚋 请求体","/pages/1.5.x/api_request_body/"],["050.编程式接口/010.请求API/010.api_request_async.md","🚁 同步/异步","/pages/1.5.x/api_request_async/"],["050.编程式接口/010.请求API/011.api_callback.md","⚓ 回调函数","/pages/1.5.x/api_callback/"],["050.编程式接口/010.请求API/012.api_cookie.md","🥯 Cookie","/pages/1.5.x/api_cookie/"],["050.编程式接口/010.请求API/013.api_success.md","🍜 成功/失败条件","/pages/1.5.x/api_success/"],["050.编程式接口/010.请求API/014.api_retry.md","🌶️ 重试机制","/pages/1.5.x/api_retry/"],["050.编程式接口/010.请求API/015.api_redirection.md","⛵ 重定向","/pages/1.5.x/api_redirection/"],["050.编程式接口/010.请求API/016.api_proxy.md","🛰️ 请求代理","/pages/1.5.x/api_proxy/"]]},{title:"响应API",collapsable:!1,children:[["050.编程式接口/020.响应API/001.api_forest_response.md","🌠 响应对象","/pages/1.5.x/api_forest_response/"],["050.编程式接口/020.响应API/002.api_response_read.md","✒️ 读取数据","/pages/1.5.x/api_response_read/"],["050.编程式接口/020.响应API/003.api_response_status.md","🦋 响应状态码","/pages/1.5.x/api_response_status/"],["050.编程式接口/020.响应API/004.api_response_error.md","🏥 响应错误处理","/pages/1.5.x/api_response_error/"],["050.编程式接口/020.响应API/005.api_response_hreader.md","🎧 响应头","/pages/1.5.x/api_response_hreader/"],["050.编程式接口/020.响应API/006.api_response_cookie.md","🥞 Cookie","/pages/1.5.x/api_response_cookie/"]]}]},{title:"模板表达式",collapsable:!1,children:[["060.模板表达式/001.hello_world.md","🍬 Hello World","/pages/1.5.x/hello_world/"],["060.模板表达式/002.refer_prop.md","🍹 配置属性引用","/pages/1.5.x/refer_prop/"],["060.模板表达式/003.binding_var.md","🥃 动态变量绑定","/pages/1.5.x/binding_var/"],["060.模板表达式/004.refer_index.md","🥗 参数序号引用","/pages/1.5.x/refer_index/"],["060.模板表达式/005.refer_attr.md","🍍 引用对象属性","/pages/1.5.x/refer_attr/"],["060.模板表达式/006.invoke.md","🥝 调用对象方法","/pages/1.5.x/invoke/"],["060.模板表达式/007.refer_var.md","🍖 变量引用","/pages/1.5.x/refer_var/"]]},{title:"高级特性",collapsable:!1,children:[["070.高级特性/001.interceptor.md","🥪 拦截器","/pages/1.5.x/interceptor/"],["070.高级特性/002.custom_annotation.md","🍏 自定义注解","/pages/1.5.x/custom_annotation/"],["070.高级特性/003.makeup_annotation.md","🍇 组合注解","/pages/1.5.x/makeup_annotation/"],["070.高级特性/004.custom_converter.md","🥑 自定义转换器","/pages/custom_converter/"]]}],catalogue:{}},updateBar:{showToArticle:!1},titleBadge:!1,category:!1,tag:!1,author:{name:"公子骏",href:"https://gitee.com/dt_flys"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:dt_flys@hotmail.com"},{iconClass:"icon-gitee",title:"Gitee",link:"https://gitee.com/dromara/forest"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dromara/forest"}]},footer:{createYear:2016,copyrightInfo:"公子骏 | MIT License"},htmlModules:{pageT:'\n  <div class="wwads-cn wwads-horizontal page-ad" data-id="128" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .page-ad img{\n      width:80px!important;\n    }\n    .wwads-horizontal .wwads-content{\n      display: flex;\n      align-items: center;\n    }\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{\n      line-height:1;\n      flex: 1;\n      height: 100%;\n      display: flex;\n      align-items: center;\n    }\n    .wwads-horizontal .wwads-poweredby, .wwads-vertical .wwads-poweredby{display: none;!important;}\n  </style>\n  '}}};var yl=t(92),vl=t(93),bl=t(11);var xl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(bl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(bl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(bl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,o=n.length;r<o;r++){const{frontmatter:{categories:o,tags:s}}=n[r];"array"===Object(bl.n)(o)&&o.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(bl.n)(s)&&s.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ht.component(yl.default),Ht.component(vl.default);function kl(n){return n.toString().padStart(2,"0")}t(235);Ht.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,403))),Ht.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,93))),Ht.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,92)));t(236);var _l=[({Vue:n,options:e,router:t,siteData:r,isServer:o})=>{o||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>万维</span><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-ad");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${kl(n.getUTCMonth()+1)}-${kl(n.getUTCDate())} ${kl(n.getUTCHours())}:${kl(n.getUTCMinutes())}:${kl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(xl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",o.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#4aa962"}),e.body.appendChild(t)}var o=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<o.length;t++)o[t].alpha<=0?(e.body.removeChild(o[t].el),o.splice(t,1)):(o[t].y--,o[t].scale+=.004,o[t].alpha-=.013,o[t].el.style.cssText="left:"+o[t].x+"px;top:"+o[t].y+"px;opacity:"+o[t].alpha+";transform:scale("+o[t].scale+","+o[t].scale+") rotate(45deg);background:"+o[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?a43b3ffd957a0307e4e9335897f9f79f";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Sl=[];class Tl extends class{constructor(){this.store=new Ht({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ht.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Tl.prototype,{getPageAsyncComponent:ti,getLayoutAsyncComponent:ri,getAsyncComponent:oi,getVueComponent:si});var wl={install(n){const e=new Tl;n.$vuepress=e,n.prototype.$vuepress=e}};function ql(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Cl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ii("pageKey",e),Ht.component(e)||Ht.component(e,ti(e)),Ht.component(e)?n(e):n("")}},El={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Fl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},jl=(t(237),t(238),Object(fl.a)(Fl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Rl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ht.config.productionTip=!1,Ht.use($a),Ht.use(wl),Ht.mixin(function(n,e,t=Ht){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),s={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),s),{computed:s}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},gl)),Ht.component("Content",Cl),Ht.component("ContentSlotsDistributor",El),Ht.component("OutboundLink",jl),Ht.component("ClientOnly",Rl),Ht.component("Layout",ri("Layout")),Ht.component("NotFound",ri("NotFound")),Ht.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"db62b4a"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:gl.routerBase||gl.base,t=new $a({base:e,mode:"history",fallback:!1,routes:ml,scrollBehavior:(n,e,t)=>t||(n.hash?!Ht.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(ql(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";ql(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";ql(n,o)?r(o):ql(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(_l.filter(n=>"function"==typeof n).map(e=>e({Vue:Ht,options:r,router:t,siteData:gl,isServer:n})))}catch(n){console.error(n)}return{app:new Ht(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Sl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);