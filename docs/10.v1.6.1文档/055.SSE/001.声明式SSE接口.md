---
id: sse_declarative
hide_title: true
title: 声明式 SSE 接口
date: 2022-07-01 12:44:20
permalink: /pages/1.6.1/sse_declarative/
---

## SSE

SSE（Server-Sent Events），也被称作“事件流”（Event Stream），是一种旨在通过HTTP协议来实现服务器主动向客户端推送数据的技术手段。
它可以在客户端与服务器之间建立一条持久化的HTTP长连接，并通过这条连接实现服务器向客户端的实时数据推送，但客户端不能通过 SSE 向服务端发送数据。

自`v1.6.1`版本之后，Forest 提供了对 SSE 的支持，并且支持`声名式`和`编程式`两种 SSE 请求方式。

## 声明式 SSE 接口

### 接口定义

SSE 的声名式接口定义方式和普通 HTTP 接口定义方式类型，只需要将`ForestSSE`类作为接口方法的返回值类型即可，调用该方法后即可返回`ForestSSE`类的对象实例。

`ForestSSE`是 Forest 的 SSE 控制器类，通过此类对象可以进行监听、添加消息回调函数等操作。

```java
public interface SSEClient {
    
    // ForestSSE 为 Forest 的 SSE 控制器类
    // 只要以此类作为方法的返回值类型，该方法就自动成为 SSE 请求方法
    @Get("/sse")
    ForestSSE testSSE();
}
```

### 监听事件

调用接口方法后会返回`ForestSSE`类对象，此时变化把普通的 HTTP 请求转换为 SSE 控制器,但不会发送任何实际的网络请求。

```java
sseClient.testSSE(); // 把普通的 HTTP 请求转换为 SSE 控制器,但不会发送任何实际的网络请求
```

得到 SSE 控制器之后，便可调用`listen()`方法开始监听 SSE 的事件流，并阻塞当前调用的线程。

```java
sseClient.testSSE().listen(); // 开始监听 SSE 事件流，并阻塞当前线程
```

### 异步监听

ForestSSE 控制器中的`listen()`方法是一种同步的监听方法，另外 Forset 也提供了异步的监听方法：`asyncListen()`

```java
sseClient.testSSE().asyncListen(); // 开始异步监听 SSE 事件流，并且不会阻塞当前线程
```


## 事件处理

在上面的例子中，我们可以通过`listen()`和`asyncListen()`方法进行事件监听，但若在此时接受到实际事件消息，并不会进行任何处理。

如要针对不同事件内容，进行响应的处理，就需要通过以下代码来添加事件消息的回调函数：

```java
sseClient.testSSE() // 调用接口方法后返回 ForestSSE 对象
        .setOnOpen(eventSource -> {
            // SSE 开始监听时调用
            // eventSource 为 EventSource 事件源对象
            eventSource.getRequest(); // 获取 Forest 请求对象
            eventSource.getResponse(); // 获取 Forest 响应对象
        })
        .setOnClose((req, res) -> {
            // SSE 开始监听时调用
            // req 为 Forest 请求对象
            // res 为 Forest 响应对象
        })
        .addOnData((eventSource, name, value) -> {
            // 处理事件消息名称为 data 的事件
            // name 为事件消息名称 (同 eventSource.getName())
            // value 为事件消息的值
            eventSource.getRequest(); // 获取 Forest 请求对象
            eventSource.getResponse(); // 获取 Forest 响应对象
            eventSource.getRawData(); // 获取事件消息的原始数据
            eventSource.getName(); // 获取事件消息的名称，如 data、event、id 等
            eventSource.getValue(); // 获取事件消息的值
        })
        .addOnEvent((eventSource, name, value) -> {
            // 处理事件消息名称为 event 的事件
            // 参数内容与上面的 addOnData 回调函数参数相同
            if ("close".equals(value)) {
                eventSource.close(); // 手动关闭事件流，停止 SSE 监听
            }
        })
        .addOnId((eventSource, name, value) -> {
            // 处理事件消息名称为 id 的事件
            // 参数内容与上面的 addOnData 或 addOnEvent 回调函数参数相同
        })
        .addOnRetry((eventSource, name, value) -> {
            // 处理事件消息名称为 retry 的事件
            // 参数内容与上面的几个回调函数参数相同
        })
        .listen(); // 开始监听 SSE 事件流
```

`addOnData`、`addOnEvent`以及`addOnId`等函数都是监听内置固定消息名称的方法，也可以调用`addConsumer`方法来处理非固定的，通过字符串参数指定的消息名称的事件

```java
sseClient.testSSE() // 调用接口方法后返回 ForestSSE 对象
        .addConsumer("data", (eventSource, name, value) -> {
            // 通过字符串参数指定要监听的消息名称
            // 第一个参数传入 "data"，就会监听消息名称为 data 的事件
            // 参数内容与上面的 addOnData、addOnId 等回调函数参数一致
        })
        .addConsumer("event", (eventSource, name, value) -> {
            // 通过字符串参数，来指定要监听消息名为 event 的事件
        })
        .addConsumer("push", (eventSource, name, value) -> {
            // 当然也可以指定非标准的消息名称
        })
        .listen(); // 开始监听 SSE 事件流
```